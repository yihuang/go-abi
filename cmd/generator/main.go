package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"go/format"
	"io"
	"os"
	"strings"
	"text/template"
)

// ABI types from Ethereum ABI specification
type (
	// ABI represents the entire contract ABI
	ABI []ABIElement

	// ABIElement represents a single element in the ABI
	ABIElement struct {
		Type            string          `json:"type"`
		Name            string          `json:"name,omitempty"`
		Inputs          []ABIParameter  `json:"inputs,omitempty"`
		Outputs         []ABIParameter  `json:"outputs,omitempty"`
		StateMutability string          `json:"stateMutability,omitempty"`
		Anonymous       bool            `json:"anonymous,omitempty"`
	}

	// ABIParameter represents a function parameter or return value
	ABIParameter struct {
		Name         string `json:"name"`
		Type         string `json:"type"`
		InternalType string `json:"internalType,omitempty"`
		Components   []ABIParameter `json:"components,omitempty"`
		Indexed      bool   `json:"indexed,omitempty"`
	}
)

// Config holds the generator configuration
type Config struct {
	ABIFile    string
	OutputFile string
	Package    string
}

var (
	abiFile    = flag.String("abi", "", "Path to ABI JSON file")
	outputFile = flag.String("out", "bindings.go", "Output Go file")
	pkgName    = flag.String("pkg", "main", "Package name for generated code")
)

func main() {
	flag.Parse()

	if *abiFile == "" {
		fmt.Fprintf(os.Stderr, "Error: -abi flag is required\n")
		os.Exit(1)
	}

	config := Config{
		ABIFile:    *abiFile,
		OutputFile: *outputFile,
		Package:    *pkgName,
	}

	if err := generate(config); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated bindings in %s\n", config.OutputFile)
}

func generate(config Config) error {
	// Read ABI file
	abiData, err := os.ReadFile(config.ABIFile)
	if err != nil {
		return fmt.Errorf("reading ABI file: %w", err)
	}

	// Parse ABI JSON
	var abi ABI
	if err := json.Unmarshal(abiData, &abi); err != nil {
		return fmt.Errorf("parsing ABI JSON: %w", err)
	}

	// Generate code
	code, err := generateCode(config, abi)
	if err != nil {
		return fmt.Errorf("generating code: %w", err)
	}

	// Format code
	formatted, err := format.Source([]byte(code))
	if err != nil {
		return fmt.Errorf("formatting code: %w", err)
	}

	// Write output file
	if err := os.WriteFile(config.OutputFile, formatted, 0644); err != nil {
		return fmt.Errorf("writing output file: %w", err)
	}

	return nil
}

func generateCode(config Config, abi ABI) (string, error) {
	var buf strings.Builder

	// Write header
	buf.WriteString(fmt.Sprintf(`// Code generated by go-abi generator. DO NOT EDIT.

package %s

import (
	"math/big"
	"github.com/huangyi/go-abi/pkg/abi"
)

`, config.Package))

	// Process each ABI element
	for _, elem := range abi {
		switch elem.Type {
		case "function":
			if err := generateFunction(&buf, elem); err != nil {
				return "", err
			}
		case "event":
			if err := generateEvent(&buf, elem); err != nil {
				return "", err
			}
		case "constructor":
			// Constructors are handled differently
		case "fallback", "receive":
			// Fallback/receive functions
		}
	}

	return buf.String(), nil
}

func generateFunction(w io.Writer, elem ABIElement) error {
	// Generate function signature
	funcName := strings.Title(elem.Name)

	tmpl := `// {{.FuncName}} represents the {{.OriginalName}} function
type {{.FuncName}} struct {
	// Function parameters
	{{- range .Inputs}}
	{{.Name | title}} {{.Type | goType}}
	{{- end}}
}

// Encode encodes the function call
func (f {{.FuncName}}) Encode() ([]byte, error) {
	// TODO: Implement encoding
	return nil, nil
}

// Decode decodes function call data
func (f *{{.FuncName}}) Decode(data []byte) error {
	// TODO: Implement decoding
	return nil
}

`

	data := struct {
		FuncName     string
		OriginalName string
		Inputs       []ABIParameter
	}{
		FuncName:     funcName,
		OriginalName: elem.Name,
		Inputs:       elem.Inputs,
	}

	t := template.Must(template.New("function").Funcs(template.FuncMap{
		"title":  strings.Title,
		"goType": toGoType,
	}).Parse(tmpl))

	return t.Execute(w, data)
}

func generateEvent(w io.Writer, elem ABIElement) error {
	eventName := strings.Title(elem.Name)

	tmpl := `// {{.EventName}} represents the {{.OriginalName}} event
type {{.EventName}} struct {
	// Event parameters
	{{- range .Inputs}}
	{{.Name | title}} {{.Type | goType}}
	{{- end}}
}

// EncodeTopics encodes indexed parameters for event filtering
func (e {{.EventName}}) EncodeTopics() [][]byte {
	// TODO: Implement topic encoding
	return nil
}

// Decode decodes event data
func (e *{{.EventName}}) Decode(data []byte, topics [][]byte) error {
	// TODO: Implement decoding
	return nil
}

`

	data := struct {
		EventName    string
		OriginalName string
		Inputs       []ABIParameter
	}{
		EventName:    eventName,
		OriginalName: elem.Name,
		Inputs:       elem.Inputs,
	}

	t := template.Must(template.New("event").Funcs(template.FuncMap{
		"title":  strings.Title,
		"goType": toGoType,
	}).Parse(tmpl))

	return t.Execute(w, data)
}

// toGoType converts ABI types to Go types
func toGoType(abiType string) string {
	switch {
	case strings.HasPrefix(abiType, "uint"):
		return "*big.Int"
	case strings.HasPrefix(abiType, "int"):
		return "*big.Int"
	case abiType == "bool":
		return "bool"
	case abiType == "address":
		return "[20]byte"
	case abiType == "string":
		return "string"
	case abiType == "bytes":
		return "[]byte"
	case strings.HasPrefix(abiType, "bytes"):
		return "[]byte"
	case strings.HasPrefix(abiType, "tuple"):
		return "struct{}" // Will be replaced with actual struct
	default:
		return "interface{}"
	}
}