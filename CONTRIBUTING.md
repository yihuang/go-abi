# Contributing to go-abi

Thank you for your interest in contributing to go-abi! This document provides guidelines and instructions for contributing to the project.

## Table of Contents

- [Code of Conduct](#code-of-conduct)
- [Getting Started](#getting-started)
- [Development Workflow](#development-workflow)
- [Coding Standards](#coding-standards)
- [Testing](#testing)
- [Benchmarking](#benchmarking)
- [Documentation](#documentation)
- [Code Generation](#code-generation)
- [Pull Request Process](#pull-request-process)

## Code of Conduct

This project adheres to the principle of creating high-quality, maintainable code. By participating, you are expected to uphold this code of conduct.

- Be respectful and inclusive
- Focus on constructive feedback
- Help maintain a welcoming environment
- Write clean, well-documented code

## Getting Started

### Prerequisites

- Go 1.21 or later
- git

### Setup

1. Fork the repository on GitHub
2. Clone your fork:

```bash
git clone https://github.com/your-username/go-abi.git
cd go-abi
```

3. Add the upstream repository as a remote:

```bash
git remote add upstream https://github.com/yihuang/go-abi.git
```

4. Verify your setup:

```bash
go test ./...
go generate ./...
```

### Building

Build all packages:

```bash
go build ./...
```

Build the command-line tool:

```bash
go build ./cmd
```

## Development Workflow

### Branch Naming

Use descriptive branch names:

- `feature/description-of-feature`
- `bugfix/issue-number-description`
- `docs/improvement-description`
- `refactor/scope-of-refactoring`

### Common Workflow

1. Create a new branch from `main`:

```bash
git checkout -b feature/your-feature-name
```

2. Make your changes
3. Run tests and generate code:

```bash
go test ./...
go generate ./...
```

4. Commit your changes with a clear message:

```bash
git commit -m "feat: add support for XYZ"
```

5. Push to your fork:

```bash
git push origin feature/your-feature-name
```

6. Create a pull request on GitHub

## Coding Standards

### Go Standards

Follow these Go coding standards:

1. **Formatting**: Use `gofmt` or `goimports`
2. **Naming**: Use CamelCase for exported names, camelCase for unexported
3. **Error Handling**: Always check errors, never ignore them with `_`
4. **Packages**: Use short, concise package names
5. **Documentation**: Document all exported types, functions, and methods

### Project-Specific Standards

1. **Generated Code**: Never edit generated code files (`.abi.go` files). These are generated by `go generate`.
2. **Documentation**: Update documentation when you change functionality
3. **Tests**: Write tests for new features
4. **Benchmarks**: Add benchmarks for performance-critical code

### Code Style Checklist

- [ ] Code is formatted with `go fmt` or `goimports`
- [ ] All public APIs are documented
- [ ] Error messages are clear and actionable
- [ ] Variable names are descriptive
- [ ] Complex logic has comments
- [ ] No commented-out code

## Testing

### Running Tests

Run all tests:

```bash
go test ./...
```

Run tests with verbose output:

```bash
go test -v ./...
```

Run specific test:

```bash
go test -run TestFunctionName ./...
```

Run tests with coverage:

```bash
go test -coverprofile=coverage.out ./...
go tool cover -html=coverage.out
```

### Writing Tests

1. Test files end with `_test.go`
2. Test functions start with `Test`
3. Use table-driven tests for multiple cases
4. Test both success and failure cases
5. Use `testing.T` and `testing.B` for benchmarks

Example test:

```go
func TestEncodeAddress(t *testing.T) {
    tests := []struct {
        name    string
        input   common.Address
        want    []byte
    }{
        {
            name: "zero address",
            input: common.Address{},
            want:  bytes.Repeat([]byte{0}, 32),
        },
        // ... more tests
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            buf := make([]byte, 32)
            got, err := encodeAddress(tt.input, buf)
            if err != nil {
                t.Fatalf("encodeAddress() error = %v", err)
            }
            if got != 32 {
                t.Fatalf("encodeAddress() returned %d bytes, want 32", got)
            }
            if !bytes.Equal(buf, tt.want) {
                t.Errorf("encodeAddress() = %x, want %x", buf, tt.want)
            }
        })
    }
}
```

## Benchmarking

### Running Benchmarks

Run all benchmarks:

```bash
go test -bench=. ./...
```

Run specific benchmark:

```bash
go test -bench=BenchmarkEncode ./...
```

Run benchmarks with memory allocation reporting:

```bash
go test -bench=. -benchmem ./...
```

### Writing Benchmarks

Benchmark functions start with `Benchmark` and take `*testing.B`:

```go
func BenchmarkEncodeComplex(b *testing.B) {
    data := createTestData()
    b.ResetTimer()

    for i := 0; i < b.N; i++ {
        _, err := data.Encode()
        if err != nil {
            b.Fatal(err)
        }
    }
}
```

Benchmark guidelines:

1. Create test data outside `b.ResetTimer()`
2. Use `b.ResetTimer()` to exclude setup time
3. Report memory allocations with `-benchmem`
4. Compare against go-ethereum when applicable

## Documentation

### Types of Documentation

1. **Code Documentation**: Comments in `.go` files using `//`
2. **API Documentation**: Godoc format
3. **Design Documentation**: Markdown files in `docs/`
4. **Examples**: Real-world usage examples in `examples/`

### Writing Documentation

1. Use clear, concise language
2. Provide examples for complex APIs
3. Update CHANGELOG.md for notable changes
4. Include design rationale for significant changes

### Example Documentation

```go
// EncodeAddress encodes an Ethereum address to ABI format.
// The address is left-padded to 32 bytes as per the ABI specification.
//
// Example:
//     addr := common.HexToAddress("0x1234567890123456789012345678901234567890")
//     buf := make([]byte, 32)
//     n, err := EncodeAddress(addr, buf)
//     // buf now contains the encoded address
func EncodeAddress(addr common.Address, buf []byte) (int, error) {
    // ... implementation
}
```

## Code Generation

### How Code Generation Works

The project uses `go:generate` directives to automatically generate code:

1. Human-readable ABI definitions in `.go` files
2. Run `go generate` to create `.abi.go` files
3. Generated files contain encode/decode functions

### Modifying the Generator

If you need to modify the code generator:

1. Edit files in `generator/` directory
2. Rebuild the generator:

```bash
go build -o cmd/go-abi ./generator
```

3. Regenerate code:

```bash
go generate ./...
```

4. Run tests to verify changes

### Regenerating Code

Always regenerate code after changing the generator:

```bash
go generate ./...
```

The CI will check that generated code is up to date. If `git diff` shows changes after `go generate`, the PR will fail.

## Pull Request Process

### Before Submitting

1. **Tests Pass**: Ensure all tests pass locally
2. **Code Generated**: Run `go generate ./...` and commit changes
3. **Documentation**: Update documentation as needed
4. **CHANGELOG**: Add entry to CHANGELOG.md if significant change
5. **Reformat**: Ensure code is properly formatted

### Pull Request Checklist

- [ ] Code follows project standards
- [ ] Tests pass locally
- [ ] Code is generated and committed
- [ ] Documentation is updated
- [ ] CHANGELOG.md is updated (if applicable)
- [ ] Commit message follows conventional commits format

### Commit Message Format

Use conventional commits format:

```
type(scope): description

[optional body]

[optional footer(s)]
```

Types:
- `feat`: New feature
- `fix`: Bug fix
- `docs`: Documentation changes
- `style`: Code style changes (formatting, etc.)
- `refactor`: Code refactoring
- `test`: Adding or updating tests
- `chore`: Maintenance tasks

Examples:

```
feat: add support for tuple arrays
fix: resolve bounds check issue in nested arrays
docs: update code generator documentation
test: add benchmark for complex tuple encoding
```

### Review Process

1. All PRs require at least one reviewer
2. Address reviewer feedback
3. CI must pass (tests, build, code generation)
4. Rebase if needed to keep history clean

### After Merge

1. Pull the latest `main` from upstream
2. Your branch can be deleted
3. Update your fork's main branch

## Additional Resources

- [Go Testing Documentation](https://golang.org/doc/tutorial/add-a-test)
- [Effective Go](https://golang.org/doc/effective_go)
- [Go Code Review Comments](https://github.com/golang/go/wiki/CodeReviewComments)
- [Ethereum ABI Specification](https://docs.soliditylang.org/en/latest/abi-spec.html)

## Questions?

If you have questions about contributing:

1. Check existing issues and PRs
2. Create a new issue with the `question` label
3. Reach out to maintainers

Thank you for contributing to go-abi!
