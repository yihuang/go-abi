package generator

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"slices"
	"strings"
	"text/template"

	ethabi "github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/yihuang/go-abi"
)

var (
	DefaultImports = []ImportSpec{
		{Path: "fmt"},
		{Path: "encoding/binary"},
		{Path: "math/big"},
		{Path: "github.com/ethereum/go-ethereum/common"},
		{Path: "github.com/ethereum/go-ethereum/crypto"},
	}
)

type M = map[string]interface{}

// ImportSpec represents a Go import with optional alias
type ImportSpec struct {
	Path  string
	Alias string // empty string means no alias
}

// SelectorInfo holds information about a function selector
type SelectorInfo struct {
	Name  string
	Sig   string
	Bytes [4]byte
}

// Generator handles ABI code generation with standalone functions
// This is a new approach that generates standalone encoding/decoding functions
// for each ABI type, allowing recursive composition and code reuse.
type Generator struct {
	buf bytes.Buffer

	Options   Options
	Imports   []ImportSpec
	Selectors []SelectorInfo
	StdPrefix string
}

// NewGenerator creates a new ABI code generator with standalone functions
func NewGenerator(opts ...Option) *Generator {
	opt := NewOptions(opts...)

	defaultImports := slices.Clone(DefaultImports)
	stdPrefix := ""
	if !opt.Stdlib {
		defaultImports = append(defaultImports, ImportSpec{Path: "github.com/yihuang/go-abi"})
		stdPrefix = "abi."
	}

	return &Generator{
		Options:   *opt,
		Imports:   append(defaultImports, opt.ExtraImports...),
		Selectors: []SelectorInfo{},
		StdPrefix: stdPrefix,
	}
}

func (g *Generator) L(format string, args ...any) {
	fmt.Fprintf(&g.buf, format, args...)
	fmt.Fprint(&g.buf, "\n")
}

func (g *Generator) T(tpl string, m map[string]interface{}) {
	t := template.Must(template.New("").Parse(tpl))
	t.Execute(&g.buf, m)
}

// GenerateFromABI generates Go code from ABI JSON using standalone functions
func (g *Generator) GenerateFromABI(abiDef ethabi.ABI) (string, error) {
	// Write do not edit warning
	g.L("// Code generated by go-abi. DO NOT EDIT.")
	g.L("")

	// Write package declaration
	g.L("package %s", g.Options.PackageName)
	g.L("")

	// Write imports
	if len(g.Imports) > 0 {
		g.L("import (")
		for _, imp := range g.Imports {
			if imp.Alias != "" {
				g.L("\t%s \"%s\"", imp.Alias, imp.Path)
			} else {
				g.L("\t\"%s\"", imp.Path)
			}
		}
		g.L(")")
		g.L("")
	}

	// First, collect all tuple types needed for this ABI
	var methods []ethabi.Method
	for _, name := range SortedMapKeys(abiDef.Methods) {
		methods = append(methods, abiDef.Methods[name])
	}

	// Generate all selector constants at the beginning
	g.genAllSelectors(methods)

	// Generate all tuple structs needed for this function FIRST
	// This ensures tuple types are available for encoding function generation
	g.genTuples(methods)

	// Collect all types needed for encoding functions (excluding tuple types)
	allTypes := g.collectAllTypes(methods)

	// Now generate functions in the order they were collected
	for _, t := range allTypes {
		g.genEncodingFunction(t)
	}

	// Generate size functions after encoding functions
	for _, t := range allTypes {
		if !IsDynamicType(t) {
			continue
		}

		g.genSizeFunction(t)
	}

	// Generate decoding functions after encoding and size functions
	for _, t := range allTypes {
		g.genDecodingFunction(t)
	}

	// Generate code for each function
	for _, method := range methods {
		g.genFunction(method)
	}

	var events []ethabi.Event
	for _, name := range SortedMapKeys(abiDef.Events) {
		events = append(events, abiDef.Events[name])
	}

	g.genAllEventTopics(events)

	// Generate code for each event
	for _, name := range SortedMapKeys(abiDef.Events) {
		event := abiDef.Events[name]
		g.genEvent(event)
	}

	// Format the generated code
	return string(g.buf.Bytes()), nil
}

// collectAllTypes collects all unique ABI types needed for encoding functions
func (g *Generator) collectAllTypes(methods []ethabi.Method) []ethabi.Type {
	typeSet := make(map[string]ethabi.Type)

	var collectTypes func(t ethabi.Type)
	collectTypes = func(t ethabi.Type) {
		typeID := abi.GenTypeIdentifier(t)
		if _, exists := typeSet[typeID]; !exists {
			typeSet[typeID] = t
		}

		// Recursively collect nested types
		switch t.T {
		case ethabi.SliceTy, ethabi.ArrayTy:
			if t.Elem != nil {
				collectTypes(*t.Elem)
			}
		case ethabi.TupleTy:
			for _, elem := range t.TupleElems {
				collectTypes(*elem)
			}
		}
	}

	// Collect types from all methods
	for _, method := range methods {
		// Collect from inputs
		for _, input := range method.Inputs {
			collectTypes(input.Type)
		}
		// Collect from outputs
		for _, output := range method.Outputs {
			collectTypes(output.Type)
		}
	}

	// Convert map to slice
	result := make([]ethabi.Type, 0, len(typeSet))
	for _, name := range SortedMapKeys(typeSet) {
		t := typeSet[name]
		if t.T == ethabi.TupleTy {
			// Skip tuple types since they have their own struct methods
			continue
		}
		result = append(result, t)
	}
	return result
}

func (g *Generator) genFuncName(t ethabi.Type, fn string) string {
	typeID := abi.GenTypeIdentifier(t)
	if !g.Options.Stdlib && abi.IsStdlibType(typeID) {
		// Use standard library prefix for stdlib types
		return fmt.Sprintf("%s%s%s", g.StdPrefix, fn, typeID)
	}
	return fmt.Sprintf("%s%s%s", ToCamel(g.Options.Prefix), fn, typeID)
}

// genEncodingFunction generates a standalone encoding function for a specific ABI type
func (g *Generator) genEncodingFunction(t ethabi.Type) {
	funcName := g.genFuncName(t, "Encode")
	if strings.Contains(funcName, ".") {
		// Skip generating decoding function for stdlib types
		return
	}

	goType := g.abiTypeToGoType(t)

	g.L("")
	g.L("// %s encodes %s to ABI bytes", funcName, t.String())
	g.L("func %s(value %s, buf []byte) (int, error) {", funcName, goType)

	// Generate encoding logic based on type
	switch t.T {
	case ethabi.UintTy, ethabi.IntTy:
		g.genIntEncoding(t)
	case ethabi.AddressTy:
		g.genAddressEncoding()
	case ethabi.BoolTy:
		g.genBoolEncoding()
	case ethabi.StringTy:
		g.genStringEncoding()
	case ethabi.BytesTy:
		g.genBytesEncoding()
	case ethabi.FixedBytesTy:
		g.genFixedBytesEncoding(t)
	case ethabi.SliceTy:
		g.genSliceEncoding(t)
	case ethabi.ArrayTy:
		g.genArrayEncoding(t)
	case ethabi.TupleTy:
		panic("tuple types should use struct methods for encoding")
	default:
		panic("unsupported ABI type for encoding function generation: " + t.String())
	}

	g.L("}")
}

// genSizeFunction generates a standalone size calculation function for a specific ABI type
func (g *Generator) genSizeFunction(t ethabi.Type) {
	funcName := g.genFuncName(t, "Size")
	if strings.Contains(funcName, ".") {
		// Skip generating decoding function for stdlib types
		return
	}

	g.L("")
	g.L("// %s returns the encoded size of %s", funcName, t.String())
	g.L("func %s(value %s) int {", funcName, g.abiTypeToGoType(t))

	// Generate size calculation logic based on type
	if !IsDynamicType(t) {
		// Static types have fixed size
		g.L("\treturn %d", GetTypeSize(t))
	} else {
		// Dynamic types need size calculation
		switch t.T {
		case ethabi.StringTy:
			g.L("\tsize := 32 + %sPad32(len(value)) // length + padded string data", g.StdPrefix)
		case ethabi.BytesTy:
			g.L("\tsize := 32 + %sPad32(len(value)) // length + padded bytes data", g.StdPrefix)
		case ethabi.SliceTy:
			if IsDynamicType(*t.Elem) {
				// Dynamic array with dynamic elements
				g.L("\tsize := 32 + 32 * len(value) // length + offset pointers for dynamic elements")
				g.L("\tfor _, elem := range value {")
				g.L("\t	size += %s", g.genSizeCall(*t.Elem, "elem"))
				g.L("\t}")
			} else {
				// Dynamic array with static elements
				g.L("\tsize := 32 + %d * len(value) // length + static elements", GetTypeSize(*t.Elem))
			}
		case ethabi.ArrayTy:
			// Fixed size array of dynamic element types
			g.L("\tsize := 32 * %d // offsets", t.Size)
			for i := 0; i < t.Size; i++ {
				g.L("\tsize += %s", g.genSizeCall(*t.Elem, fmt.Sprintf("value[%d]", i)))
			}
		case ethabi.TupleTy:
			// Dynamic tuple, just call tuple struct method
			g.L("\tsize := value.EncodedSize() // dynamic tuple")
		default:
			panic("impossible")
		}
		g.L("\treturn size")
	}

	g.L("}")
}

// genDecodingFunction generates a standalone decoding function for a specific ABI type
func (g *Generator) genDecodingFunction(t ethabi.Type) {
	funcName := g.genFuncName(t, "Decode")
	if strings.Contains(funcName, ".") {
		// Skip generating decoding function for stdlib types
		return
	}

	goType := g.abiTypeToGoType(t)

	g.L("")
	g.L("// %s decodes %s from ABI bytes", funcName, t.String())
	g.L("func %s(data []byte) (%s, int, error) {", funcName, goType)

	// Generate decoding logic based on type
	switch t.T {
	case ethabi.UintTy, ethabi.IntTy:
		g.genIntDecoding(t)
	case ethabi.AddressTy:
		g.genAddressDecoding()
	case ethabi.BoolTy:
		g.genBoolDecoding()
	case ethabi.StringTy:
		g.genStringDecoding()
	case ethabi.BytesTy:
		g.genBytesDecoding()
	case ethabi.FixedBytesTy:
		g.genFixedBytesDecoding(t)
	case ethabi.SliceTy:
		g.genSliceDecoding(t)
	case ethabi.ArrayTy:
		g.genArrayDecoding(t)
	case ethabi.TupleTy:
		panic("tuple types should use struct methods for decoding")
	default:
		panic("unsupported ABI type for decoding function generation: " + t.String())
	}

	g.L("}")
}

// genTuples generates all tuple structs needed for a function
func (g *Generator) genTuples(methods []ethabi.Method) {
	// Collect all tuple types from function inputs and outputs
	tupleTypes := make(map[string]ethabi.Type)

	var collectTupleVisitor func(t ethabi.Type)
	collectTupleVisitor = func(t ethabi.Type) {
		if t.T != ethabi.TupleTy {
			return
		}
		tupleTypes[abi.TupleStructName(t)] = t
	}

	// Collect tuples from all methods
	for _, method := range methods {
		// Collect tuples from all inputs
		for _, input := range method.Inputs {
			VisitABIType(input.Type, collectTupleVisitor)
		}
		// Collect tuples from all outputs
		for _, output := range method.Outputs {
			VisitABIType(output.Type, collectTupleVisitor)
		}
	}

	// Generate struct definitions for collected tuples
	for _, name := range SortedMapKeys(tupleTypes) {
		// Check if this tuple should use an external implementation
		if _, exists := g.Options.ExternalTuples[name]; exists {
			// Skip generating this tuple since it uses an external implementation
			continue
		}

		tupleType := tupleTypes[name]
		s := StructFromTuple(tupleType)
		g.genStruct(s)
	}
}

// genStruct generates a struct definition
func (g *Generator) genStruct(s Struct) {
	g.L("")
	g.L("const %sStaticSize = %d", s.Name, GetTupleSize(s.Types()))
	g.L("")
	g.L("// %s represents an ABI tuple", s.Name)
	g.L("type %s struct {", s.Name)

	for _, f := range s.Fields {
		goType := g.abiTypeToGoType(*f.Type)
		g.L("%s %s", f.Name, goType)
	}
	g.L("}")

	// Generate encode method for the tuple struct
	g.genStructMethods(s)
}

// genStructMethods generates Encode/Decode methods for tuple structs
func (g *Generator) genStructMethods(s Struct) {
	// Generate EncodedSize method
	g.genEncodedSize(s)

	// Generate EncodeTo method that calls standalone function
	g.genStructEncodeTo(s)

	// Generate Encode method
	g.L("")
	g.L("// Encode encodes %s to ABI bytes", s.Name)
	g.L("func (value %s) Encode() ([]byte, error) {", s.Name)
	g.L("\tbuf := make([]byte, value.EncodedSize())")
	g.L("\tif _, err := value.EncodeTo(buf); err != nil {")
	g.L("\t\treturn nil, err")
	g.L("\t}")
	g.L("\treturn buf, nil")
	g.L("}")

	// Generate Decode method
	g.genStructDecode(s)
}

// genStructEncodeTo generates the EncodeTo method that calls standalone function
func (g *Generator) genStructEncodeTo(s Struct) error {
	g.L("")
	g.L("// EncodeTo encodes %s to ABI bytes in the provided buffer", s.Name)
	g.L("func (value %s) EncodeTo(buf []byte) (int, error) {", s.Name)

	g.genTupleEncoding(s.T)

	g.L("}")
	return nil
}

// genEncodedSize generates the size calculation logic without selector
func (g *Generator) genEncodedSize(s Struct) {
	g.L("")
	g.L("// EncodedSize returns the total encoded size of %s", s.Name)
	g.L("func (t %s) EncodedSize() int {", s.Name)
	g.L("\tdynamicSize := 0")

	for _, f := range s.Fields {
		if !IsDynamicType(*f.Type) {
			continue
		}

		g.L("\tdynamicSize += %s", g.genSizeCall(*f.Type, fmt.Sprintf("t.%s", f.Name)))
	}

	g.L("")
	g.L("\treturn %sStaticSize + dynamicSize", s.Name)
	g.L("}")
}

// genSize generates size calculation logic for a type
func (g *Generator) genSize(t ethabi.Type, acc string, ref string) {
	if !IsDynamicType(t) {
		g.L("%s += %d // static element %s", acc, GetTypeSize(t), ref)
		return
	}

	switch t.T {
	case ethabi.StringTy:
		g.L("%s += 32 + %sPad32(len(%s)) // length + padded string data", acc, g.StdPrefix, ref)

	case ethabi.BytesTy:
		g.L("%s += 32 + %sPad32(len(%s)) // length + padded bytes data", acc, g.StdPrefix, ref)

	case ethabi.SliceTy:
		if IsDynamicType(*t.Elem) {
			// Dynamic array with dynamic elements
			g.L("%s += 32 + 32 * len(%s) // length + offset pointers for dynamic elements", acc, ref)
			g.L("for _, elem := range %s {", ref)
			g.genSizeIndented(*t.Elem, acc, "elem")
			g.L("}")
		} else {
			// Dynamic array with static elements
			g.L("%s += 32 + %d * len(%s) // length + static elements", acc, GetTypeSize(*t.Elem), ref)
		}

	case ethabi.ArrayTy:
		// Fixed size array of dynamic element types
		g.L("for _, elem := range %s {", ref)
		g.genSizeIndented(*t.Elem, acc, "elem")
		g.L("}")

	case ethabi.TupleTy:
		// Dynamic tuple, just call tuple struct method
		g.L("%s += %s.EncodedSize() // dynamic tuple", acc, ref)

	default:
		panic("impossible")
	}
}

// genSizeIndented generates size calculation logic with proper indentation
func (g *Generator) genSizeIndented(t ethabi.Type, acc string, ref string) {
	if !IsDynamicType(t) {
		g.L("\t%s += %d // static element %s", acc, GetTypeSize(t), ref)
		return
	}

	switch t.T {
	case ethabi.StringTy:
		g.L("\t%s += 32 + %sPad32(len(%s)) // length + padded string data", acc, g.StdPrefix, ref)

	case ethabi.BytesTy:
		g.L("\t%s += 32 + %sPad32(len(%s)) // length + padded bytes data", acc, g.StdPrefix, ref)

	case ethabi.SliceTy:
		if IsDynamicType(*t.Elem) {
			// Dynamic array with dynamic elements
			g.L("\t%s += 32 + 32 * len(%s) // length + offset pointers for dynamic elements", acc, ref)
			g.L("\tfor _, elem := range %s {", ref)
			g.genSizeIndented(*t.Elem, acc, "elem")
			g.L("\t}")
		} else {
			// Dynamic array with static elements
			g.L("\t%s += 32 + %d * len(%s) // length + static elements", acc, GetTypeSize(*t.Elem), ref)
		}

	case ethabi.ArrayTy:
		// Fixed size array of dynamic element types
		g.L("\tfor _, elem := range %s {", ref)
		g.genSizeIndented(*t.Elem, acc, "elem")
		g.L("\t}")

	case ethabi.TupleTy:
		// Dynamic tuple, just call tuple struct method
		g.L("\t%s += %s.EncodedSize() // dynamic tuple", acc, ref)

	default:
		panic("impossible")
	}
}

// genStructDecode generates the Decode method (placeholder for now)
func (g *Generator) genStructDecode(s Struct) {
	staticSize := GetTupleSize(s.Types())
	g.L("")
	g.L("// Decode decodes %s from ABI bytes in the provided buffer", s.Name)
	g.L("func (t *%s) Decode(data []byte) (int, error) {", s.Name)
	g.L("\tif len(data) < %d {", staticSize)
	g.L("\t\treturn 0, io.ErrUnexpectedEOF")
	g.L("\t}")

	g.L("\tvar (")
	g.L("\t\terr error")
	if IsDynamicType(s.T) {
		g.L("\t\tn int")
	}
	g.L("\t)")
	g.L("\t\tdynamicOffset := %d", staticSize)

	var offset int
	for _, f := range s.Fields {
		dataRef := fmt.Sprintf("data[%d:]", offset)
		if !IsDynamicType(*f.Type) {
			g.L("\t// Decode static field %s: %s", f.Name, f.Type.String())

			if f.Type.T == ethabi.TupleTy {
				g.L("\t_, err = t.%s.Decode(%s)", f.Name, dataRef)
			} else {
				g.L("\tt.%s, _, err = %s", f.Name, g.genDecodeCall(*f.Type, dataRef))
			}
			g.L("\tif err != nil {")
			g.L("\t\treturn 0, err")
			g.L("\t}")

			offset += GetTypeSize(*f.Type)
		} else {
			g.L("\t// Decode dynamic field %s", f.Name)
			g.L("\t{")

			g.L("\t\toffset := int(binary.BigEndian.Uint64(data[%d+24:%d+32]))", offset, offset)
			g.L("\t\tif offset != dynamicOffset {")
			g.L("\t\t\treturn 0, errors.New(\"invalid offset for dynamic field %s\")", f.Name)
			g.L("\t\t}")

			if f.Type.T == ethabi.TupleTy {
				g.L("\t\tn, err = t.%s.Decode(data[dynamicOffset:])", f.Name)
			} else {
				g.L("\t\tt.%s, n, err = %s", f.Name, g.genDecodeCall(*f.Type, "data[dynamicOffset:]"))
			}
			g.L("\t\tif err != nil {")
			g.L("\t\t\treturn 0, err")
			g.L("\t\t}")
			g.L("\t\tdynamicOffset += n")

			g.L("\t}")

			offset += 32
		}
	}

	g.L("\treturn dynamicOffset, nil")
	g.L("}")
}

func (g *Generator) genFunction(method ethabi.Method) {
	// Generate struct and methods for functions with inputs
	name := fmt.Sprintf("%sCall", Title.String(method.Name))
	if len(method.Inputs) > 0 {
		s := StructFromArguments(name, method.Inputs)
		g.genStruct(s)
	} else {
		g.L("")
		g.L("// %s represents the input arguments for %s function", name, method.Name)
		g.L("type %s struct {", name)
		g.L("\t%sEmptyTuple", g.StdPrefix)
		g.L("}")
	}

	g.L("")
	g.L("// EncodeWithSelector encodes %s arguments to ABI bytes including function selector", method.Name)
	g.L("func (t %s) EncodeWithSelector() ([]byte, error) {", name)
	g.L("\tresult := make([]byte, 4 + t.EncodedSize())")
	g.L("\tcopy(result[:4], %sSelector[:])", Title.String(method.Name))
	g.L("\tif _, err := t.EncodeTo(result[4:]); err != nil {")
	g.L("\t\treturn nil, err")
	g.L("\t}")
	g.L("\treturn result, nil")
	g.L("}")

	name = fmt.Sprintf("%sReturn", Title.String(method.Name))
	if len(method.Outputs) > 0 {
		s := StructFromArguments(name, method.Outputs)
		g.genStruct(s)
	} else {
		g.L("")
		g.L("// %s represents the input arguments for %s function", name, method.Name)
		g.L("type %s struct {", name)
		g.L("\t%sEmptyTuple", g.StdPrefix)
		g.L("}")
	}
}

func (g *Generator) genAllSelectors(methods []ethabi.Method) {
	if len(methods) == 0 {
		return
	}

	g.L("")
	g.L("// Function selectors")
	g.L("var (")
	for _, method := range methods {
		name := Title.String(method.Name)
		g.L("\t// %s", method.Sig)
		g.L("\t%sSelector = [4]byte{0x%02x, 0x%02x, 0x%02x, 0x%02x}",
			name,
			method.ID[0],
			method.ID[1],
			method.ID[2],
			method.ID[3])
	}
	g.L(")")

	g.L("")
	g.L("// Big endian integer versions of function selectors")
	g.L("const (")
	for _, method := range methods {
		// Generate integer version of selector
		name := Title.String(method.Name)
		selectorInt := binary.BigEndian.Uint32(method.ID)
		g.L("\t%sID = %d", name, selectorInt)
	}
	g.L(")")
}

// abiTypeToGoType converts ABI type to Go type (reuse existing implementation)
func (g *Generator) abiTypeToGoType(abiType ethabi.Type) string {
	// Reuse the existing implementation from generator.go
	// This is a temporary placeholder - we should refactor this to avoid duplication
	switch abiType.T {
	case ethabi.UintTy:
		// Use the closest native Go type that fits to avoid big.Int allocations
		if abiType.Size <= 8 {
			return "uint8"
		} else if abiType.Size <= 16 {
			return "uint16"
		} else if abiType.Size <= 32 {
			return "uint32"
		} else if abiType.Size <= 64 {
			return "uint64"
		} else {
			return "*big.Int"
		}
	case ethabi.IntTy:
		// Use the closest native Go type that fits to avoid big.Int allocations
		if abiType.Size <= 8 {
			return "int8"
		} else if abiType.Size <= 16 {
			return "int16"
		} else if abiType.Size <= 32 {
			return "int32"
		} else if abiType.Size <= 64 {
			return "int64"
		} else {
			return "*big.Int"
		}
	case ethabi.AddressTy:
		return "common.Address"
	case ethabi.BoolTy:
		return "bool"
	case ethabi.StringTy:
		return "string"
	case ethabi.BytesTy:
		return "[]byte"
	case ethabi.FixedBytesTy:
		return fmt.Sprintf("[%d]byte", abiType.Size)
	case ethabi.SliceTy:
		// Dynamic arrays like uint256[]
		elemType := g.abiTypeToGoType(*abiType.Elem)
		return fmt.Sprintf("[]%s", elemType)
	case ethabi.ArrayTy:
		// Fixed-size arrays like uint256[10]
		elemType := g.abiTypeToGoType(*abiType.Elem)
		return fmt.Sprintf("[%d]%s", abiType.Size, elemType)
	case ethabi.TupleTy:
		// Handle tuple types - generate struct type name
		structName := abi.TupleStructName(abiType)
		// Check if this tuple has an external implementation
		if externalName, exists := g.Options.ExternalTuples[structName]; exists {
			return externalName
		}
		return structName
	default:
		panic(fmt.Sprintf("unsupported ABI type: %s", abiType.String()))
	}
}

func (g *Generator) genEncodeCall(t ethabi.Type, value string, dataRef string) string {
	// Generate the function name for encoding a call with this type
	if t.T == ethabi.TupleTy {
		// For tuple types, use the struct's EncodeTo method
		return fmt.Sprintf("%s.EncodeTo(%s)", value, dataRef)
	}

	return fmt.Sprintf("%s(%s, %s)", g.genFuncName(t, "Encode"), value, dataRef)
}

func (g *Generator) genSizeCall(t ethabi.Type, valueRef string) string {
	if !IsDynamicType(t) {
		panic("size call should only be generated for dynamic types")
	}

	if t.T == ethabi.TupleTy {
		// For tuple types, use the struct's EncodedSize method
		return fmt.Sprintf("%s.EncodedSize()", valueRef)
	}

	return fmt.Sprintf("%s(%s)", g.genFuncName(t, "Size"), valueRef)
}

func (g *Generator) genDecodeCall(t ethabi.Type, dataRef string) string {
	if t.T == ethabi.TupleTy {
		panic("tuple types should use struct methods for decoding")
	}

	return fmt.Sprintf("%s(%s)", g.genFuncName(t, "Decode"), dataRef)
}

// genAllEventTopics generates all event constants at the beginning of the file
func (g *Generator) genAllEventTopics(events []ethabi.Event) {
	if len(events) == 0 {
		return
	}

	g.L("")
	g.L("// Event signatures")
	g.L("var (")
	for _, event := range events {
		g.L("\t// %s", event.Sig)

		var parts []string
		for _, b := range event.ID {
			parts = append(parts, fmt.Sprintf("0x%02x", b))
		}
		g.L("\t%sEventTopic = common.Hash{%s}", event.Name, strings.Join(parts, ", "))
	}
	g.L(")")
}

func (g *Generator) genEvent(event ethabi.Event) {
	// Fill empty field names
	for i := range event.Inputs {
		if event.Inputs[i].Name == "" {
			event.Inputs[i].Name = fmt.Sprintf("field%d", i)
		}
	}

	// gen top level struct NameEvent
	g.genEventTopLevel(event)

	// gen struct NameEventIndexed
	g.genEventIndexed(event)

	// gen struct NameEventData
	dataStruct := StructFromEventData(event)
	if len(dataStruct.Fields) > 0 {
		g.genStruct(dataStruct)
	} else {
		g.L(`type %sEventData %sEmptyTuple`, event.Name, g.StdPrefix)
	}

	return
}

func (g *Generator) genEventTopLevel(event ethabi.Event) {
	g.L("// %sEvent represents the %s event", event.Name, event.Name)
	g.L("type %sEvent struct {", event.Name)
	g.L("%sEventIndexed", event.Name)
	g.L("%sEventData", event.Name)
	g.L("}")

	// gen constructor
	g.L("// New%sEvent constructs a new %s event", event.Name, event.Name)
	g.L("func New%sEvent(", event.Name)

	for _, input := range event.Inputs {
		goType := g.abiTypeToGoType(input.Type)
		g.L("\t%s %s,", input.Name, goType)
	}

	g.L(") %sEvent {", event.Name)
	g.L("return %sEvent{", event.Name)
	g.L("\t%sEventIndexed: %sEventIndexed{", event.Name, event.Name)

	for _, input := range event.Inputs {
		if !input.Indexed {
			continue
		}
		g.L("%s: %s,", Title.String(input.Name), input.Name)
	}

	g.L("\t},")
	g.L("\t%sEventData: %sEventData{", event.Name, event.Name)

	for _, input := range event.Inputs {
		if input.Indexed {
			continue
		}
		g.L("%s: %s,", Title.String(input.Name), input.Name)
	}

	g.L("\t},")
	g.L("}")
	g.L("}")
}

func (g *Generator) genEventIndexed(event ethabi.Event) {
	name := event.Name

	var fields []ethabi.Argument
	for _, input := range event.Inputs {
		if !input.Indexed {
			continue
		}
		fields = append(fields, input)
	}

	if len(fields) == 0 {
		g.L(`type %sEventIndexed %sEmptyIndexed`, event.Name, g.StdPrefix)
		return
	}

	g.L("// %s represents an ABI event", name)
	g.L("type %sEventIndexed struct {", name)

	for _, input := range fields {
		goType := g.abiTypeToGoType(input.Type)
		fieldName := Title.String(input.Name)
		g.L("%s %s", fieldName, goType)
	}
	g.L("}")

	// Generate methods for indexed fields
	g.L("// EncodeTopics encodes indexed fields of %s event to topics", name)
	g.L("func (e %sEventIndexed) EncodeTopics() ([]common.Hash, error) {", name)
	g.L("\ttopics := make([]common.Hash, 0, %d)", len(fields)+1)
	g.L("\ttopics = append(topics, %sEventTopic)", name)

	for _, input := range fields {
		fieldName := Title.String(input.Name)

		g.L("\t{")
		g.L("\t\t// %s", fieldName)
		ref := fmt.Sprintf("e.%s", fieldName)

		g.genEncodeToHash(input.Type, ref)

		g.L("\t\ttopics = append(topics, hash)")
		g.L("\t}")
	}

	g.L("\treturn topics, nil")
	g.L("}")

	g.L("// DecodeTopics decodes indexed fields of %s event from topics, ignore hash topics", name)
	g.L("func (e *%sEventIndexed) DecodeTopics(topics []common.Hash) error {", name)

	g.L("\tif len(topics) != %d {", len(fields)+1)
	g.L("\t\treturn fmt.Errorf(\"invalid number of topics for %s event: expected %d, got %%d\", len(topics))", name, len(fields)+1)
	g.L("\t}")

	g.L("\tif topics[0] != %sEventTopic {", name)
	g.L("\t\treturn fmt.Errorf(\"invalid event topic for %s event\")", name)
	g.L("\t}")

	decodeFields := make(map[int]struct{})
	for i, input := range fields {
		if IsDynamicType(input.Type) || GetTypeSize(input.Type) != 32 {
			// ignore hash fields silently
			continue
		}
		decodeFields[i] = struct{}{}
	}

	if len(decodeFields) > 0 {
		g.L("\tvar err error")
	}
	for i, input := range fields {
		if _, ok := decodeFields[i]; !ok {
			continue
		}

		fieldName := Title.String(input.Name)
		dataRef := fmt.Sprintf("topics[%d][:]", i+1)
		g.L("\te.%s, _, err = %s", fieldName, g.genDecodeCall(input.Type, dataRef))
		g.L("\tif err != nil {")
		g.L("\t\treturn err")
		g.L("\t}")
	}

	g.L("\treturn nil")
	g.L("}")
}

func (g *Generator) genEncodeToHash(t ethabi.Type, ref string) {
	isDynamic := IsDynamicType(t)
	typeSize := GetTypeSize(t)
	if !isDynamic && typeSize == 32 {
		// fast path
		g.L("var hash common.Hash")
		g.L("if _, err := %s; err != nil {", g.genEncodeCall(t, ref, "hash[:]"))
		g.L("\treturn nil, err")
		g.L("}")
	} else if isDynamic {
		// dynamic type - hash the encoded bytes
		g.L("encodedSize := %s", g.genSizeCall(t, ref))
		g.L("buf := make([]byte, encodedSize)")
		g.L("if _, err := %s; err != nil {", g.genEncodeCall(t, ref, "buf"))
		g.L("\treturn nil, err")
		g.L("}")
		g.L("hash := crypto.Keccak256Hash(buf)")
	} else {
		// static type but not 32 bytes
		g.L("buf := make([]byte, %d)", typeSize)
		g.L("if _, err := %s; err != nil {", g.genEncodeCall(t, ref, "buf"))
		g.L("\treturn nil, err")
		g.L("}")
		g.L("hash := crypto.Keccak256Hash(buf)")
	}
}
