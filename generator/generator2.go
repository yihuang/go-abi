package generator

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"text/template"

	"github.com/ethereum/go-ethereum/accounts/abi"
)

// Generator2 handles ABI code generation with standalone functions
// This is a new approach that generates standalone encoding/decoding functions
// for each ABI type, allowing recursive composition and code reuse.
type Generator2 struct {
	buf bytes.Buffer

	Options   Options
	Imports   []ImportSpec
	Selectors []SelectorInfo
	Events    []EventInfo

	// Track generated functions to avoid duplicates
	generatedFunctions map[string]bool
}

// NewGenerator2 creates a new ABI code generator with standalone functions
func NewGenerator2(opts ...Option) *Generator2 {
	opt := NewOptions(opts...)

	return &Generator2{
		Options:            *opt,
		Imports:            append(DefaultImports, opt.ExtraImports...),
		Selectors:          []SelectorInfo{},
		Events:             []EventInfo{},
		generatedFunctions: make(map[string]bool),
	}
}

func (g *Generator2) L(format string, args ...any) {
	fmt.Fprintf(&g.buf, format, args...)
	fmt.Fprint(&g.buf, "\n")
}

func (g *Generator2) T(tpl string, m map[string]interface{}) {
	t := template.Must(template.New("").Parse(tpl))
	t.Execute(&g.buf, m)
}

// GenerateFromABI generates Go code from ABI JSON using standalone functions
func (g *Generator2) GenerateFromABI(abiDef abi.ABI) (string, error) {
	// Write do not edit warning
	g.L("// Code generated by go-abi generator2. DO NOT EDIT.")
	g.L("")

	// Write package declaration
	g.L("package %s", g.Options.PackageName)
	g.L("")

	// Write imports
	if len(g.Imports) > 0 {
		g.L("import (")
		for _, imp := range g.Imports {
			if imp.Alias != "" {
				g.L("\t%s \"%s\"", imp.Alias, imp.Path)
			} else {
				g.L("\t\"%s\"", imp.Path)
			}
		}
		g.L(")")
		g.L("")
	}

	// First, collect all tuple types needed for this ABI
	var methods []abi.Method
	for _, name := range SortedMapKeys(abiDef.Methods) {
		methods = append(methods, abiDef.Methods[name])
	}

	// Collect all selectors
	for _, method := range methods {
		g.Selectors = append(g.Selectors, SelectorInfo{
			Name:  Title.String(method.Name),
			Sig:   method.Sig,
			Bytes: [4]byte{method.ID[0], method.ID[1], method.ID[2], method.ID[3]},
		})
	}

	// Generate all selector constants at the beginning
	g.genAllSelectors()

	// Generate all tuple structs needed for this function FIRST
	// This ensures tuple types are available for encoding function generation
	if err := g.genTuples(methods); err != nil {
		return "", err
	}

	// Collect all types needed for encoding functions (excluding tuple types)
	allTypes := g.collectAllTypes(methods)

	// Generate all encoding functions in topological order
	// First collect all functions that need to be generated
	for _, t := range allTypes {
		if err := g.collectEncodingFunction(t); err != nil {
			return "", fmt.Errorf("failed to collect encoding function for type %s: %w", t.String(), err)
		}
	}

	// Also collect size functions for all types
	for _, t := range allTypes {
		if err := g.collectSizeFunction(t); err != nil {
			return "", fmt.Errorf("failed to collect size function for type %s: %w", t.String(), err)
		}
	}

	// Now generate functions in the order they were collected
	for _, t := range allTypes {
		if err := g.genEncodingFunction(t); err != nil {
			return "", fmt.Errorf("failed to generate encoding function for type %s: %w", t.String(), err)
		}
	}

	// Generate size functions after encoding functions
	for _, t := range allTypes {
		if err := g.genSizeFunction(t); err != nil {
			return "", fmt.Errorf("failed to generate size function for type %s: %w", t.String(), err)
		}
	}

	// Generate code for each function
	for _, method := range methods {
		if err := g.genFunction(method); err != nil {
			return "", fmt.Errorf("failed to generate function %s: %w", method.Name, err)
		}
	}

	// Generate code for each event
	for _, event := range g.Events {
		if err := g.genEvent(event); err != nil {
			return "", fmt.Errorf("failed to generate event %s: %w", event.Name, err)
		}
	}

	// Format the generated code
	return string(g.buf.Bytes()), nil
}

// GenTypeIdentifier generates a unique identifier for any ABI type
// This is used to create unique function names for encoding/decoding
func GenTypeIdentifier(t abi.Type) string {
	switch t.T {
	case abi.UintTy:
		if t.Size <= 64 {
			return fmt.Sprintf("uint%d", t.Size)
		}
		return "uint256"
	case abi.IntTy:
		if t.Size <= 64 {
			return fmt.Sprintf("int%d", t.Size)
		}
		return "int256"
	case abi.AddressTy:
		return "address"
	case abi.BoolTy:
		return "bool"
	case abi.StringTy:
		return "string"
	case abi.BytesTy:
		return "bytes"
	case abi.FixedBytesTy:
		return fmt.Sprintf("bytes%d", t.Size)
	case abi.SliceTy:
		if t.Elem != nil {
			return fmt.Sprintf("%s_array", GenTypeIdentifier(*t.Elem))
		}
		return "unknown_array"
	case abi.ArrayTy:
		if t.Elem != nil {
			return fmt.Sprintf("%s_array_%d", GenTypeIdentifier(*t.Elem), t.Size)
		}
		return fmt.Sprintf("unknown_array_%d", t.Size)
	case abi.TupleTy:
		return TupleStructName(t) // Reuse existing tuple identifier logic
	default:
		return t.String()
	}
}

// collectAllTypes collects all unique ABI types needed for encoding functions
func (g *Generator2) collectAllTypes(methods []abi.Method) []abi.Type {
	typeSet := make(map[string]abi.Type)

	var collectTypes func(t abi.Type)
	collectTypes = func(t abi.Type) {
		typeID := GenTypeIdentifier(t)
		if _, exists := typeSet[typeID]; !exists {
			typeSet[typeID] = t
		}

		// Recursively collect nested types
		switch t.T {
		case abi.SliceTy, abi.ArrayTy:
			if t.Elem != nil {
				collectTypes(*t.Elem)
			}
		case abi.TupleTy:
			for _, elem := range t.TupleElems {
				collectTypes(*elem)
			}
		}
	}

	// Collect types from all methods
	for _, method := range methods {
		// Collect from inputs
		for _, input := range method.Inputs {
			collectTypes(input.Type)
		}
		// Collect from outputs
		for _, output := range method.Outputs {
			collectTypes(output.Type)
		}
	}

	// Convert map to slice
	result := make([]abi.Type, 0, len(typeSet))
	for _, name := range SortedMapKeys(typeSet) {
		t := typeSet[name]
		if t.T == abi.TupleTy {
			// Skip tuple types since they have their own struct methods
			continue
		}
		result = append(result, t)
	}
	return result
}

// collectEncodingFunction collects all encoding functions needed for a type
func (g *Generator2) collectEncodingFunction(t abi.Type) error {
	typeID := GenTypeIdentifier(t)
	funcName := fmt.Sprintf("encode_%s", typeID)

	// Skip if already collected
	if _, ok := g.generatedFunctions[funcName]; ok {
		return nil
	}
	g.generatedFunctions[funcName] = false

	// Recursively collect dependencies
	switch t.T {
	case abi.SliceTy, abi.ArrayTy:
		if t.Elem != nil {
			return g.collectEncodingFunction(*t.Elem)
		}
	case abi.TupleTy:
		for _, elem := range t.TupleElems {
			if elem != nil {
				if err := g.collectEncodingFunction(*elem); err != nil {
					return err
				}
			}
		}
	}

	return nil
}

// collectSizeFunction collects all size functions needed for a type
func (g *Generator2) collectSizeFunction(t abi.Type) error {
	typeID := GenTypeIdentifier(t)
	funcName := fmt.Sprintf("size_%s", typeID)

	// Skip if already collected
	if _, ok := g.generatedFunctions[funcName]; ok {
		return nil
	}
	g.generatedFunctions[funcName] = false

	// Recursively collect dependencies
	switch t.T {
	case abi.SliceTy, abi.ArrayTy:
		if t.Elem != nil {
			return g.collectSizeFunction(*t.Elem)
		}
	case abi.TupleTy:
		for _, elem := range t.TupleElems {
			if elem != nil {
				if err := g.collectSizeFunction(*elem); err != nil {
					return err
				}
			}
		}
	}

	return nil
}

// genSizeFunction generates a standalone size calculation function for a specific ABI type
func (g *Generator2) genSizeFunction(t abi.Type) error {
	typeID := GenTypeIdentifier(t)
	funcName := fmt.Sprintf("size_%s", typeID)

	// Skip if already generated
	if g.generatedFunctions[funcName] {
		return nil
	}
	g.generatedFunctions[funcName] = true

	g.L("")
	g.L("// %s returns the encoded size of %s", funcName, t.String())
	g.L("func %s(value %s) int {", funcName, g.abiTypeToGoType(t))

	// Generate size calculation logic based on type
	g.L("	size := 0")

	if !IsDynamicType(t) {
		// Static types have fixed size
		g.L("	return %d", GetTypeSize(t))
	} else {
		// Dynamic types need size calculation
		switch t.T {
		case abi.StringTy:
			g.L("	size += 32 + abi.Pad32(len(value)) // length + padded string data")
		case abi.BytesTy:
			g.L("	size += 32 + abi.Pad32(len(value)) // length + padded bytes data")
		case abi.SliceTy:
			if IsDynamicType(*t.Elem) {
				// Dynamic array with dynamic elements
				g.L("	size += 32 + 32 * len(value) // length + offset pointers for dynamic elements")
				g.L("	for _, elem := range value {")
				g.L("		size += %s(elem)", genSizeCall(*t.Elem))
				g.L("	}")
			} else {
				// Dynamic array with static elements
				g.L("	size += 32 + %d * len(value) // length + static elements", GetTypeSize(*t.Elem))
			}
		case abi.ArrayTy:
			// Fixed size array of dynamic element types
			g.L("	for _, elem := range value {")
			g.L("		size += %s(elem)", genSizeCall(*t.Elem))
			g.L("	}")
		case abi.TupleTy:
			// Dynamic tuple, just call tuple struct method
			g.L("	size += value.EncodedSize() // dynamic tuple")
		default:
			panic("impossible")
		}
		g.L("	return size")
	}

	g.L("}")
	return nil
}

// genEncodingFunction generates a standalone encoding function for a specific ABI type
func (g *Generator2) genEncodingFunction(t abi.Type) error {
	typeID := GenTypeIdentifier(t)
	funcName := fmt.Sprintf("encode_%s", typeID)

	// Skip if already generated
	if g.generatedFunctions[funcName] {
		return nil
	}
	g.generatedFunctions[funcName] = true

	g.L("")
	g.L("// %s encodes %s to ABI bytes", funcName, t.String())
	g.L("func %s(value %s, buf []byte) (int, error) {", funcName, g.abiTypeToGoType(t))

	// Generate encoding logic based on type
	switch t.T {
	case abi.UintTy, abi.IntTy:
		g.genIntEncoding(t)
	case abi.AddressTy:
		g.genAddressEncoding()
	case abi.BoolTy:
		g.genBoolEncoding()
	case abi.StringTy:
		g.genStringEncoding()
	case abi.BytesTy:
		g.genBytesEncoding()
	case abi.FixedBytesTy:
		g.genFixedBytesEncoding(t)
	case abi.SliceTy:
		if err := g.genSliceEncoding(t); err != nil {
			return err
		}
	case abi.ArrayTy:
		if err := g.genArrayEncoding(t); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported ABI type for encoding: %s", t.String())
	}

	g.L("}")
	return nil
}

// genIntEncoding generates encoding for integer types
func (g *Generator2) genIntEncoding(t abi.Type) {
	// Optimize small integer types to avoid big.Int overhead
	if t.Size <= 64 {
		g.genSmallIntEncoding(t)
	} else {
		g.genBigIntEncoding(t)
	}
}

// genSmallIntEncoding generates optimized encoding for small integer types
func (g *Generator2) genSmallIntEncoding(t abi.Type) {
	// For small integers, we can use direct binary encoding without big.Int
	switch t.Size {
	case 8:
		if t.T == abi.IntTy {
			// int8 - sign extend
			g.L("\tif value < 0 {")
			g.L("\t\tfor i := 0; i < 31; i++ { buf[i] = 0xff }")
			g.L("\t}")
			g.L("\tbuf[31] = byte(value)")
		} else {
			// uint8
			g.L("\tbuf[31] = byte(value)")
		}
	case 16:
		if t.T == abi.IntTy {
			// int16 - sign extend
			g.L("\tif value < 0 {")
			g.L("\t\tfor i := 0; i < 30; i++ { buf[i] = 0xff }")
			g.L("\t}")
			g.L("\tbinary.BigEndian.PutUint16(buf[30:32], uint16(value))")
		} else {
			// uint16
			g.L("\tbinary.BigEndian.PutUint16(buf[30:32], uint16(value))")
		}
	case 32:
		if t.T == abi.IntTy {
			// int32 - sign extend
			g.L("\tif value < 0 {")
			g.L("\t\tfor i := 0; i < 28; i++ { buf[i] = 0xff }")
			g.L("\t}")
			g.L("\tbinary.BigEndian.PutUint32(buf[28:32], uint32(value))")
		} else {
			// uint32
			g.L("\tbinary.BigEndian.PutUint32(buf[28:32], uint32(value))")
		}
	case 64:
		if t.T == abi.IntTy {
			// int64 - sign extend
			g.L("\tif value < 0 {")
			g.L("\t\tfor i := 0; i < 24; i++ { buf[i] = 0xff }")
			g.L("\t}")
			g.L("\tbinary.BigEndian.PutUint64(buf[24:32], uint64(value))")
		} else {
			// uint64
			g.L("\tbinary.BigEndian.PutUint64(buf[24:32], uint64(value))")
		}
	}

	g.L("\treturn 32, nil")
}

// genBigIntEncoding generates encoding for big.Int types
func (g *Generator2) genBigIntEncoding(t abi.Type) {
	signed := "false"
	if t.T == abi.IntTy {
		signed = "true"
	}

	g.L("\tif err := abi.EncodeBigInt(value, buf[:32], %s); err != nil {", signed)
	g.L("\t\treturn 0, err")
	g.L("\t}")
	g.L("\treturn 32, nil")
}

// genAddressEncoding generates encoding for address types
func (g *Generator2) genAddressEncoding() {
	g.L("\tcopy(buf[12:32], value[:])")
	g.L("\treturn 32, nil")
}

// genBoolEncoding generates encoding for boolean types
func (g *Generator2) genBoolEncoding() {
	g.L("\tif value {")
	g.L("\t\tbuf[31] = 1")
	g.L("\t}")
	g.L("\treturn 32, nil")
}

// genStringEncoding generates encoding for string types
func (g *Generator2) genStringEncoding() {
	g.L("\t// Encode length")
	g.L("\tbinary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))")
	g.L("\t")
	g.L("\t// Encode data")
	g.L("\tcopy(buf[32:], []byte(value))")
	g.L("\t")
	g.L("\treturn 32 + abi.Pad32(len(value)), nil")
}

// genBytesEncoding generates encoding for bytes types
func (g *Generator2) genBytesEncoding() {
	g.L("\t// Encode length")
	g.L("\tbinary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))")
	g.L("\t")
	g.L("\t// Encode data")
	g.L("\tcopy(buf[32:], value)")
	g.L("\t")
	g.L("\treturn 32 + abi.Pad32(len(value)), nil")
}

// genFixedBytesEncoding generates encoding for fixed bytes types
func (g *Generator2) genFixedBytesEncoding(t abi.Type) {
	g.L("\tcopy(buf[:%d], value[:])", t.Size)
	g.L("\treturn 32, nil")
}

// genSliceEncoding generates encoding for slice types
func (g *Generator2) genSliceEncoding(t abi.Type) error {
	if t.Elem == nil {
		return fmt.Errorf("slice type has nil element")
	}

	g.L("\t// Encode length")
	g.L("\tbinary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))")
	g.L("\t")
	g.L("\t// Encode elements")
	g.L("\toffset := 32")
	g.L("\tfor _, elem := range value {")
	g.L("\t\tn, err := %sbuf[offset:])", genEncodeCall(*t.Elem, "elem"))
	g.L("\t\tif err != nil {")
	g.L("\t\t\treturn 0, err")
	g.L("\t\t}")
	g.L("\t\toffset += n")
	g.L("\t}")
	g.L("\t")
	g.L("\treturn offset, nil")

	return nil
}

// genArrayEncoding generates encoding for array types
func (g *Generator2) genArrayEncoding(t abi.Type) error {
	if t.Elem == nil {
		return fmt.Errorf("array type has nil element")
	}

	g.L("\t// Encode fixed-size array")
	g.L("\toffset := 0")
	g.L("\tif len(value) != %d {", t.Size)
	g.L("\t\treturn 0, fmt.Errorf(\"invalid array length: expected %d, got %%d\", len(value))", t.Size)
	g.L("\t}")
	g.L("\tfor _, elem := range value {")
	g.L("\t\tn, err := %sbuf[offset:])", genEncodeCall(*t.Elem, "elem"))
	g.L("\t\tif err != nil {")
	g.L("\t\t\treturn 0, err")
	g.L("\t\t}")
	g.L("\t\toffset += n")
	g.L("\t}")
	g.L("\t")
	g.L("\treturn offset, nil")

	return nil
}

// genTupleEncoding generates encoding for tuple types
func (g *Generator2) genTupleEncoding(t abi.Type) error {
	// For tuple types, we need to generate the actual encoding logic
	// This handles the encoding of each field in the tuple

	g.L("\t// Encode tuple fields")
	g.L("\toffset := 0")

	// Generate encoding for each tuple element
	g.L("\tvar (")
	g.L("\t\terr error")
	g.L("\t\tn int")
	g.L("\t)")
	for i, elem := range t.TupleElems {
		if elem == nil {
			return fmt.Errorf("tuple element %d is nil", i)
		}

		// Generate field access - use meaningful field names if available
		fieldName := fmt.Sprintf("value.Field%d", i)
		if i < len(t.TupleRawNames) && t.TupleRawNames[i] != "" {
			fieldName = fmt.Sprintf("value.%s", Title.String(t.TupleRawNames[i]))
		}
		g.L("\t// Field %d: %s", i, elem.String())
		g.L("\tn, err = %sbuf[offset:])", genEncodeCall(*elem, fieldName))
		g.L("\tif err != nil {")
		g.L("\t\treturn 0, err")
		g.L("\t}")
		g.L("\toffset += n")
		g.L("")
	}

	g.L("\treturn offset, nil")
	g.L("}")

	return nil
}

// genTuples generates all tuple structs needed for a function
func (g *Generator2) genTuples(methods []abi.Method) error {
	// Collect all tuple types from function inputs and outputs
	tupleTypes := make(map[string]abi.Type)

	var collectTuples func(t abi.Type)
	collectTuples = func(t abi.Type) {
		if t.T == abi.TupleTy {
			structName := TupleStructName(t)
			if _, exists := tupleTypes[structName]; !exists {
				tupleTypes[structName] = t
				// Recursively collect nested tuples
				for _, elem := range t.TupleElems {
					collectTuples(*elem)
				}
			}
		} else if t.T == abi.ArrayTy || t.T == abi.SliceTy {
			// Check array elements for tuples
			if t.Elem != nil {
				collectTuples(*t.Elem)
			}
		}
	}

	// Collect tuples from all methods
	for _, method := range methods {
		// Collect tuples from all inputs
		for _, input := range method.Inputs {
			collectTuples(input.Type)
		}
		// Collect tuples from all outputs
		for _, output := range method.Outputs {
			collectTuples(output.Type)
		}
	}

	// Generate struct definitions for collected tuples
	for _, name := range SortedMapKeys(tupleTypes) {
		// Check if this tuple should use an external implementation
		if _, exists := g.Options.ExternalTuples[name]; exists {
			// Skip generating this tuple since it uses an external implementation
			continue
		}

		tupleType := tupleTypes[name]
		s := StructFromTuple(tupleType)
		if err := g.genStruct(s); err != nil {
			return err
		}

		// Generate encode method for the tuple struct
		g.genStructMethods(s)
	}

	return nil
}

// genStruct generates a struct definition
func (g *Generator2) genStruct(s Struct) error {
	g.L("")
	g.L("const %sStaticSize = %d", s.Name, GetTupleSize(s.Types()))
	g.L("")
	g.L("// %s represents an ABI tuple", s.Name)
	g.L("type %s struct {", s.Name)

	for _, f := range s.Fields {
		goType := g.abiTypeToGoType(*f.Type)
		g.L("%s %s", f.Name, goType)
	}
	g.L("}")
	return nil
}

// genStructMethods generates Encode/Decode methods for tuple structs
func (g *Generator2) genStructMethods(s Struct) {
	// Generate EncodedSize method
	g.genEncodedSize(s)

	// Generate EncodeTo method that calls standalone function
	g.genStructEncodeTo(s)

	// Generate Encode method
	g.L("")
	g.L("// Encode encodes %s to ABI bytes", s.Name)
	g.L("func (t %s) Encode() ([]byte, error) {", s.Name)
	g.L("\tbuf := make([]byte, t.EncodedSize())")
	g.L("\tif _, err := t.EncodeTo(buf); err != nil {")
	g.L("\t\treturn nil, err")
	g.L("\t}")
	g.L("\treturn buf, nil")
	g.L("}")

	// Generate Decode method (placeholder for now)
	g.genDecode(s)
}

// genStructEncodeTo generates the EncodeTo method that calls standalone function
func (g *Generator2) genStructEncodeTo(s Struct) error {
	g.L("")
	g.L("// EncodeTo encodes %s to ABI bytes in the provided buffer", s.Name)
	g.L("func (value %s) EncodeTo(buf []byte) (int, error) {", s.Name)

	if err := g.genTupleEncoding(s.T); err != nil {
		return err
	}

	return nil
}

// genEncodedSize generates the size calculation logic without selector
func (g *Generator2) genEncodedSize(s Struct) {
	g.L("")
	g.L("// EncodedSize returns the total encoded size of %s", s.Name)
	g.L("func (t %s) EncodedSize() int {", s.Name)
	g.L("\tdynamicSize := 0")

	for _, f := range s.Fields {
		if !IsDynamicType(*f.Type) {
			continue
		}
		// Use size functions instead of inline calculations
		g.L("	dynamicSize += %st.%s)", genSizeCall(*f.Type), f.Name)
	}

	g.L("")
	g.L("\treturn %sStaticSize + dynamicSize", s.Name)
	g.L("}")
}

// genSize generates size calculation logic for a type
func (g *Generator2) genSize(t abi.Type, acc string, ref string) {
	if !IsDynamicType(t) {
		g.L("%s += %d // static element %s", acc, GetTypeSize(t), ref)
		return
	}

	switch t.T {
	case abi.StringTy:
		g.L("%s += 32 + abi.Pad32(len(%s)) // length + padded string data", acc, ref)

	case abi.BytesTy:
		g.L("%s += 32 + abi.Pad32(len(%s)) // length + padded bytes data", acc, ref)

	case abi.SliceTy:
		if IsDynamicType(*t.Elem) {
			// Dynamic array with dynamic elements
			g.L("%s += 32 + 32 * len(%s) // length + offset pointers for dynamic elements", acc, ref)
			g.L("for _, elem := range %s {", ref)
			g.genSizeIndented(*t.Elem, acc, "elem")
			g.L("}")
		} else {
			// Dynamic array with static elements
			g.L("%s += 32 + %d * len(%s) // length + static elements", acc, GetTypeSize(*t.Elem), ref)
		}

	case abi.ArrayTy:
		// Fixed size array of dynamic element types
		g.L("for _, elem := range %s {", ref)
		g.genSizeIndented(*t.Elem, acc, "elem")
		g.L("}")

	case abi.TupleTy:
		// Dynamic tuple, just call tuple struct method
		g.L("%s += %s.EncodedSize() // dynamic tuple", acc, ref)

	default:
		panic("impossible")
	}
}

// genSizeIndented generates size calculation logic with proper indentation
func (g *Generator2) genSizeIndented(t abi.Type, acc string, ref string) {
	if !IsDynamicType(t) {
		g.L("\t%s += %d // static element %s", acc, GetTypeSize(t), ref)
		return
	}

	switch t.T {
	case abi.StringTy:
		g.L("\t%s += 32 + abi.Pad32(len(%s)) // length + padded string data", acc, ref)

	case abi.BytesTy:
		g.L("\t%s += 32 + abi.Pad32(len(%s)) // length + padded bytes data", acc, ref)

	case abi.SliceTy:
		if IsDynamicType(*t.Elem) {
			// Dynamic array with dynamic elements
			g.L("\t%s += 32 + 32 * len(%s) // length + offset pointers for dynamic elements", acc, ref)
			g.L("\tfor _, elem := range %s {", ref)
			g.genSizeIndented(*t.Elem, acc, "elem")
			g.L("\t}")
		} else {
			// Dynamic array with static elements
			g.L("\t%s += 32 + %d * len(%s) // length + static elements", acc, GetTypeSize(*t.Elem), ref)
		}

	case abi.ArrayTy:
		// Fixed size array of dynamic element types
		g.L("\tfor _, elem := range %s {", ref)
		g.genSizeIndented(*t.Elem, acc, "elem")
		g.L("\t}")

	case abi.TupleTy:
		// Dynamic tuple, just call tuple struct method
		g.L("\t%s += %s.EncodedSize() // dynamic tuple", acc, ref)

	default:
		panic("impossible")
	}
}

// genDecode generates the Decode method (placeholder for now)
func (g *Generator2) genDecode(s Struct) {
	g.L("")
	g.L("// Decode decodes %s from ABI bytes in the provided buffer", s.Name)
	g.L("func (t *%s) Decode(data0 []byte) error {", s.Name)
	g.L("\t// TODO: Implement decode")
	g.L("\treturn fmt.Errorf(\"decode not yet implemented\")")
	g.L("}")
}

func (g *Generator2) genFunction(method abi.Method) error {
	// TODO: Implement function generation with standalone functions
	// For now, just generate a placeholder
	selectorName := fmt.Sprintf("%sSelector", Title.String(method.Name))

	// Generate struct and methods for functions with inputs
	if len(method.Inputs) > 0 {
		s := StructFromInputs(method)

		// For function argument structs, we need to ensure the tuple type identifier
		// matches the actual struct name used in encoding functions
		// Create a tuple type from the inputs to get the correct identifier
		inputTypes := make([]*abi.Type, len(method.Inputs))
		for i, input := range method.Inputs {
			inputType := input.Type
			inputTypes[i] = &inputType
		}

		if err := g.genStruct(s); err != nil {
			return err
		}

		g.genStructMethods(s)

		g.L("")
		g.L("// EncodeWithSelector encodes %s arguments to ABI bytes including function selector", method.Name)
		g.L("func (t %s) EncodeWithSelector() ([]byte, error) {", s.Name)
		g.L("\tresult := make([]byte, 4 + t.EncodedSize())")
		g.L("\tcopy(result[:4], %s[:])", selectorName)
		g.L("\tif _, err := t.EncodeTo(result[4:]); err != nil {")
		g.L("\t\treturn nil, err")
		g.L("\t}")
		g.L("\treturn result, nil")
		g.L("}")
	}

	return nil
}

func (g *Generator2) genEvent(event EventInfo) error {
	// TODO: Implement event generation
	return nil
}

func (g *Generator2) genAllSelectors() {
	// Reuse existing implementation
	if len(g.Selectors) == 0 {
		return
	}

	g.L("")
	g.L("// Function selectors")
	g.L("var (")
	for _, selector := range g.Selectors {
		g.L("\t// %s", selector.Sig)
		g.L("\t%sSelector = [4]byte{0x%02x, 0x%02x, 0x%02x, 0x%02x}",
			selector.Name,
			selector.Bytes[0],
			selector.Bytes[1],
			selector.Bytes[2],
			selector.Bytes[3])
	}
	g.L(")")

	g.L("")
	g.L("// Big endian integer versions of function selectors")
	g.L("const (")
	for _, selector := range g.Selectors {
		// Generate integer version of selector
		selectorInt := binary.BigEndian.Uint32(selector.Bytes[:])
		g.L("\t%sID = %d", selector.Name, selectorInt)
	}
	g.L(")")
}

// abiTypeToGoType converts ABI type to Go type (reuse existing implementation)
func (g *Generator2) abiTypeToGoType(abiType abi.Type) string {
	// Reuse the existing implementation from generator.go
	// This is a temporary placeholder - we should refactor this to avoid duplication
	switch abiType.T {
	case abi.UintTy:
		// Use native Go types for common sizes to avoid big.Int allocations
		switch abiType.Size {
		case 8, 16, 32, 64:
			return fmt.Sprintf("uint%d", abiType.Size)
		default:
			return "*big.Int"
		}
	case abi.IntTy:
		// Use native Go types for common sizes to avoid big.Int allocations
		switch abiType.Size {
		case 8, 16, 32, 64:
			return fmt.Sprintf("int%d", abiType.Size)
		default:
			return "*big.Int"
		}
	case abi.AddressTy:
		return "common.Address"
	case abi.BoolTy:
		return "bool"
	case abi.StringTy:
		return "string"
	case abi.BytesTy:
		return "[]byte"
	case abi.FixedBytesTy:
		return fmt.Sprintf("[%d]byte", abiType.Size)
	case abi.SliceTy:
		// Dynamic arrays like uint256[]
		if abiType.Elem == nil {
			panic("invalid slice type: nil element")
		}
		elemType := g.abiTypeToGoType(*abiType.Elem)
		return fmt.Sprintf("[]%s", elemType)
	case abi.ArrayTy:
		// Fixed-size arrays like uint256[10]
		if abiType.Elem == nil {
			panic("invalid array type: nil element")
		}
		elemType := g.abiTypeToGoType(*abiType.Elem)
		return fmt.Sprintf("[%d]%s", abiType.Size, elemType)
	case abi.TupleTy:
		// Handle tuple types - generate struct type name
		structName := TupleStructName(abiType)
		// Check if this tuple has an external implementation
		if externalName, exists := g.Options.ExternalTuples[structName]; exists {
			return externalName
		}
		return structName
	default:
		panic(fmt.Sprintf("unsupported ABI type: %s", abiType.String()))
	}
}

func genEncodeCall(t abi.Type, value string) string {
	// Generate the function name for encoding a call with this type
	if t.T == abi.TupleTy {
		// For tuple types, use the struct's EncodeTo method
		return fmt.Sprintf("%s.EncodeTo(", value)
	}

	typeID := GenTypeIdentifier(t)
	return fmt.Sprintf("encode_%s(%s, ", typeID, value)
}

func genSizeCall(t abi.Type) string {
	// Generate the function name for size calculation with this type
	if t.T == abi.TupleTy {
		// For tuple types, use the struct's EncodedSize method
		return "value.EncodedSize()"
	}

	typeID := GenTypeIdentifier(t)
	return fmt.Sprintf("size_%s(", typeID)
}
