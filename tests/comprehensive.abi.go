// Code generated by go-abi. DO NOT EDIT.

package tests

import (
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/yihuang/go-abi"
)

// Function selectors
var (
	// testComplexDynamicTuples((uint256,(string,string[],(uint256,string[])))[])
	TestComplexDynamicTuplesSelector = [4]byte{0xc0, 0x96, 0x4c, 0x93}
	// testDeeplyNested(((((uint256,string)))))
	TestDeeplyNestedSelector = [4]byte{0x21, 0x75, 0xe8, 0x54}
	// testExternalTuple((address,string,uint256))
	TestExternalTupleSelector = [4]byte{0x96, 0x39, 0x8b, 0x38}
	// testFixedArrays(address[5],uint256[3],bytes32[2])
	TestFixedArraysSelector = [4]byte{0x23, 0xb8, 0x46, 0x5c}
	// testMixedTypes(bytes32,bytes,bool,uint8,(uint32,bytes,bool)[])
	TestMixedTypesSelector = [4]byte{0x85, 0x8a, 0xe6, 0x15}
	// testNestedDynamicArrays(uint256[][],address[][3][],string[][])
	TestNestedDynamicArraysSelector = [4]byte{0x1a, 0xdd, 0xf6, 0x20}
	// testNestedStruct(((address,string,uint256)[]))
	TestNestedStructSelector = [4]byte{0xe8, 0x3b, 0x85, 0x67}
	// testSmallIntegers(uint8,uint16,uint32,uint64,int8,int16,int32,int64)
	TestSmallIntegersSelector = [4]byte{0x29, 0x2b, 0xd2, 0x39}
)

// Big endian integer versions of function selectors
const (
	TestComplexDynamicTuplesID = 3231075475
	TestDeeplyNestedID         = 561375316
	TestExternalTupleID        = 2520353592
	TestFixedArraysID          = 599279196
	TestMixedTypesID           = 2240472597
	TestNestedDynamicArraysID  = 450754080
	TestNestedStructID         = 3896214887
	TestSmallIntegersID        = 690737721
)

const GroupStaticSize = 32

// Group represents an ABI tuple
type Group struct {
	Users []User
}

// EncodedSize returns the total encoded size of Group
func (t Group) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += SizeUserSlice(t.Users)

	return GroupStaticSize + dynamicSize
}

// EncodeTo encodes Group to ABI bytes in the provided buffer
func (value Group) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := GroupStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Users: (address,string,uint256)[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeUserSlice(value.Users, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes Group to ABI bytes
func (value Group) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Group from ABI bytes in the provided buffer
func (t *Group) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field Users
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Users")
		}
		t.Users, n, err = DecodeUserSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

const ItemStaticSize = 96

// Item represents an ABI tuple
type Item struct {
	Id     uint32
	Data   []byte
	Active bool
}

// EncodedSize returns the total encoded size of Item
func (t Item) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += SizeBytes(t.Data)

	return ItemStaticSize + dynamicSize
}

// EncodeTo encodes Item to ABI bytes in the provided buffer
func (value Item) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := ItemStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Id: uint32
	if _, err := EncodeUint32(value.Id, buf[0:]); err != nil {
		return 0, err
	}

	// Field Data: bytes
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeBytes(value.Data, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Active: bool
	if _, err := EncodeBool(value.Active, buf[64:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes Item to ABI bytes
func (value Item) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Item from ABI bytes in the provided buffer
func (t *Item) Decode(data []byte) (int, error) {
	if len(data) < 96 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 96
	// Decode static field Id: uint32
	t.Id, _, err = DecodeUint32(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Data
	{
		offset := int(binary.BigEndian.Uint64(data[32+24 : 32+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Data")
		}
		t.Data, n, err = DecodeBytes(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode static field Active: bool
	t.Active, _, err = DecodeBool(data[64:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

const Level1StaticSize = 32

// Level1 represents an ABI tuple
type Level1 struct {
	Level1 Level2
}

// EncodedSize returns the total encoded size of Level1
func (t Level1) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.Level1.EncodedSize()

	return Level1StaticSize + dynamicSize
}

// EncodeTo encodes Level1 to ABI bytes in the provided buffer
func (value Level1) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := Level1StaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Level1: (((uint256,string)))
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.Level1.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes Level1 to ABI bytes
func (value Level1) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Level1 from ABI bytes in the provided buffer
func (t *Level1) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field Level1
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Level1")
		}
		n, err = t.Level1.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

const Level2StaticSize = 32

// Level2 represents an ABI tuple
type Level2 struct {
	Level2 Level3
}

// EncodedSize returns the total encoded size of Level2
func (t Level2) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.Level2.EncodedSize()

	return Level2StaticSize + dynamicSize
}

// EncodeTo encodes Level2 to ABI bytes in the provided buffer
func (value Level2) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := Level2StaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Level2: ((uint256,string))
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.Level2.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes Level2 to ABI bytes
func (value Level2) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Level2 from ABI bytes in the provided buffer
func (t *Level2) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field Level2
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Level2")
		}
		n, err = t.Level2.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

const Level3StaticSize = 32

// Level3 represents an ABI tuple
type Level3 struct {
	Level3 Level4
}

// EncodedSize returns the total encoded size of Level3
func (t Level3) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.Level3.EncodedSize()

	return Level3StaticSize + dynamicSize
}

// EncodeTo encodes Level3 to ABI bytes in the provided buffer
func (value Level3) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := Level3StaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Level3: (uint256,string)
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.Level3.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes Level3 to ABI bytes
func (value Level3) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Level3 from ABI bytes in the provided buffer
func (t *Level3) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field Level3
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Level3")
		}
		n, err = t.Level3.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

const Level4StaticSize = 64

// Level4 represents an ABI tuple
type Level4 struct {
	Value       *big.Int
	Description string
}

// EncodedSize returns the total encoded size of Level4
func (t Level4) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += SizeString(t.Description)

	return Level4StaticSize + dynamicSize
}

// EncodeTo encodes Level4 to ABI bytes in the provided buffer
func (value Level4) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := Level4StaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Value: uint256
	if _, err := EncodeUint256(value.Value, buf[0:]); err != nil {
		return 0, err
	}

	// Field Description: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeString(value.Description, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes Level4 to ABI bytes
func (value Level4) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Level4 from ABI bytes in the provided buffer
func (t *Level4) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 64
	// Decode static field Value: uint256
	t.Value, _, err = DecodeUint256(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Description
	{
		offset := int(binary.BigEndian.Uint64(data[32+24 : 32+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Description")
		}
		t.Description, n, err = DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

const User2StaticSize = 64

// User2 represents an ABI tuple
type User2 struct {
	Id      *big.Int
	Profile UserProfile
}

// EncodedSize returns the total encoded size of User2
func (t User2) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.Profile.EncodedSize()

	return User2StaticSize + dynamicSize
}

// EncodeTo encodes User2 to ABI bytes in the provided buffer
func (value User2) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := User2StaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Id: uint256
	if _, err := EncodeUint256(value.Id, buf[0:]); err != nil {
		return 0, err
	}

	// Field Profile: (string,string[],(uint256,string[]))
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.Profile.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes User2 to ABI bytes
func (value User2) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes User2 from ABI bytes in the provided buffer
func (t *User2) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 64
	// Decode static field Id: uint256
	t.Id, _, err = DecodeUint256(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Profile
	{
		offset := int(binary.BigEndian.Uint64(data[32+24 : 32+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Profile")
		}
		n, err = t.Profile.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

const UserMetadata2StaticSize = 64

// UserMetadata2 represents an ABI tuple
type UserMetadata2 struct {
	CreatedAt *big.Int
	Tags      []string
}

// EncodedSize returns the total encoded size of UserMetadata2
func (t UserMetadata2) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += SizeStringSlice(t.Tags)

	return UserMetadata2StaticSize + dynamicSize
}

// EncodeTo encodes UserMetadata2 to ABI bytes in the provided buffer
func (value UserMetadata2) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := UserMetadata2StaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field CreatedAt: uint256
	if _, err := EncodeUint256(value.CreatedAt, buf[0:]); err != nil {
		return 0, err
	}

	// Field Tags: string[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeStringSlice(value.Tags, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes UserMetadata2 to ABI bytes
func (value UserMetadata2) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes UserMetadata2 from ABI bytes in the provided buffer
func (t *UserMetadata2) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 64
	// Decode static field CreatedAt: uint256
	t.CreatedAt, _, err = DecodeUint256(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Tags
	{
		offset := int(binary.BigEndian.Uint64(data[32+24 : 32+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Tags")
		}
		t.Tags, n, err = DecodeStringSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

const UserProfileStaticSize = 96

// UserProfile represents an ABI tuple
type UserProfile struct {
	Name     string
	Emails   []string
	Metadata UserMetadata2
}

// EncodedSize returns the total encoded size of UserProfile
func (t UserProfile) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += SizeString(t.Name)
	dynamicSize += SizeStringSlice(t.Emails)
	dynamicSize += t.Metadata.EncodedSize()

	return UserProfileStaticSize + dynamicSize
}

// EncodeTo encodes UserProfile to ABI bytes in the provided buffer
func (value UserProfile) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := UserProfileStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Name: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeString(value.Name, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Emails: string[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeStringSlice(value.Emails, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Metadata: (uint256,string[])
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[64+24:64+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.Metadata.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes UserProfile to ABI bytes
func (value UserProfile) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes UserProfile from ABI bytes in the provided buffer
func (t *UserProfile) Decode(data []byte) (int, error) {
	if len(data) < 96 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 96
	// Decode dynamic field Name
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Name")
		}
		t.Name, n, err = DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Emails
	{
		offset := int(binary.BigEndian.Uint64(data[32+24 : 32+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Emails")
		}
		t.Emails, n, err = DecodeStringSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Metadata
	{
		offset := int(binary.BigEndian.Uint64(data[64+24 : 64+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Metadata")
		}
		n, err = t.Metadata.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// EncodeAddress encodes address to ABI bytes
func EncodeAddress(value common.Address, buf []byte) (int, error) {
	copy(buf[12:32], value[:])
	return 32, nil
}

// EncodeAddressArray5 encodes address[5] to ABI bytes
func EncodeAddressArray5(value [5]common.Address, buf []byte) (int, error) {
	// Encode fixed-size array with static elements
	if _, err := EncodeAddress(value[0], buf[0:]); err != nil {
		return 0, err
	}
	if _, err := EncodeAddress(value[1], buf[32:]); err != nil {
		return 0, err
	}
	if _, err := EncodeAddress(value[2], buf[64:]); err != nil {
		return 0, err
	}
	if _, err := EncodeAddress(value[3], buf[96:]); err != nil {
		return 0, err
	}
	if _, err := EncodeAddress(value[4], buf[128:]); err != nil {
		return 0, err
	}

	return 160, nil
}

// EncodeAddressSlice encodes address[] to ABI bytes
func EncodeAddressSlice(value []common.Address, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeAddress(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeAddressSliceArray3 encodes address[][3] to ABI bytes
func EncodeAddressSliceArray3(value [3][]common.Address, buf []byte) (int, error) {
	// Encode fixed-size array with dynamic elements
	var (
		n   int
		err error
	)
	dynamicOffset := 32 * 3
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	n, err = EncodeAddressSlice(value[0], buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	n, err = EncodeAddressSlice(value[1], buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	binary.BigEndian.PutUint64(buf[64+24:64+32], uint64(dynamicOffset))
	n, err = EncodeAddressSlice(value[2], buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// EncodeAddressSliceArray3Slice encodes address[][3][] to ABI bytes
func EncodeAddressSliceArray3Slice(value [][3][]common.Address, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with dynamic types
	var offset int
	dynamicOffset := len(value) * 32
	for _, elem := range value {
		// Write offset for element
		offset += 32
		binary.BigEndian.PutUint64(buf[offset-8:offset], uint64(dynamicOffset))

		// Write element at dynamic region
		n, err := EncodeAddressSliceArray3(elem, buf[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}

	return dynamicOffset + 32, nil
}

// EncodeBool encodes bool to ABI bytes
func EncodeBool(value bool, buf []byte) (int, error) {
	if value {
		buf[31] = 1
	}
	return 32, nil
}

// EncodeBytes encodes bytes to ABI bytes
func EncodeBytes(value []byte, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))

	// Encode data
	copy(buf[32:], value)

	return 32 + abi.Pad32(len(value)), nil
}

// EncodeBytes32 encodes bytes32 to ABI bytes
func EncodeBytes32(value [32]byte, buf []byte) (int, error) {
	copy(buf[:32], value[:])
	return 32, nil
}

// EncodeBytes32Array2 encodes bytes32[2] to ABI bytes
func EncodeBytes32Array2(value [2][32]byte, buf []byte) (int, error) {
	// Encode fixed-size array with static elements
	if _, err := EncodeBytes32(value[0], buf[0:]); err != nil {
		return 0, err
	}
	if _, err := EncodeBytes32(value[1], buf[32:]); err != nil {
		return 0, err
	}

	return 64, nil
}

// EncodeInt16 encodes int16 to ABI bytes
func EncodeInt16(value int16, buf []byte) (int, error) {
	if value < 0 {
		for i := 0; i < 30; i++ {
			buf[i] = 0xff
		}
	}
	binary.BigEndian.PutUint16(buf[30:32], uint16(value))
	return 32, nil
}

// EncodeInt32 encodes int32 to ABI bytes
func EncodeInt32(value int32, buf []byte) (int, error) {
	if value < 0 {
		for i := 0; i < 28; i++ {
			buf[i] = 0xff
		}
	}
	binary.BigEndian.PutUint32(buf[28:32], uint32(value))
	return 32, nil
}

// EncodeInt64 encodes int64 to ABI bytes
func EncodeInt64(value int64, buf []byte) (int, error) {
	if value < 0 {
		for i := 0; i < 24; i++ {
			buf[i] = 0xff
		}
	}
	binary.BigEndian.PutUint64(buf[24:32], uint64(value))
	return 32, nil
}

// EncodeInt8 encodes int8 to ABI bytes
func EncodeInt8(value int8, buf []byte) (int, error) {
	if value < 0 {
		for i := 0; i < 31; i++ {
			buf[i] = 0xff
		}
	}
	buf[31] = byte(value)
	return 32, nil
}

// EncodeItemSlice encodes (uint32,bytes,bool)[] to ABI bytes
func EncodeItemSlice(value []Item, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with dynamic types
	var offset int
	dynamicOffset := len(value) * 32
	for _, elem := range value {
		// Write offset for element
		offset += 32
		binary.BigEndian.PutUint64(buf[offset-8:offset], uint64(dynamicOffset))

		// Write element at dynamic region
		n, err := elem.EncodeTo(buf[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}

	return dynamicOffset + 32, nil
}

// EncodeString encodes string to ABI bytes
func EncodeString(value string, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))

	// Encode data
	copy(buf[32:], []byte(value))

	return 32 + abi.Pad32(len(value)), nil
}

// EncodeStringSlice encodes string[] to ABI bytes
func EncodeStringSlice(value []string, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with dynamic types
	var offset int
	dynamicOffset := len(value) * 32
	for _, elem := range value {
		// Write offset for element
		offset += 32
		binary.BigEndian.PutUint64(buf[offset-8:offset], uint64(dynamicOffset))

		// Write element at dynamic region
		n, err := EncodeString(elem, buf[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}

	return dynamicOffset + 32, nil
}

// EncodeStringSliceSlice encodes string[][] to ABI bytes
func EncodeStringSliceSlice(value [][]string, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with dynamic types
	var offset int
	dynamicOffset := len(value) * 32
	for _, elem := range value {
		// Write offset for element
		offset += 32
		binary.BigEndian.PutUint64(buf[offset-8:offset], uint64(dynamicOffset))

		// Write element at dynamic region
		n, err := EncodeStringSlice(elem, buf[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}

	return dynamicOffset + 32, nil
}

// EncodeUint16 encodes uint16 to ABI bytes
func EncodeUint16(value uint16, buf []byte) (int, error) {
	binary.BigEndian.PutUint16(buf[30:32], uint16(value))
	return 32, nil
}

// EncodeUint256 encodes uint256 to ABI bytes
func EncodeUint256(value *big.Int, buf []byte) (int, error) {
	if err := abi.EncodeBigInt(value, buf[:32], false); err != nil {
		return 0, err
	}
	return 32, nil
}

// EncodeUint256Array3 encodes uint256[3] to ABI bytes
func EncodeUint256Array3(value [3]*big.Int, buf []byte) (int, error) {
	// Encode fixed-size array with static elements
	if _, err := EncodeUint256(value[0], buf[0:]); err != nil {
		return 0, err
	}
	if _, err := EncodeUint256(value[1], buf[32:]); err != nil {
		return 0, err
	}
	if _, err := EncodeUint256(value[2], buf[64:]); err != nil {
		return 0, err
	}

	return 96, nil
}

// EncodeUint256Slice encodes uint256[] to ABI bytes
func EncodeUint256Slice(value []*big.Int, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeUint256(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeUint256SliceSlice encodes uint256[][] to ABI bytes
func EncodeUint256SliceSlice(value [][]*big.Int, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with dynamic types
	var offset int
	dynamicOffset := len(value) * 32
	for _, elem := range value {
		// Write offset for element
		offset += 32
		binary.BigEndian.PutUint64(buf[offset-8:offset], uint64(dynamicOffset))

		// Write element at dynamic region
		n, err := EncodeUint256Slice(elem, buf[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}

	return dynamicOffset + 32, nil
}

// EncodeUint32 encodes uint32 to ABI bytes
func EncodeUint32(value uint32, buf []byte) (int, error) {
	binary.BigEndian.PutUint32(buf[28:32], uint32(value))
	return 32, nil
}

// EncodeUint64 encodes uint64 to ABI bytes
func EncodeUint64(value uint64, buf []byte) (int, error) {
	binary.BigEndian.PutUint64(buf[24:32], uint64(value))
	return 32, nil
}

// EncodeUint8 encodes uint8 to ABI bytes
func EncodeUint8(value uint8, buf []byte) (int, error) {
	buf[31] = byte(value)
	return 32, nil
}

// EncodeUser2Slice encodes (uint256,(string,string[],(uint256,string[])))[] to ABI bytes
func EncodeUser2Slice(value []User2, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with dynamic types
	var offset int
	dynamicOffset := len(value) * 32
	for _, elem := range value {
		// Write offset for element
		offset += 32
		binary.BigEndian.PutUint64(buf[offset-8:offset], uint64(dynamicOffset))

		// Write element at dynamic region
		n, err := elem.EncodeTo(buf[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}

	return dynamicOffset + 32, nil
}

// EncodeUserSlice encodes (address,string,uint256)[] to ABI bytes
func EncodeUserSlice(value []User, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with dynamic types
	var offset int
	dynamicOffset := len(value) * 32
	for _, elem := range value {
		// Write offset for element
		offset += 32
		binary.BigEndian.PutUint64(buf[offset-8:offset], uint64(dynamicOffset))

		// Write element at dynamic region
		n, err := elem.EncodeTo(buf[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}

	return dynamicOffset + 32, nil
}

// SizeAddressSlice returns the encoded size of address[]
func SizeAddressSlice(value []common.Address) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeAddressSliceArray3 returns the encoded size of address[][3]
func SizeAddressSliceArray3(value [3][]common.Address) int {
	size := 32 * 3 // offsets
	size += SizeAddressSlice(value[0])
	size += SizeAddressSlice(value[1])
	size += SizeAddressSlice(value[2])
	return size
}

// SizeAddressSliceArray3Slice returns the encoded size of address[][3][]
func SizeAddressSliceArray3Slice(value [][3][]common.Address) int {
	size := 32 + 32*len(value) // length + offset pointers for dynamic elements
	for _, elem := range value {
		size += SizeAddressSliceArray3(elem)
	}
	return size
}

// SizeBytes returns the encoded size of bytes
func SizeBytes(value []byte) int {
	size := 32 + abi.Pad32(len(value)) // length + padded bytes data
	return size
}

// SizeItemSlice returns the encoded size of (uint32,bytes,bool)[]
func SizeItemSlice(value []Item) int {
	size := 32 + 32*len(value) // length + offset pointers for dynamic elements
	for _, elem := range value {
		size += elem.EncodedSize()
	}
	return size
}

// SizeString returns the encoded size of string
func SizeString(value string) int {
	size := 32 + abi.Pad32(len(value)) // length + padded string data
	return size
}

// SizeStringSlice returns the encoded size of string[]
func SizeStringSlice(value []string) int {
	size := 32 + 32*len(value) // length + offset pointers for dynamic elements
	for _, elem := range value {
		size += SizeString(elem)
	}
	return size
}

// SizeStringSliceSlice returns the encoded size of string[][]
func SizeStringSliceSlice(value [][]string) int {
	size := 32 + 32*len(value) // length + offset pointers for dynamic elements
	for _, elem := range value {
		size += SizeStringSlice(elem)
	}
	return size
}

// SizeUint256Slice returns the encoded size of uint256[]
func SizeUint256Slice(value []*big.Int) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeUint256SliceSlice returns the encoded size of uint256[][]
func SizeUint256SliceSlice(value [][]*big.Int) int {
	size := 32 + 32*len(value) // length + offset pointers for dynamic elements
	for _, elem := range value {
		size += SizeUint256Slice(elem)
	}
	return size
}

// SizeUser2Slice returns the encoded size of (uint256,(string,string[],(uint256,string[])))[]
func SizeUser2Slice(value []User2) int {
	size := 32 + 32*len(value) // length + offset pointers for dynamic elements
	for _, elem := range value {
		size += elem.EncodedSize()
	}
	return size
}

// SizeUserSlice returns the encoded size of (address,string,uint256)[]
func SizeUserSlice(value []User) int {
	size := 32 + 32*len(value) // length + offset pointers for dynamic elements
	for _, elem := range value {
		size += elem.EncodedSize()
	}
	return size
}

// DecodeAddress decodes address from ABI bytes
func DecodeAddress(data []byte) (common.Address, int, error) {
	var result common.Address
	copy(result[:], data[12:32])
	return result, 32, nil
}

// DecodeAddressArray5 decodes address[5] from ABI bytes
func DecodeAddressArray5(data []byte) ([5]common.Address, int, error) {
	// Decode fixed-size array with static elements
	var (
		result [5]common.Address
		err    error
	)
	if len(data) < 160 {
		return result, 0, io.ErrUnexpectedEOF
	}
	// Element 0
	result[0], _, err = DecodeAddress(data[0:])
	if err != nil {
		return result, 0, err
	}
	// Element 1
	result[1], _, err = DecodeAddress(data[32:])
	if err != nil {
		return result, 0, err
	}
	// Element 2
	result[2], _, err = DecodeAddress(data[64:])
	if err != nil {
		return result, 0, err
	}
	// Element 3
	result[3], _, err = DecodeAddress(data[96:])
	if err != nil {
		return result, 0, err
	}
	// Element 4
	result[4], _, err = DecodeAddress(data[128:])
	if err != nil {
		return result, 0, err
	}
	return result, 160, nil
}

// DecodeAddressSlice decodes address[] from ABI bytes
func DecodeAddressSlice(data []byte) ([]common.Address, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 32*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with static types
	result := make([]common.Address, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeAddress(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeAddressSliceArray3 decodes address[][3] from ABI bytes
func DecodeAddressSliceArray3(data []byte) ([3][]common.Address, int, error) {
	// Decode fixed-size array with dynamic elements
	var result [3][]common.Address
	if len(data) < 96 {
		return result, 0, io.ErrUnexpectedEOF
	}
	var (
		n   int
		err error
	)
	offset := 0
	dynamicOffset := 96
	for i := 0; i < 3; i++ {
		offset += 32
		tmp := int(binary.BigEndian.Uint64(data[offset-8 : offset]))
		if dynamicOffset != tmp {
			return result, 0, fmt.Errorf("invalid offset for array element %d: expected %d, got %d", i, dynamicOffset, tmp)
		}
		result[i], n, err = DecodeAddressSlice(data[dynamicOffset:])
		if err != nil {
			return result, 0, err
		}
		dynamicOffset += n
	}
	return result, dynamicOffset, nil
}

// DecodeAddressSliceArray3Slice decodes address[][3][] from ABI bytes
func DecodeAddressSliceArray3Slice(data []byte) ([][3][]common.Address, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 32*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with dynamic types
	result := make([][3][]common.Address, length)
	dynamicOffset := length * 32
	for i := 0; i < length; i++ {
		offset += 32
		tmp := int(binary.BigEndian.Uint64(data[offset-8 : offset]))
		if dynamicOffset != tmp {
			return nil, 0, fmt.Errorf("invalid offset for slice element %d: expected %d, got %d", i, dynamicOffset, tmp)
		}
		result[i], n, err = DecodeAddressSliceArray3(data[dynamicOffset:])
		if err != nil {
			return nil, 0, err
		}
		dynamicOffset += n
	}
	return result, dynamicOffset + 32, nil
}

// DecodeBool decodes bool from ABI bytes
func DecodeBool(data []byte) (bool, int, error) {
	result := data[31] != 0
	return result, 32, nil
}

// DecodeBytes decodes bytes from ABI bytes
func DecodeBytes(data []byte) ([]byte, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32+abi.Pad32(length) {
		return nil, 0, io.ErrUnexpectedEOF
	}

	// Decode data
	result := make([]byte, length)
	copy(result, data[32:32+length])
	return result, 32 + abi.Pad32(length), nil
}

// DecodeBytes32 decodes bytes32 from ABI bytes
func DecodeBytes32(data []byte) ([32]byte, int, error) {
	var result [32]byte
	copy(result[:], data[:32])
	return result, 32, nil
}

// DecodeBytes32Array2 decodes bytes32[2] from ABI bytes
func DecodeBytes32Array2(data []byte) ([2][32]byte, int, error) {
	// Decode fixed-size array with static elements
	var (
		result [2][32]byte
		err    error
	)
	if len(data) < 64 {
		return result, 0, io.ErrUnexpectedEOF
	}
	// Element 0
	result[0], _, err = DecodeBytes32(data[0:])
	if err != nil {
		return result, 0, err
	}
	// Element 1
	result[1], _, err = DecodeBytes32(data[32:])
	if err != nil {
		return result, 0, err
	}
	return result, 64, nil
}

// DecodeInt16 decodes int16 from ABI bytes
func DecodeInt16(data []byte) (int16, int, error) {
	var result int16
	result = int16(binary.BigEndian.Uint16(data[30:32]))
	if data[0]&0x80 != 0 { // Check sign bit
		result = result | ^0x7fff // Sign extend
	}
	return result, 32, nil
}

// DecodeInt32 decodes int32 from ABI bytes
func DecodeInt32(data []byte) (int32, int, error) {
	var result int32
	result = int32(binary.BigEndian.Uint32(data[28:32]))
	if data[0]&0x80 != 0 { // Check sign bit
		result = result | ^0x7fffffff // Sign extend
	}
	return result, 32, nil
}

// DecodeInt64 decodes int64 from ABI bytes
func DecodeInt64(data []byte) (int64, int, error) {
	var result int64
	result = int64(binary.BigEndian.Uint64(data[24:32]))
	if data[0]&0x80 != 0 { // Check sign bit
		result = result | ^0x7fffffffffffffff // Sign extend
	}
	return result, 32, nil
}

// DecodeInt8 decodes int8 from ABI bytes
func DecodeInt8(data []byte) (int8, int, error) {
	var result int8
	result = int8(data[31])
	if data[0]&0x80 != 0 { // Check sign bit
		result = result | ^0x7f // Sign extend
	}
	return result, 32, nil
}

// DecodeItemSlice decodes (uint32,bytes,bool)[] from ABI bytes
func DecodeItemSlice(data []byte) ([]Item, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 32*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with dynamic types
	result := make([]Item, length)
	dynamicOffset := length * 32
	for i := 0; i < length; i++ {
		offset += 32
		tmp := int(binary.BigEndian.Uint64(data[offset-8 : offset]))
		if dynamicOffset != tmp {
			return nil, 0, fmt.Errorf("invalid offset for slice element %d: expected %d, got %d", i, dynamicOffset, tmp)
		}
		n, err = result[i].Decode(data[dynamicOffset:])
		if err != nil {
			return nil, 0, err
		}
		dynamicOffset += n
	}
	return result, dynamicOffset + 32, nil
}

// DecodeString decodes string from ABI bytes
func DecodeString(data []byte) (string, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32+abi.Pad32(length) {
		return "", 0, io.ErrUnexpectedEOF
	}

	// Decode data
	result := string(data[32 : 32+length])
	return result, 32 + abi.Pad32(length), nil
}

// DecodeStringSlice decodes string[] from ABI bytes
func DecodeStringSlice(data []byte) ([]string, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 32*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with dynamic types
	result := make([]string, length)
	dynamicOffset := length * 32
	for i := 0; i < length; i++ {
		offset += 32
		tmp := int(binary.BigEndian.Uint64(data[offset-8 : offset]))
		if dynamicOffset != tmp {
			return nil, 0, fmt.Errorf("invalid offset for slice element %d: expected %d, got %d", i, dynamicOffset, tmp)
		}
		result[i], n, err = DecodeString(data[dynamicOffset:])
		if err != nil {
			return nil, 0, err
		}
		dynamicOffset += n
	}
	return result, dynamicOffset + 32, nil
}

// DecodeStringSliceSlice decodes string[][] from ABI bytes
func DecodeStringSliceSlice(data []byte) ([][]string, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 32*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with dynamic types
	result := make([][]string, length)
	dynamicOffset := length * 32
	for i := 0; i < length; i++ {
		offset += 32
		tmp := int(binary.BigEndian.Uint64(data[offset-8 : offset]))
		if dynamicOffset != tmp {
			return nil, 0, fmt.Errorf("invalid offset for slice element %d: expected %d, got %d", i, dynamicOffset, tmp)
		}
		result[i], n, err = DecodeStringSlice(data[dynamicOffset:])
		if err != nil {
			return nil, 0, err
		}
		dynamicOffset += n
	}
	return result, dynamicOffset + 32, nil
}

// DecodeUint16 decodes uint16 from ABI bytes
func DecodeUint16(data []byte) (uint16, int, error) {
	result := binary.BigEndian.Uint16(data[30:32])
	return result, 32, nil
}

// DecodeUint256 decodes uint256 from ABI bytes
func DecodeUint256(data []byte) (*big.Int, int, error) {
	result, err := abi.DecodeBigInt(data[:32], false)
	if err != nil {
		return nil, 0, err
	}
	return result, 32, nil
}

// DecodeUint256Array3 decodes uint256[3] from ABI bytes
func DecodeUint256Array3(data []byte) ([3]*big.Int, int, error) {
	// Decode fixed-size array with static elements
	var (
		result [3]*big.Int
		err    error
	)
	if len(data) < 96 {
		return result, 0, io.ErrUnexpectedEOF
	}
	// Element 0
	result[0], _, err = DecodeUint256(data[0:])
	if err != nil {
		return result, 0, err
	}
	// Element 1
	result[1], _, err = DecodeUint256(data[32:])
	if err != nil {
		return result, 0, err
	}
	// Element 2
	result[2], _, err = DecodeUint256(data[64:])
	if err != nil {
		return result, 0, err
	}
	return result, 96, nil
}

// DecodeUint256Slice decodes uint256[] from ABI bytes
func DecodeUint256Slice(data []byte) ([]*big.Int, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 32*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with static types
	result := make([]*big.Int, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeUint256(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeUint256SliceSlice decodes uint256[][] from ABI bytes
func DecodeUint256SliceSlice(data []byte) ([][]*big.Int, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 32*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with dynamic types
	result := make([][]*big.Int, length)
	dynamicOffset := length * 32
	for i := 0; i < length; i++ {
		offset += 32
		tmp := int(binary.BigEndian.Uint64(data[offset-8 : offset]))
		if dynamicOffset != tmp {
			return nil, 0, fmt.Errorf("invalid offset for slice element %d: expected %d, got %d", i, dynamicOffset, tmp)
		}
		result[i], n, err = DecodeUint256Slice(data[dynamicOffset:])
		if err != nil {
			return nil, 0, err
		}
		dynamicOffset += n
	}
	return result, dynamicOffset + 32, nil
}

// DecodeUint32 decodes uint32 from ABI bytes
func DecodeUint32(data []byte) (uint32, int, error) {
	result := binary.BigEndian.Uint32(data[28:32])
	return result, 32, nil
}

// DecodeUint64 decodes uint64 from ABI bytes
func DecodeUint64(data []byte) (uint64, int, error) {
	result := binary.BigEndian.Uint64(data[24:32])
	return result, 32, nil
}

// DecodeUint8 decodes uint8 from ABI bytes
func DecodeUint8(data []byte) (uint8, int, error) {
	result := uint8(data[31])
	return result, 32, nil
}

// DecodeUser2Slice decodes (uint256,(string,string[],(uint256,string[])))[] from ABI bytes
func DecodeUser2Slice(data []byte) ([]User2, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 32*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with dynamic types
	result := make([]User2, length)
	dynamicOffset := length * 32
	for i := 0; i < length; i++ {
		offset += 32
		tmp := int(binary.BigEndian.Uint64(data[offset-8 : offset]))
		if dynamicOffset != tmp {
			return nil, 0, fmt.Errorf("invalid offset for slice element %d: expected %d, got %d", i, dynamicOffset, tmp)
		}
		n, err = result[i].Decode(data[dynamicOffset:])
		if err != nil {
			return nil, 0, err
		}
		dynamicOffset += n
	}
	return result, dynamicOffset + 32, nil
}

// DecodeUserSlice decodes (address,string,uint256)[] from ABI bytes
func DecodeUserSlice(data []byte) ([]User, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 32*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with dynamic types
	result := make([]User, length)
	dynamicOffset := length * 32
	for i := 0; i < length; i++ {
		offset += 32
		tmp := int(binary.BigEndian.Uint64(data[offset-8 : offset]))
		if dynamicOffset != tmp {
			return nil, 0, fmt.Errorf("invalid offset for slice element %d: expected %d, got %d", i, dynamicOffset, tmp)
		}
		n, err = result[i].Decode(data[dynamicOffset:])
		if err != nil {
			return nil, 0, err
		}
		dynamicOffset += n
	}
	return result, dynamicOffset + 32, nil
}

const TestComplexDynamicTuplesCallStaticSize = 32

// TestComplexDynamicTuplesCall represents an ABI tuple
type TestComplexDynamicTuplesCall struct {
	Users []User2
}

// EncodedSize returns the total encoded size of TestComplexDynamicTuplesCall
func (t TestComplexDynamicTuplesCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += SizeUser2Slice(t.Users)

	return TestComplexDynamicTuplesCallStaticSize + dynamicSize
}

// EncodeTo encodes TestComplexDynamicTuplesCall to ABI bytes in the provided buffer
func (value TestComplexDynamicTuplesCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestComplexDynamicTuplesCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Users: (uint256,(string,string[],(uint256,string[])))[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeUser2Slice(value.Users, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes TestComplexDynamicTuplesCall to ABI bytes
func (value TestComplexDynamicTuplesCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestComplexDynamicTuplesCall from ABI bytes in the provided buffer
func (t *TestComplexDynamicTuplesCall) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field Users
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Users")
		}
		t.Users, n, err = DecodeUser2Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// EncodeWithSelector encodes testComplexDynamicTuples arguments to ABI bytes including function selector
func (t TestComplexDynamicTuplesCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TestComplexDynamicTuplesSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const TestComplexDynamicTuplesReturnStaticSize = 32

// TestComplexDynamicTuplesReturn represents an ABI tuple
type TestComplexDynamicTuplesReturn struct {
	Field1 bool
}

// EncodedSize returns the total encoded size of TestComplexDynamicTuplesReturn
func (t TestComplexDynamicTuplesReturn) EncodedSize() int {
	dynamicSize := 0

	return TestComplexDynamicTuplesReturnStaticSize + dynamicSize
}

// EncodeTo encodes TestComplexDynamicTuplesReturn to ABI bytes in the provided buffer
func (value TestComplexDynamicTuplesReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestComplexDynamicTuplesReturnStaticSize // Start dynamic data after static section
	// Field Field1: bool
	if _, err := EncodeBool(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TestComplexDynamicTuplesReturn to ABI bytes
func (value TestComplexDynamicTuplesReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestComplexDynamicTuplesReturn from ABI bytes in the provided buffer
func (t *TestComplexDynamicTuplesReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bool
	t.Field1, _, err = DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

const TestDeeplyNestedCallStaticSize = 32

// TestDeeplyNestedCall represents an ABI tuple
type TestDeeplyNestedCall struct {
	Data Level1
}

// EncodedSize returns the total encoded size of TestDeeplyNestedCall
func (t TestDeeplyNestedCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.Data.EncodedSize()

	return TestDeeplyNestedCallStaticSize + dynamicSize
}

// EncodeTo encodes TestDeeplyNestedCall to ABI bytes in the provided buffer
func (value TestDeeplyNestedCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestDeeplyNestedCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Data: ((((uint256,string))))
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.Data.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes TestDeeplyNestedCall to ABI bytes
func (value TestDeeplyNestedCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestDeeplyNestedCall from ABI bytes in the provided buffer
func (t *TestDeeplyNestedCall) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field Data
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Data")
		}
		n, err = t.Data.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// EncodeWithSelector encodes testDeeplyNested arguments to ABI bytes including function selector
func (t TestDeeplyNestedCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TestDeeplyNestedSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const TestDeeplyNestedReturnStaticSize = 32

// TestDeeplyNestedReturn represents an ABI tuple
type TestDeeplyNestedReturn struct {
	Field1 bool
}

// EncodedSize returns the total encoded size of TestDeeplyNestedReturn
func (t TestDeeplyNestedReturn) EncodedSize() int {
	dynamicSize := 0

	return TestDeeplyNestedReturnStaticSize + dynamicSize
}

// EncodeTo encodes TestDeeplyNestedReturn to ABI bytes in the provided buffer
func (value TestDeeplyNestedReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestDeeplyNestedReturnStaticSize // Start dynamic data after static section
	// Field Field1: bool
	if _, err := EncodeBool(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TestDeeplyNestedReturn to ABI bytes
func (value TestDeeplyNestedReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestDeeplyNestedReturn from ABI bytes in the provided buffer
func (t *TestDeeplyNestedReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bool
	t.Field1, _, err = DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

const TestExternalTupleCallStaticSize = 32

// TestExternalTupleCall represents an ABI tuple
type TestExternalTupleCall struct {
	User User
}

// EncodedSize returns the total encoded size of TestExternalTupleCall
func (t TestExternalTupleCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.User.EncodedSize()

	return TestExternalTupleCallStaticSize + dynamicSize
}

// EncodeTo encodes TestExternalTupleCall to ABI bytes in the provided buffer
func (value TestExternalTupleCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestExternalTupleCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field User: (address,string,uint256)
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.User.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes TestExternalTupleCall to ABI bytes
func (value TestExternalTupleCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestExternalTupleCall from ABI bytes in the provided buffer
func (t *TestExternalTupleCall) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field User
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field User")
		}
		n, err = t.User.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// EncodeWithSelector encodes testExternalTuple arguments to ABI bytes including function selector
func (t TestExternalTupleCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TestExternalTupleSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const TestExternalTupleReturnStaticSize = 32

// TestExternalTupleReturn represents an ABI tuple
type TestExternalTupleReturn struct {
	Field1 bool
}

// EncodedSize returns the total encoded size of TestExternalTupleReturn
func (t TestExternalTupleReturn) EncodedSize() int {
	dynamicSize := 0

	return TestExternalTupleReturnStaticSize + dynamicSize
}

// EncodeTo encodes TestExternalTupleReturn to ABI bytes in the provided buffer
func (value TestExternalTupleReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestExternalTupleReturnStaticSize // Start dynamic data after static section
	// Field Field1: bool
	if _, err := EncodeBool(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TestExternalTupleReturn to ABI bytes
func (value TestExternalTupleReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestExternalTupleReturn from ABI bytes in the provided buffer
func (t *TestExternalTupleReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bool
	t.Field1, _, err = DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

const TestFixedArraysCallStaticSize = 320

// TestFixedArraysCall represents an ABI tuple
type TestFixedArraysCall struct {
	Addresses [5]common.Address
	Uints     [3]*big.Int
	Bytes32s  [2][32]byte
}

// EncodedSize returns the total encoded size of TestFixedArraysCall
func (t TestFixedArraysCall) EncodedSize() int {
	dynamicSize := 0

	return TestFixedArraysCallStaticSize + dynamicSize
}

// EncodeTo encodes TestFixedArraysCall to ABI bytes in the provided buffer
func (value TestFixedArraysCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestFixedArraysCallStaticSize // Start dynamic data after static section
	// Field Addresses: address[5]
	if _, err := EncodeAddressArray5(value.Addresses, buf[0:]); err != nil {
		return 0, err
	}

	// Field Uints: uint256[3]
	if _, err := EncodeUint256Array3(value.Uints, buf[160:]); err != nil {
		return 0, err
	}

	// Field Bytes32s: bytes32[2]
	if _, err := EncodeBytes32Array2(value.Bytes32s, buf[256:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TestFixedArraysCall to ABI bytes
func (value TestFixedArraysCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestFixedArraysCall from ABI bytes in the provided buffer
func (t *TestFixedArraysCall) Decode(data []byte) (int, error) {
	if len(data) < 320 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 320
	// Decode static field Addresses: address[5]
	t.Addresses, _, err = DecodeAddressArray5(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode static field Uints: uint256[3]
	t.Uints, _, err = DecodeUint256Array3(data[160:])
	if err != nil {
		return 0, err
	}
	// Decode static field Bytes32s: bytes32[2]
	t.Bytes32s, _, err = DecodeBytes32Array2(data[256:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// EncodeWithSelector encodes testFixedArrays arguments to ABI bytes including function selector
func (t TestFixedArraysCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TestFixedArraysSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const TestFixedArraysReturnStaticSize = 32

// TestFixedArraysReturn represents an ABI tuple
type TestFixedArraysReturn struct {
	Field1 bool
}

// EncodedSize returns the total encoded size of TestFixedArraysReturn
func (t TestFixedArraysReturn) EncodedSize() int {
	dynamicSize := 0

	return TestFixedArraysReturnStaticSize + dynamicSize
}

// EncodeTo encodes TestFixedArraysReturn to ABI bytes in the provided buffer
func (value TestFixedArraysReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestFixedArraysReturnStaticSize // Start dynamic data after static section
	// Field Field1: bool
	if _, err := EncodeBool(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TestFixedArraysReturn to ABI bytes
func (value TestFixedArraysReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestFixedArraysReturn from ABI bytes in the provided buffer
func (t *TestFixedArraysReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bool
	t.Field1, _, err = DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

const TestMixedTypesCallStaticSize = 160

// TestMixedTypesCall represents an ABI tuple
type TestMixedTypesCall struct {
	FixedData   [32]byte
	DynamicData []byte
	Flag        bool
	Count       uint8
	Items       []Item
}

// EncodedSize returns the total encoded size of TestMixedTypesCall
func (t TestMixedTypesCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += SizeBytes(t.DynamicData)
	dynamicSize += SizeItemSlice(t.Items)

	return TestMixedTypesCallStaticSize + dynamicSize
}

// EncodeTo encodes TestMixedTypesCall to ABI bytes in the provided buffer
func (value TestMixedTypesCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestMixedTypesCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field FixedData: bytes32
	if _, err := EncodeBytes32(value.FixedData, buf[0:]); err != nil {
		return 0, err
	}

	// Field DynamicData: bytes
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeBytes(value.DynamicData, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Flag: bool
	if _, err := EncodeBool(value.Flag, buf[64:]); err != nil {
		return 0, err
	}

	// Field Count: uint8
	if _, err := EncodeUint8(value.Count, buf[96:]); err != nil {
		return 0, err
	}

	// Field Items: (uint32,bytes,bool)[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[128+24:128+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeItemSlice(value.Items, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes TestMixedTypesCall to ABI bytes
func (value TestMixedTypesCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestMixedTypesCall from ABI bytes in the provided buffer
func (t *TestMixedTypesCall) Decode(data []byte) (int, error) {
	if len(data) < 160 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 160
	// Decode static field FixedData: bytes32
	t.FixedData, _, err = DecodeBytes32(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field DynamicData
	{
		offset := int(binary.BigEndian.Uint64(data[32+24 : 32+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field DynamicData")
		}
		t.DynamicData, n, err = DecodeBytes(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode static field Flag: bool
	t.Flag, _, err = DecodeBool(data[64:])
	if err != nil {
		return 0, err
	}
	// Decode static field Count: uint8
	t.Count, _, err = DecodeUint8(data[96:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Items
	{
		offset := int(binary.BigEndian.Uint64(data[128+24 : 128+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Items")
		}
		t.Items, n, err = DecodeItemSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// EncodeWithSelector encodes testMixedTypes arguments to ABI bytes including function selector
func (t TestMixedTypesCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TestMixedTypesSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const TestMixedTypesReturnStaticSize = 32

// TestMixedTypesReturn represents an ABI tuple
type TestMixedTypesReturn struct {
	Field1 bool
}

// EncodedSize returns the total encoded size of TestMixedTypesReturn
func (t TestMixedTypesReturn) EncodedSize() int {
	dynamicSize := 0

	return TestMixedTypesReturnStaticSize + dynamicSize
}

// EncodeTo encodes TestMixedTypesReturn to ABI bytes in the provided buffer
func (value TestMixedTypesReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestMixedTypesReturnStaticSize // Start dynamic data after static section
	// Field Field1: bool
	if _, err := EncodeBool(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TestMixedTypesReturn to ABI bytes
func (value TestMixedTypesReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestMixedTypesReturn from ABI bytes in the provided buffer
func (t *TestMixedTypesReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bool
	t.Field1, _, err = DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

const TestNestedDynamicArraysCallStaticSize = 96

// TestNestedDynamicArraysCall represents an ABI tuple
type TestNestedDynamicArraysCall struct {
	Matrix        [][]*big.Int
	AddressMatrix [][3][]common.Address
	DymMatrix     [][]string
}

// EncodedSize returns the total encoded size of TestNestedDynamicArraysCall
func (t TestNestedDynamicArraysCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += SizeUint256SliceSlice(t.Matrix)
	dynamicSize += SizeAddressSliceArray3Slice(t.AddressMatrix)
	dynamicSize += SizeStringSliceSlice(t.DymMatrix)

	return TestNestedDynamicArraysCallStaticSize + dynamicSize
}

// EncodeTo encodes TestNestedDynamicArraysCall to ABI bytes in the provided buffer
func (value TestNestedDynamicArraysCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestNestedDynamicArraysCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Matrix: uint256[][]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeUint256SliceSlice(value.Matrix, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field AddressMatrix: address[][3][]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeAddressSliceArray3Slice(value.AddressMatrix, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field DymMatrix: string[][]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[64+24:64+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeStringSliceSlice(value.DymMatrix, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes TestNestedDynamicArraysCall to ABI bytes
func (value TestNestedDynamicArraysCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestNestedDynamicArraysCall from ABI bytes in the provided buffer
func (t *TestNestedDynamicArraysCall) Decode(data []byte) (int, error) {
	if len(data) < 96 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 96
	// Decode dynamic field Matrix
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Matrix")
		}
		t.Matrix, n, err = DecodeUint256SliceSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field AddressMatrix
	{
		offset := int(binary.BigEndian.Uint64(data[32+24 : 32+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field AddressMatrix")
		}
		t.AddressMatrix, n, err = DecodeAddressSliceArray3Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field DymMatrix
	{
		offset := int(binary.BigEndian.Uint64(data[64+24 : 64+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field DymMatrix")
		}
		t.DymMatrix, n, err = DecodeStringSliceSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// EncodeWithSelector encodes testNestedDynamicArrays arguments to ABI bytes including function selector
func (t TestNestedDynamicArraysCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TestNestedDynamicArraysSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const TestNestedDynamicArraysReturnStaticSize = 32

// TestNestedDynamicArraysReturn represents an ABI tuple
type TestNestedDynamicArraysReturn struct {
	Field1 bool
}

// EncodedSize returns the total encoded size of TestNestedDynamicArraysReturn
func (t TestNestedDynamicArraysReturn) EncodedSize() int {
	dynamicSize := 0

	return TestNestedDynamicArraysReturnStaticSize + dynamicSize
}

// EncodeTo encodes TestNestedDynamicArraysReturn to ABI bytes in the provided buffer
func (value TestNestedDynamicArraysReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestNestedDynamicArraysReturnStaticSize // Start dynamic data after static section
	// Field Field1: bool
	if _, err := EncodeBool(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TestNestedDynamicArraysReturn to ABI bytes
func (value TestNestedDynamicArraysReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestNestedDynamicArraysReturn from ABI bytes in the provided buffer
func (t *TestNestedDynamicArraysReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bool
	t.Field1, _, err = DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

const TestNestedStructCallStaticSize = 32

// TestNestedStructCall represents an ABI tuple
type TestNestedStructCall struct {
	Group Group
}

// EncodedSize returns the total encoded size of TestNestedStructCall
func (t TestNestedStructCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.Group.EncodedSize()

	return TestNestedStructCallStaticSize + dynamicSize
}

// EncodeTo encodes TestNestedStructCall to ABI bytes in the provided buffer
func (value TestNestedStructCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestNestedStructCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Group: ((address,string,uint256)[])
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.Group.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes TestNestedStructCall to ABI bytes
func (value TestNestedStructCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestNestedStructCall from ABI bytes in the provided buffer
func (t *TestNestedStructCall) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field Group
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Group")
		}
		n, err = t.Group.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// EncodeWithSelector encodes testNestedStruct arguments to ABI bytes including function selector
func (t TestNestedStructCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TestNestedStructSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const TestNestedStructReturnStaticSize = 32

// TestNestedStructReturn represents an ABI tuple
type TestNestedStructReturn struct {
	Field1 bool
}

// EncodedSize returns the total encoded size of TestNestedStructReturn
func (t TestNestedStructReturn) EncodedSize() int {
	dynamicSize := 0

	return TestNestedStructReturnStaticSize + dynamicSize
}

// EncodeTo encodes TestNestedStructReturn to ABI bytes in the provided buffer
func (value TestNestedStructReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestNestedStructReturnStaticSize // Start dynamic data after static section
	// Field Field1: bool
	if _, err := EncodeBool(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TestNestedStructReturn to ABI bytes
func (value TestNestedStructReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestNestedStructReturn from ABI bytes in the provided buffer
func (t *TestNestedStructReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bool
	t.Field1, _, err = DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

const TestSmallIntegersCallStaticSize = 256

// TestSmallIntegersCall represents an ABI tuple
type TestSmallIntegersCall struct {
	U8  uint8
	U16 uint16
	U32 uint32
	U64 uint64
	I8  int8
	I16 int16
	I32 int32
	I64 int64
}

// EncodedSize returns the total encoded size of TestSmallIntegersCall
func (t TestSmallIntegersCall) EncodedSize() int {
	dynamicSize := 0

	return TestSmallIntegersCallStaticSize + dynamicSize
}

// EncodeTo encodes TestSmallIntegersCall to ABI bytes in the provided buffer
func (value TestSmallIntegersCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestSmallIntegersCallStaticSize // Start dynamic data after static section
	// Field U8: uint8
	if _, err := EncodeUint8(value.U8, buf[0:]); err != nil {
		return 0, err
	}

	// Field U16: uint16
	if _, err := EncodeUint16(value.U16, buf[32:]); err != nil {
		return 0, err
	}

	// Field U32: uint32
	if _, err := EncodeUint32(value.U32, buf[64:]); err != nil {
		return 0, err
	}

	// Field U64: uint64
	if _, err := EncodeUint64(value.U64, buf[96:]); err != nil {
		return 0, err
	}

	// Field I8: int8
	if _, err := EncodeInt8(value.I8, buf[128:]); err != nil {
		return 0, err
	}

	// Field I16: int16
	if _, err := EncodeInt16(value.I16, buf[160:]); err != nil {
		return 0, err
	}

	// Field I32: int32
	if _, err := EncodeInt32(value.I32, buf[192:]); err != nil {
		return 0, err
	}

	// Field I64: int64
	if _, err := EncodeInt64(value.I64, buf[224:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TestSmallIntegersCall to ABI bytes
func (value TestSmallIntegersCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestSmallIntegersCall from ABI bytes in the provided buffer
func (t *TestSmallIntegersCall) Decode(data []byte) (int, error) {
	if len(data) < 256 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 256
	// Decode static field U8: uint8
	t.U8, _, err = DecodeUint8(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode static field U16: uint16
	t.U16, _, err = DecodeUint16(data[32:])
	if err != nil {
		return 0, err
	}
	// Decode static field U32: uint32
	t.U32, _, err = DecodeUint32(data[64:])
	if err != nil {
		return 0, err
	}
	// Decode static field U64: uint64
	t.U64, _, err = DecodeUint64(data[96:])
	if err != nil {
		return 0, err
	}
	// Decode static field I8: int8
	t.I8, _, err = DecodeInt8(data[128:])
	if err != nil {
		return 0, err
	}
	// Decode static field I16: int16
	t.I16, _, err = DecodeInt16(data[160:])
	if err != nil {
		return 0, err
	}
	// Decode static field I32: int32
	t.I32, _, err = DecodeInt32(data[192:])
	if err != nil {
		return 0, err
	}
	// Decode static field I64: int64
	t.I64, _, err = DecodeInt64(data[224:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// EncodeWithSelector encodes testSmallIntegers arguments to ABI bytes including function selector
func (t TestSmallIntegersCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TestSmallIntegersSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const TestSmallIntegersReturnStaticSize = 32

// TestSmallIntegersReturn represents an ABI tuple
type TestSmallIntegersReturn struct {
	Field1 bool
}

// EncodedSize returns the total encoded size of TestSmallIntegersReturn
func (t TestSmallIntegersReturn) EncodedSize() int {
	dynamicSize := 0

	return TestSmallIntegersReturnStaticSize + dynamicSize
}

// EncodeTo encodes TestSmallIntegersReturn to ABI bytes in the provided buffer
func (value TestSmallIntegersReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestSmallIntegersReturnStaticSize // Start dynamic data after static section
	// Field Field1: bool
	if _, err := EncodeBool(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TestSmallIntegersReturn to ABI bytes
func (value TestSmallIntegersReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestSmallIntegersReturn from ABI bytes in the provided buffer
func (t *TestSmallIntegersReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bool
	t.Field1, _, err = DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// Event signatures
var (
	// Complex(string,uint256[],address)
	ComplexEventTopic = common.Hash{0x56, 0x22, 0xe4, 0xd3, 0x12, 0xf8, 0xdd, 0x97, 0xbb, 0x32, 0x6c, 0x82, 0x99, 0x40, 0xc0, 0x6e, 0x5f, 0x3f, 0xf7, 0x2b, 0x31, 0x1a, 0x4d, 0xee, 0x95, 0x97, 0x35, 0x15, 0x88, 0x7d, 0x0d, 0xc7}
	// IndexOnly(address)
	IndexOnlyEventTopic = common.Hash{0x97, 0x3c, 0xfd, 0x69, 0xe6, 0x55, 0xa7, 0xff, 0xc7, 0x50, 0xd3, 0x74, 0x5d, 0x6c, 0xd2, 0xb0, 0xef, 0x78, 0xe9, 0x8c, 0x28, 0x84, 0x0b, 0xa3, 0xc7, 0x16, 0x3a, 0x5a, 0xe6, 0x37, 0x1f, 0x27}
	// Transfer(address,address,uint256)
	TransferEventTopic = common.Hash{0xdd, 0xf2, 0x52, 0xad, 0x1b, 0xe2, 0xc8, 0x9b, 0x69, 0xc2, 0xb0, 0x68, 0xfc, 0x37, 0x8d, 0xaa, 0x95, 0x2b, 0xa7, 0xf1, 0x63, 0xc4, 0xa1, 0x16, 0x28, 0xf5, 0x5a, 0x4d, 0xf5, 0x23, 0xb3, 0xef}
	// UserCreated((address,string,uint256),address)
	UserCreatedEventTopic = common.Hash{0x34, 0xd6, 0x8f, 0x2d, 0xec, 0x91, 0xef, 0x13, 0x0d, 0xe9, 0x21, 0x4e, 0x8e, 0xa8, 0x6e, 0x02, 0x29, 0xf7, 0x22, 0xee, 0x89, 0x41, 0xc9, 0x9f, 0x75, 0xbf, 0xa5, 0x38, 0x17, 0xd9, 0x97, 0x82}
)

// ComplexEvent represents the Complex event
type ComplexEvent struct {
	ComplexEventIndexed
	ComplexEventData
}

// NewComplexEvent constructs a new Complex event
func NewComplexEvent(
	message string,
	numbers []*big.Int,
	sender common.Address,
) ComplexEvent {
	return ComplexEvent{
		ComplexEventIndexed: ComplexEventIndexed{
			Sender: sender,
		},
		ComplexEventData: ComplexEventData{
			Message: message,
			Numbers: numbers,
		},
	}
}

// Complex represents an ABI event
type ComplexEventIndexed struct {
	Sender common.Address
}

// EncodeTopics encodes indexed fields of Complex event to topics
func (e ComplexEventIndexed) EncodeTopics() ([]common.Hash, error) {
	topics := make([]common.Hash, 0, 2)
	topics = append(topics, ComplexEventTopic)
	{
		// Sender
		var hash common.Hash
		if _, err := EncodeAddress(e.Sender, hash[:]); err != nil {
			return nil, err
		}
		topics = append(topics, hash)
	}
	return topics, nil
}

// DecodeTopics decodes indexed fields of Complex event from topics, ignore hash topics
func (e *ComplexEventIndexed) DecodeTopics(topics []common.Hash) error {
	if len(topics) != 2 {
		return fmt.Errorf("invalid number of topics for Complex event: expected 2, got %d", len(topics))
	}
	if topics[0] != ComplexEventTopic {
		return fmt.Errorf("invalid event topic for Complex event")
	}
	var err error
	e.Sender, _, err = DecodeAddress(topics[1][:])
	if err != nil {
		return err
	}
	return nil
}

const ComplexEventDataStaticSize = 64

// ComplexEventData represents an ABI tuple
type ComplexEventData struct {
	Message string
	Numbers []*big.Int
}

// EncodedSize returns the total encoded size of ComplexEventData
func (t ComplexEventData) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += SizeString(t.Message)
	dynamicSize += SizeUint256Slice(t.Numbers)

	return ComplexEventDataStaticSize + dynamicSize
}

// EncodeTo encodes ComplexEventData to ABI bytes in the provided buffer
func (value ComplexEventData) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := ComplexEventDataStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Message: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeString(value.Message, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Numbers: uint256[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeUint256Slice(value.Numbers, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes ComplexEventData to ABI bytes
func (value ComplexEventData) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes ComplexEventData from ABI bytes in the provided buffer
func (t *ComplexEventData) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 64
	// Decode dynamic field Message
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Message")
		}
		t.Message, n, err = DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Numbers
	{
		offset := int(binary.BigEndian.Uint64(data[32+24 : 32+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Numbers")
		}
		t.Numbers, n, err = DecodeUint256Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// IndexOnlyEvent represents the IndexOnly event
type IndexOnlyEvent struct {
	IndexOnlyEventIndexed
	IndexOnlyEventData
}

// NewIndexOnlyEvent constructs a new IndexOnly event
func NewIndexOnlyEvent(
	sender common.Address,
) IndexOnlyEvent {
	return IndexOnlyEvent{
		IndexOnlyEventIndexed: IndexOnlyEventIndexed{
			Sender: sender,
		},
		IndexOnlyEventData: IndexOnlyEventData{},
	}
}

// IndexOnly represents an ABI event
type IndexOnlyEventIndexed struct {
	Sender common.Address
}

// EncodeTopics encodes indexed fields of IndexOnly event to topics
func (e IndexOnlyEventIndexed) EncodeTopics() ([]common.Hash, error) {
	topics := make([]common.Hash, 0, 2)
	topics = append(topics, IndexOnlyEventTopic)
	{
		// Sender
		var hash common.Hash
		if _, err := EncodeAddress(e.Sender, hash[:]); err != nil {
			return nil, err
		}
		topics = append(topics, hash)
	}
	return topics, nil
}

// DecodeTopics decodes indexed fields of IndexOnly event from topics, ignore hash topics
func (e *IndexOnlyEventIndexed) DecodeTopics(topics []common.Hash) error {
	if len(topics) != 2 {
		return fmt.Errorf("invalid number of topics for IndexOnly event: expected 2, got %d", len(topics))
	}
	if topics[0] != IndexOnlyEventTopic {
		return fmt.Errorf("invalid event topic for IndexOnly event")
	}
	var err error
	e.Sender, _, err = DecodeAddress(topics[1][:])
	if err != nil {
		return err
	}
	return nil
}

type IndexOnlyEventData abi.EmptyTuple

// TransferEvent represents the Transfer event
type TransferEvent struct {
	TransferEventIndexed
	TransferEventData
}

// NewTransferEvent constructs a new Transfer event
func NewTransferEvent(
	from common.Address,
	to common.Address,
	value *big.Int,
) TransferEvent {
	return TransferEvent{
		TransferEventIndexed: TransferEventIndexed{
			From: from,
			To:   to,
		},
		TransferEventData: TransferEventData{
			Value: value,
		},
	}
}

// Transfer represents an ABI event
type TransferEventIndexed struct {
	From common.Address
	To   common.Address
}

// EncodeTopics encodes indexed fields of Transfer event to topics
func (e TransferEventIndexed) EncodeTopics() ([]common.Hash, error) {
	topics := make([]common.Hash, 0, 3)
	topics = append(topics, TransferEventTopic)
	{
		// From
		var hash common.Hash
		if _, err := EncodeAddress(e.From, hash[:]); err != nil {
			return nil, err
		}
		topics = append(topics, hash)
	}
	{
		// To
		var hash common.Hash
		if _, err := EncodeAddress(e.To, hash[:]); err != nil {
			return nil, err
		}
		topics = append(topics, hash)
	}
	return topics, nil
}

// DecodeTopics decodes indexed fields of Transfer event from topics, ignore hash topics
func (e *TransferEventIndexed) DecodeTopics(topics []common.Hash) error {
	if len(topics) != 3 {
		return fmt.Errorf("invalid number of topics for Transfer event: expected 3, got %d", len(topics))
	}
	if topics[0] != TransferEventTopic {
		return fmt.Errorf("invalid event topic for Transfer event")
	}
	var err error
	e.From, _, err = DecodeAddress(topics[1][:])
	if err != nil {
		return err
	}
	e.To, _, err = DecodeAddress(topics[2][:])
	if err != nil {
		return err
	}
	return nil
}

const TransferEventDataStaticSize = 32

// TransferEventData represents an ABI tuple
type TransferEventData struct {
	Value *big.Int
}

// EncodedSize returns the total encoded size of TransferEventData
func (t TransferEventData) EncodedSize() int {
	dynamicSize := 0

	return TransferEventDataStaticSize + dynamicSize
}

// EncodeTo encodes TransferEventData to ABI bytes in the provided buffer
func (value TransferEventData) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TransferEventDataStaticSize // Start dynamic data after static section
	// Field Value: uint256
	if _, err := EncodeUint256(value.Value, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TransferEventData to ABI bytes
func (value TransferEventData) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TransferEventData from ABI bytes in the provided buffer
func (t *TransferEventData) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Value: uint256
	t.Value, _, err = DecodeUint256(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// UserCreatedEvent represents the UserCreated event
type UserCreatedEvent struct {
	UserCreatedEventIndexed
	UserCreatedEventData
}

// NewUserCreatedEvent constructs a new UserCreated event
func NewUserCreatedEvent(
	user User,
	creator common.Address,
) UserCreatedEvent {
	return UserCreatedEvent{
		UserCreatedEventIndexed: UserCreatedEventIndexed{
			Creator: creator,
		},
		UserCreatedEventData: UserCreatedEventData{
			User: user,
		},
	}
}

// UserCreated represents an ABI event
type UserCreatedEventIndexed struct {
	Creator common.Address
}

// EncodeTopics encodes indexed fields of UserCreated event to topics
func (e UserCreatedEventIndexed) EncodeTopics() ([]common.Hash, error) {
	topics := make([]common.Hash, 0, 2)
	topics = append(topics, UserCreatedEventTopic)
	{
		// Creator
		var hash common.Hash
		if _, err := EncodeAddress(e.Creator, hash[:]); err != nil {
			return nil, err
		}
		topics = append(topics, hash)
	}
	return topics, nil
}

// DecodeTopics decodes indexed fields of UserCreated event from topics, ignore hash topics
func (e *UserCreatedEventIndexed) DecodeTopics(topics []common.Hash) error {
	if len(topics) != 2 {
		return fmt.Errorf("invalid number of topics for UserCreated event: expected 2, got %d", len(topics))
	}
	if topics[0] != UserCreatedEventTopic {
		return fmt.Errorf("invalid event topic for UserCreated event")
	}
	var err error
	e.Creator, _, err = DecodeAddress(topics[1][:])
	if err != nil {
		return err
	}
	return nil
}

const UserCreatedEventDataStaticSize = 32

// UserCreatedEventData represents an ABI tuple
type UserCreatedEventData struct {
	User User
}

// EncodedSize returns the total encoded size of UserCreatedEventData
func (t UserCreatedEventData) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.User.EncodedSize()

	return UserCreatedEventDataStaticSize + dynamicSize
}

// EncodeTo encodes UserCreatedEventData to ABI bytes in the provided buffer
func (value UserCreatedEventData) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := UserCreatedEventDataStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field User: (address,string,uint256)
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.User.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes UserCreatedEventData to ABI bytes
func (value UserCreatedEventData) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes UserCreatedEventData from ABI bytes in the provided buffer
func (t *UserCreatedEventData) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field User
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field User")
		}
		n, err = t.User.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}
