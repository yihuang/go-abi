// Code generated by go-abi. DO NOT EDIT.

package tests

import (
	"encoding/binary"
	"fmt"
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/yihuang/go-abi"
)

// Function selectors
var (
	// testComplexDynamicTuples((uint256,(string,string[],(uint256,string[])))[])
	TestComplexDynamicTuplesSelector = [4]byte{0xc0, 0x96, 0x4c, 0x93}
	// testDeeplyNested(((((uint256,string)))))
	TestDeeplyNestedSelector = [4]byte{0x21, 0x75, 0xe8, 0x54}
	// testFixedArrays(address[5],uint256[3],bytes32[2])
	TestFixedArraysSelector = [4]byte{0x23, 0xb8, 0x46, 0x5c}
	// testMixedTypes(bytes32,bytes,bool,uint8,(uint32,bytes,bool)[])
	TestMixedTypesSelector = [4]byte{0x85, 0x8a, 0xe6, 0x15}
	// testNestedDynamicArrays(uint256[][],address[][])
	TestNestedDynamicArraysSelector = [4]byte{0x3d, 0xb1, 0xee, 0x06}
	// testSmallIntegers(uint8,uint16,uint32,uint64,int8,int16,int32,int64)
	TestSmallIntegersSelector = [4]byte{0x29, 0x2b, 0xd2, 0x39}
)

// Big endian integer versions of function selectors
const (
	TestComplexDynamicTuplesID = 3231075475
	TestDeeplyNestedID         = 561375316
	TestFixedArraysID          = 599279196
	TestMixedTypesID           = 2240472597
	TestNestedDynamicArraysID  = 1035070982
	TestSmallIntegersID        = 690737721
)

const ItemStaticSize = 96

// Item represents an ABI tuple
type Item struct {
	Id     uint32
	Data   []byte
	Active bool
}

// EncodedSize returns the total encoded size of Item
func (t Item) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += 32 + abi.Pad32(len(t.Data)) // length + padded bytes data

	return ItemStaticSize + dynamicSize
}

// EncodeTo encodes Item to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t Item) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := ItemStaticSize // Start dynamic data after static section

	// Id (static)
	binary.BigEndian.PutUint32(buf[0+28:0+32], uint32(t.Id))

	// Data (offset)
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))

	// Data (dynamic)
	// length
	binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.Data)))
	dynamicOffset += 32

	// data
	copy(buf[dynamicOffset:], t.Data)
	dynamicOffset += abi.Pad32(len(t.Data))

	// Active (static)

	if t.Active {
		buf[64+31] = 1
	}

	return dynamicOffset, nil
}

// Encode encodes Item to ABI bytes
func (t Item) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Item from ABI bytes in the provided buffer
func (t *Item) Decode(data0 []byte) error {
	if len(data0) < ItemStaticSize {
		return fmt.Errorf("insufficient data for Item")
	}

	// t.Id (static)
	t.Id = uint32(binary.BigEndian.Uint32(data0[0+28 : 0+32]))
	// Data
	{
		offset := int(binary.BigEndian.Uint64(data0[32+24 : 32+32]))

		// t.Data (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// bytes data
		t.Data = data0[offset : offset+length]
	}
	// t.Active (static)
	t.Active = data0[64+31] == 1

	return nil
}

const Level1StaticSize = 32

// Level1 represents an ABI tuple
type Level1 struct {
	Level1 Level2
}

// EncodedSize returns the total encoded size of Level1
func (t Level1) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += t.Level1.EncodedSize() // dynamic tuple

	return Level1StaticSize + dynamicSize
}

// EncodeTo encodes Level1 to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t Level1) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := Level1StaticSize // Start dynamic data after static section

	// Level1 (offset)
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))

	// Level1 (dynamic)
	n, err := t.Level1.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes Level1 to ABI bytes
func (t Level1) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Level1 from ABI bytes in the provided buffer
func (t *Level1) Decode(data0 []byte) error {
	if len(data0) < Level1StaticSize {
		return fmt.Errorf("insufficient data for Level1")
	}

	// Level1
	{
		offset := int(binary.BigEndian.Uint64(data0[0+24 : 0+32]))

		// t.Level1 (dynamic)
		if offset >= len(data0) {
			return fmt.Errorf("insufficient data for dynamic data, t.Level1")
		}
		if err := t.Level1.Decode(data0[offset:]); err != nil {
			return err
		}
	}

	return nil
}

const Level2StaticSize = 32

// Level2 represents an ABI tuple
type Level2 struct {
	Level2 Level3
}

// EncodedSize returns the total encoded size of Level2
func (t Level2) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += t.Level2.EncodedSize() // dynamic tuple

	return Level2StaticSize + dynamicSize
}

// EncodeTo encodes Level2 to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t Level2) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := Level2StaticSize // Start dynamic data after static section

	// Level2 (offset)
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))

	// Level2 (dynamic)
	n, err := t.Level2.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes Level2 to ABI bytes
func (t Level2) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Level2 from ABI bytes in the provided buffer
func (t *Level2) Decode(data0 []byte) error {
	if len(data0) < Level2StaticSize {
		return fmt.Errorf("insufficient data for Level2")
	}

	// Level2
	{
		offset := int(binary.BigEndian.Uint64(data0[0+24 : 0+32]))

		// t.Level2 (dynamic)
		if offset >= len(data0) {
			return fmt.Errorf("insufficient data for dynamic data, t.Level2")
		}
		if err := t.Level2.Decode(data0[offset:]); err != nil {
			return err
		}
	}

	return nil
}

const Level3StaticSize = 32

// Level3 represents an ABI tuple
type Level3 struct {
	Level3 Level4
}

// EncodedSize returns the total encoded size of Level3
func (t Level3) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += t.Level3.EncodedSize() // dynamic tuple

	return Level3StaticSize + dynamicSize
}

// EncodeTo encodes Level3 to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t Level3) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := Level3StaticSize // Start dynamic data after static section

	// Level3 (offset)
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))

	// Level3 (dynamic)
	n, err := t.Level3.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes Level3 to ABI bytes
func (t Level3) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Level3 from ABI bytes in the provided buffer
func (t *Level3) Decode(data0 []byte) error {
	if len(data0) < Level3StaticSize {
		return fmt.Errorf("insufficient data for Level3")
	}

	// Level3
	{
		offset := int(binary.BigEndian.Uint64(data0[0+24 : 0+32]))

		// t.Level3 (dynamic)
		if offset >= len(data0) {
			return fmt.Errorf("insufficient data for dynamic data, t.Level3")
		}
		if err := t.Level3.Decode(data0[offset:]); err != nil {
			return err
		}
	}

	return nil
}

const Level4StaticSize = 64

// Level4 represents an ABI tuple
type Level4 struct {
	Value       *big.Int
	Description string
}

// EncodedSize returns the total encoded size of Level4
func (t Level4) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += 32 + abi.Pad32(len(t.Description)) // length + padded string data

	return Level4StaticSize + dynamicSize
}

// EncodeTo encodes Level4 to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t Level4) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := Level4StaticSize // Start dynamic data after static section

	// Value (static)

	if err := abi.EncodeBigInt(t.Value, buf[0:32], false); err != nil {
		return 0, err
	}

	// Description (offset)
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))

	// Description (dynamic)
	// length
	binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.Description)))
	dynamicOffset += 32

	// data
	copy(buf[dynamicOffset:], []byte(t.Description))
	dynamicOffset += abi.Pad32(len(t.Description))

	return dynamicOffset, nil
}

// Encode encodes Level4 to ABI bytes
func (t Level4) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Level4 from ABI bytes in the provided buffer
func (t *Level4) Decode(data0 []byte) error {
	if len(data0) < Level4StaticSize {
		return fmt.Errorf("insufficient data for Level4")
	}

	// t.Value (static)
	t.Value = new(big.Int).SetBytes(data0[0:32])
	// Description
	{
		offset := int(binary.BigEndian.Uint64(data0[32+24 : 32+32]))

		// t.Description (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// string data
		t.Description = string(data0[offset : offset+length])
	}

	return nil
}

const User2StaticSize = 64

// User2 represents an ABI tuple
type User2 struct {
	Id      *big.Int
	Profile UserProfile
}

// EncodedSize returns the total encoded size of User2
func (t User2) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += t.Profile.EncodedSize() // dynamic tuple

	return User2StaticSize + dynamicSize
}

// EncodeTo encodes User2 to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t User2) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := User2StaticSize // Start dynamic data after static section

	// Id (static)

	if err := abi.EncodeBigInt(t.Id, buf[0:32], false); err != nil {
		return 0, err
	}

	// Profile (offset)
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))

	// Profile (dynamic)
	n, err := t.Profile.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes User2 to ABI bytes
func (t User2) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes User2 from ABI bytes in the provided buffer
func (t *User2) Decode(data0 []byte) error {
	if len(data0) < User2StaticSize {
		return fmt.Errorf("insufficient data for User2")
	}

	// t.Id (static)
	t.Id = new(big.Int).SetBytes(data0[0:32])
	// Profile
	{
		offset := int(binary.BigEndian.Uint64(data0[32+24 : 32+32]))

		// t.Profile (dynamic)
		if offset >= len(data0) {
			return fmt.Errorf("insufficient data for dynamic data, t.Profile")
		}
		if err := t.Profile.Decode(data0[offset:]); err != nil {
			return err
		}
	}

	return nil
}

const UserMetadata2StaticSize = 64

// UserMetadata2 represents an ABI tuple
type UserMetadata2 struct {
	CreatedAt *big.Int
	Tags      []string
}

// EncodedSize returns the total encoded size of UserMetadata2
func (t UserMetadata2) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += 32 + 32*len(t.Tags) // length + offset pointers for dynamic elements
	for _, elem := range t.Tags {
		dynamicSize += 32 + abi.Pad32(len(elem)) // length + padded string data
	}

	return UserMetadata2StaticSize + dynamicSize
}

// EncodeTo encodes UserMetadata2 to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t UserMetadata2) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := UserMetadata2StaticSize // Start dynamic data after static section

	// CreatedAt (static)

	if err := abi.EncodeBigInt(t.CreatedAt, buf[0:32], false); err != nil {
		return 0, err
	}

	// Tags (offset)
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))

	// Tags (dynamic)
	{
		// length
		binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.Tags)))
		dynamicOffset += 32

		var written int

		// data with dynamic region
		{
			buf := buf[dynamicOffset:]
			dynamicOffset := len(t.Tags) * 32 // start after static region

			var offset int
			for _, item := range t.Tags {
				// write offsets
				binary.BigEndian.PutUint64(buf[offset+24:offset+32], uint64(dynamicOffset))
				offset += 32

				// write data (dynamic)

				// length
				binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(item)))
				dynamicOffset += 32

				// data
				copy(buf[dynamicOffset:], []byte(item))
				dynamicOffset += abi.Pad32(len(item))

			}
			written = dynamicOffset
		}
		dynamicOffset += written

	}

	return dynamicOffset, nil
}

// Encode encodes UserMetadata2 to ABI bytes
func (t UserMetadata2) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes UserMetadata2 from ABI bytes in the provided buffer
func (t *UserMetadata2) Decode(data0 []byte) error {
	if len(data0) < UserMetadata2StaticSize {
		return fmt.Errorf("insufficient data for UserMetadata2")
	}

	// t.CreatedAt (static)
	t.CreatedAt = new(big.Int).SetBytes(data0[0:32])
	// Tags
	{
		offset := int(binary.BigEndian.Uint64(data0[32+24 : 32+32]))

		// t.Tags (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// slice data
		t.Tags = make([]string, length)
		data1 := data0[offset:]

		// Dynamic elements with offsets (dynamic array)
		for i0 := 0; i0 < length; i0++ {
			// Read element offset
			tmp := i0 * 32
			if tmp+32 > len(data1) {
				return fmt.Errorf("insufficient data for element offset")
			}
			offset := int(binary.BigEndian.Uint64(data1[tmp+24 : tmp+32]))
			// Decode dynamic element at offset
			// t.Tags[i0] (dynamic)
			if offset+32 > len(data1) {
				return fmt.Errorf("insufficient data for length prefix")
			}
			length := int(binary.BigEndian.Uint64(data1[offset+24 : offset+32]))
			offset += 32
			// string data
			t.Tags[i0] = string(data1[offset : offset+length])
		}
	}

	return nil
}

const UserProfileStaticSize = 96

// UserProfile represents an ABI tuple
type UserProfile struct {
	Name     string
	Emails   []string
	Metadata UserMetadata2
}

// EncodedSize returns the total encoded size of UserProfile
func (t UserProfile) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += 32 + abi.Pad32(len(t.Name)) // length + padded string data
	dynamicSize += 32 + 32*len(t.Emails)       // length + offset pointers for dynamic elements
	for _, elem := range t.Emails {
		dynamicSize += 32 + abi.Pad32(len(elem)) // length + padded string data
	}
	dynamicSize += t.Metadata.EncodedSize() // dynamic tuple

	return UserProfileStaticSize + dynamicSize
}

// EncodeTo encodes UserProfile to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t UserProfile) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := UserProfileStaticSize // Start dynamic data after static section

	// Name (offset)
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))

	// Name (dynamic)
	// length
	binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.Name)))
	dynamicOffset += 32

	// data
	copy(buf[dynamicOffset:], []byte(t.Name))
	dynamicOffset += abi.Pad32(len(t.Name))

	// Emails (offset)
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))

	// Emails (dynamic)
	{
		// length
		binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.Emails)))
		dynamicOffset += 32

		var written int

		// data with dynamic region
		{
			buf := buf[dynamicOffset:]
			dynamicOffset := len(t.Emails) * 32 // start after static region

			var offset int
			for _, item := range t.Emails {
				// write offsets
				binary.BigEndian.PutUint64(buf[offset+24:offset+32], uint64(dynamicOffset))
				offset += 32

				// write data (dynamic)

				// length
				binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(item)))
				dynamicOffset += 32

				// data
				copy(buf[dynamicOffset:], []byte(item))
				dynamicOffset += abi.Pad32(len(item))

			}
			written = dynamicOffset
		}
		dynamicOffset += written

	}

	// Metadata (offset)
	binary.BigEndian.PutUint64(buf[64+24:64+32], uint64(dynamicOffset))

	// Metadata (dynamic)
	n, err := t.Metadata.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes UserProfile to ABI bytes
func (t UserProfile) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes UserProfile from ABI bytes in the provided buffer
func (t *UserProfile) Decode(data0 []byte) error {
	if len(data0) < UserProfileStaticSize {
		return fmt.Errorf("insufficient data for UserProfile")
	}

	// Name
	{
		offset := int(binary.BigEndian.Uint64(data0[0+24 : 0+32]))

		// t.Name (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// string data
		t.Name = string(data0[offset : offset+length])
	}
	// Emails
	{
		offset := int(binary.BigEndian.Uint64(data0[32+24 : 32+32]))

		// t.Emails (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// slice data
		t.Emails = make([]string, length)
		data1 := data0[offset:]

		// Dynamic elements with offsets (dynamic array)
		for i0 := 0; i0 < length; i0++ {
			// Read element offset
			tmp := i0 * 32
			if tmp+32 > len(data1) {
				return fmt.Errorf("insufficient data for element offset")
			}
			offset := int(binary.BigEndian.Uint64(data1[tmp+24 : tmp+32]))
			// Decode dynamic element at offset
			// t.Emails[i0] (dynamic)
			if offset+32 > len(data1) {
				return fmt.Errorf("insufficient data for length prefix")
			}
			length := int(binary.BigEndian.Uint64(data1[offset+24 : offset+32]))
			offset += 32
			// string data
			t.Emails[i0] = string(data1[offset : offset+length])
		}
	}
	// Metadata
	{
		offset := int(binary.BigEndian.Uint64(data0[64+24 : 64+32]))

		// t.Metadata (dynamic)
		if offset >= len(data0) {
			return fmt.Errorf("insufficient data for dynamic data, t.Metadata")
		}
		if err := t.Metadata.Decode(data0[offset:]); err != nil {
			return err
		}
	}

	return nil
}

const TestComplexDynamicTuplesCallStaticSize = 32

// TestComplexDynamicTuplesCall represents an ABI tuple
type TestComplexDynamicTuplesCall struct {
	Users []User2
}

// EncodedSize returns the total encoded size of TestComplexDynamicTuplesCall
func (t TestComplexDynamicTuplesCall) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += 32 + 32*len(t.Users) // length + offset pointers for dynamic elements
	for _, elem := range t.Users {
		dynamicSize += elem.EncodedSize() // dynamic tuple
	}

	return TestComplexDynamicTuplesCallStaticSize + dynamicSize
}

// EncodeTo encodes TestComplexDynamicTuplesCall to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t TestComplexDynamicTuplesCall) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := TestComplexDynamicTuplesCallStaticSize // Start dynamic data after static section

	// Users (offset)
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))

	// Users (dynamic)
	{
		// length
		binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.Users)))
		dynamicOffset += 32

		var written int

		// data with dynamic region
		{
			buf := buf[dynamicOffset:]
			dynamicOffset := len(t.Users) * 32 // start after static region

			var offset int
			for _, item := range t.Users {
				// write offsets
				binary.BigEndian.PutUint64(buf[offset+24:offset+32], uint64(dynamicOffset))
				offset += 32

				// write data (dynamic)

				n, err := item.EncodeTo(buf[dynamicOffset:])
				if err != nil {
					return 0, err
				}
				dynamicOffset += n

			}
			written = dynamicOffset
		}
		dynamicOffset += written

	}

	return dynamicOffset, nil
}

// Encode encodes TestComplexDynamicTuplesCall to ABI bytes
func (t TestComplexDynamicTuplesCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestComplexDynamicTuplesCall from ABI bytes in the provided buffer
func (t *TestComplexDynamicTuplesCall) Decode(data0 []byte) error {
	if len(data0) < TestComplexDynamicTuplesCallStaticSize {
		return fmt.Errorf("insufficient data for TestComplexDynamicTuplesCall")
	}

	// Users
	{
		offset := int(binary.BigEndian.Uint64(data0[0+24 : 0+32]))

		// t.Users (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// slice data
		t.Users = make([]User2, length)
		data1 := data0[offset:]

		// Dynamic elements with offsets (dynamic array)
		for i0 := 0; i0 < length; i0++ {
			// Read element offset
			tmp := i0 * 32
			if tmp+32 > len(data1) {
				return fmt.Errorf("insufficient data for element offset")
			}
			offset := int(binary.BigEndian.Uint64(data1[tmp+24 : tmp+32]))
			// Decode dynamic element at offset
			// t.Users[i0] (dynamic)
			if offset >= len(data1) {
				return fmt.Errorf("insufficient data for dynamic data, t.Users[i0]")
			}
			if err := t.Users[i0].Decode(data1[offset:]); err != nil {
				return err
			}
		}
	}

	return nil
}

// EncodeWithSelector encodes testComplexDynamicTuples arguments to ABI bytes including function selector
func (t TestComplexDynamicTuplesCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TestComplexDynamicTuplesSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const TestComplexDynamicTuplesReturnStaticSize = 32

// TestComplexDynamicTuplesReturn represents an ABI tuple
type TestComplexDynamicTuplesReturn struct {
	Result1 bool
}

// EncodedSize returns the total encoded size of TestComplexDynamicTuplesReturn
func (t TestComplexDynamicTuplesReturn) EncodedSize() int {
	dynamicSize := 0

	return TestComplexDynamicTuplesReturnStaticSize + dynamicSize
}

// EncodeTo encodes TestComplexDynamicTuplesReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t TestComplexDynamicTuplesReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := TestComplexDynamicTuplesReturnStaticSize // Start dynamic data after static section

	// Result1 (static)

	if t.Result1 {
		buf[0+31] = 1
	}

	return dynamicOffset, nil
}

// Encode encodes TestComplexDynamicTuplesReturn to ABI bytes
func (t TestComplexDynamicTuplesReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestComplexDynamicTuplesReturn from ABI bytes in the provided buffer
func (t *TestComplexDynamicTuplesReturn) Decode(data0 []byte) error {
	if len(data0) < TestComplexDynamicTuplesReturnStaticSize {
		return fmt.Errorf("insufficient data for TestComplexDynamicTuplesReturn")
	}

	// t.Result1 (static)
	t.Result1 = data0[0+31] == 1

	return nil
}

const TestDeeplyNestedCallStaticSize = 32

// TestDeeplyNestedCall represents an ABI tuple
type TestDeeplyNestedCall struct {
	Data Level1
}

// EncodedSize returns the total encoded size of TestDeeplyNestedCall
func (t TestDeeplyNestedCall) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += t.Data.EncodedSize() // dynamic tuple

	return TestDeeplyNestedCallStaticSize + dynamicSize
}

// EncodeTo encodes TestDeeplyNestedCall to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t TestDeeplyNestedCall) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := TestDeeplyNestedCallStaticSize // Start dynamic data after static section

	// Data (offset)
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))

	// Data (dynamic)
	n, err := t.Data.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes TestDeeplyNestedCall to ABI bytes
func (t TestDeeplyNestedCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestDeeplyNestedCall from ABI bytes in the provided buffer
func (t *TestDeeplyNestedCall) Decode(data0 []byte) error {
	if len(data0) < TestDeeplyNestedCallStaticSize {
		return fmt.Errorf("insufficient data for TestDeeplyNestedCall")
	}

	// Data
	{
		offset := int(binary.BigEndian.Uint64(data0[0+24 : 0+32]))

		// t.Data (dynamic)
		if offset >= len(data0) {
			return fmt.Errorf("insufficient data for dynamic data, t.Data")
		}
		if err := t.Data.Decode(data0[offset:]); err != nil {
			return err
		}
	}

	return nil
}

// EncodeWithSelector encodes testDeeplyNested arguments to ABI bytes including function selector
func (t TestDeeplyNestedCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TestDeeplyNestedSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const TestDeeplyNestedReturnStaticSize = 32

// TestDeeplyNestedReturn represents an ABI tuple
type TestDeeplyNestedReturn struct {
	Result1 bool
}

// EncodedSize returns the total encoded size of TestDeeplyNestedReturn
func (t TestDeeplyNestedReturn) EncodedSize() int {
	dynamicSize := 0

	return TestDeeplyNestedReturnStaticSize + dynamicSize
}

// EncodeTo encodes TestDeeplyNestedReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t TestDeeplyNestedReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := TestDeeplyNestedReturnStaticSize // Start dynamic data after static section

	// Result1 (static)

	if t.Result1 {
		buf[0+31] = 1
	}

	return dynamicOffset, nil
}

// Encode encodes TestDeeplyNestedReturn to ABI bytes
func (t TestDeeplyNestedReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestDeeplyNestedReturn from ABI bytes in the provided buffer
func (t *TestDeeplyNestedReturn) Decode(data0 []byte) error {
	if len(data0) < TestDeeplyNestedReturnStaticSize {
		return fmt.Errorf("insufficient data for TestDeeplyNestedReturn")
	}

	// t.Result1 (static)
	t.Result1 = data0[0+31] == 1

	return nil
}

const TestFixedArraysCallStaticSize = 320

// TestFixedArraysCall represents an ABI tuple
type TestFixedArraysCall struct {
	Addresses [5]common.Address
	Uints     [3]*big.Int
	Bytes32s  [2][32]byte
}

// EncodedSize returns the total encoded size of TestFixedArraysCall
func (t TestFixedArraysCall) EncodedSize() int {
	dynamicSize := 0

	return TestFixedArraysCallStaticSize + dynamicSize
}

// EncodeTo encodes TestFixedArraysCall to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t TestFixedArraysCall) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := TestFixedArraysCallStaticSize // Start dynamic data after static section

	// Addresses (static)

	// Encode fixed-size array t.Addresses
	{
		offset := 0
		for _, item := range t.Addresses {

			copy(buf[offset+12:offset+32], item[:])

			offset += 32
		}
	}

	// Uints (static)

	// Encode fixed-size array t.Uints
	{
		offset := 160
		for _, item := range t.Uints {

			if err := abi.EncodeBigInt(item, buf[offset:offset+32], false); err != nil {
				return 0, err
			}

			offset += 32
		}
	}

	// Bytes32s (static)

	// Encode fixed-size array t.Bytes32s
	{
		offset := 256
		for _, item := range t.Bytes32s {

			copy(buf[offset:offset+32], item[:])

			offset += 32
		}
	}

	return dynamicOffset, nil
}

// Encode encodes TestFixedArraysCall to ABI bytes
func (t TestFixedArraysCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestFixedArraysCall from ABI bytes in the provided buffer
func (t *TestFixedArraysCall) Decode(data0 []byte) error {
	if len(data0) < TestFixedArraysCallStaticSize {
		return fmt.Errorf("insufficient data for TestFixedArraysCall")
	}

	// t.Addresses (static)
	// Decode fixed-size array t.Addresses
	for i0 := 0; i0 < 5; i0++ {
		offset := 0 + i0*32
		data1 := data0
		// t.Addresses[i0] (static)
		copy(t.Addresses[i0][:], data1[offset+12:offset+32])
	}
	// t.Uints (static)
	// Decode fixed-size array t.Uints
	for i0 := 0; i0 < 3; i0++ {
		offset := 160 + i0*32
		data1 := data0
		// t.Uints[i0] (static)
		t.Uints[i0] = new(big.Int).SetBytes(data1[offset : offset+32])
	}
	// t.Bytes32s (static)
	// Decode fixed-size array t.Bytes32s
	for i0 := 0; i0 < 2; i0++ {
		offset := 256 + i0*32
		data1 := data0
		// t.Bytes32s[i0] (static)
		copy(t.Bytes32s[i0][:], data1[offset:offset+32])
	}

	return nil
}

// EncodeWithSelector encodes testFixedArrays arguments to ABI bytes including function selector
func (t TestFixedArraysCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TestFixedArraysSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const TestFixedArraysReturnStaticSize = 32

// TestFixedArraysReturn represents an ABI tuple
type TestFixedArraysReturn struct {
	Result1 bool
}

// EncodedSize returns the total encoded size of TestFixedArraysReturn
func (t TestFixedArraysReturn) EncodedSize() int {
	dynamicSize := 0

	return TestFixedArraysReturnStaticSize + dynamicSize
}

// EncodeTo encodes TestFixedArraysReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t TestFixedArraysReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := TestFixedArraysReturnStaticSize // Start dynamic data after static section

	// Result1 (static)

	if t.Result1 {
		buf[0+31] = 1
	}

	return dynamicOffset, nil
}

// Encode encodes TestFixedArraysReturn to ABI bytes
func (t TestFixedArraysReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestFixedArraysReturn from ABI bytes in the provided buffer
func (t *TestFixedArraysReturn) Decode(data0 []byte) error {
	if len(data0) < TestFixedArraysReturnStaticSize {
		return fmt.Errorf("insufficient data for TestFixedArraysReturn")
	}

	// t.Result1 (static)
	t.Result1 = data0[0+31] == 1

	return nil
}

const TestMixedTypesCallStaticSize = 160

// TestMixedTypesCall represents an ABI tuple
type TestMixedTypesCall struct {
	FixedData   [32]byte
	DynamicData []byte
	Flag        bool
	Count       uint8
	Items       []Item
}

// EncodedSize returns the total encoded size of TestMixedTypesCall
func (t TestMixedTypesCall) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += 32 + abi.Pad32(len(t.DynamicData)) // length + padded bytes data
	dynamicSize += 32 + 32*len(t.Items)               // length + offset pointers for dynamic elements
	for _, elem := range t.Items {
		dynamicSize += elem.EncodedSize() // dynamic tuple
	}

	return TestMixedTypesCallStaticSize + dynamicSize
}

// EncodeTo encodes TestMixedTypesCall to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t TestMixedTypesCall) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := TestMixedTypesCallStaticSize // Start dynamic data after static section

	// FixedData (static)
	copy(buf[0:0+32], t.FixedData[:])

	// DynamicData (offset)
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))

	// DynamicData (dynamic)
	// length
	binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.DynamicData)))
	dynamicOffset += 32

	// data
	copy(buf[dynamicOffset:], t.DynamicData)
	dynamicOffset += abi.Pad32(len(t.DynamicData))

	// Flag (static)

	if t.Flag {
		buf[64+31] = 1
	}

	// Count (static)
	buf[96+31] = byte(t.Count)

	// Items (offset)
	binary.BigEndian.PutUint64(buf[128+24:128+32], uint64(dynamicOffset))

	// Items (dynamic)
	{
		// length
		binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.Items)))
		dynamicOffset += 32

		var written int

		// data with dynamic region
		{
			buf := buf[dynamicOffset:]
			dynamicOffset := len(t.Items) * 32 // start after static region

			var offset int
			for _, item := range t.Items {
				// write offsets
				binary.BigEndian.PutUint64(buf[offset+24:offset+32], uint64(dynamicOffset))
				offset += 32

				// write data (dynamic)

				n, err := item.EncodeTo(buf[dynamicOffset:])
				if err != nil {
					return 0, err
				}
				dynamicOffset += n

			}
			written = dynamicOffset
		}
		dynamicOffset += written

	}

	return dynamicOffset, nil
}

// Encode encodes TestMixedTypesCall to ABI bytes
func (t TestMixedTypesCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestMixedTypesCall from ABI bytes in the provided buffer
func (t *TestMixedTypesCall) Decode(data0 []byte) error {
	if len(data0) < TestMixedTypesCallStaticSize {
		return fmt.Errorf("insufficient data for TestMixedTypesCall")
	}

	// t.FixedData (static)
	copy(t.FixedData[:], data0[0:0+32])
	// DynamicData
	{
		offset := int(binary.BigEndian.Uint64(data0[32+24 : 32+32]))

		// t.DynamicData (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// bytes data
		t.DynamicData = data0[offset : offset+length]
	}
	// t.Flag (static)
	t.Flag = data0[64+31] == 1
	// t.Count (static)
	t.Count = uint8(data0[96+31])
	// Items
	{
		offset := int(binary.BigEndian.Uint64(data0[128+24 : 128+32]))

		// t.Items (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// slice data
		t.Items = make([]Item, length)
		data1 := data0[offset:]

		// Dynamic elements with offsets (dynamic array)
		for i0 := 0; i0 < length; i0++ {
			// Read element offset
			tmp := i0 * 32
			if tmp+32 > len(data1) {
				return fmt.Errorf("insufficient data for element offset")
			}
			offset := int(binary.BigEndian.Uint64(data1[tmp+24 : tmp+32]))
			// Decode dynamic element at offset
			// t.Items[i0] (dynamic)
			if offset >= len(data1) {
				return fmt.Errorf("insufficient data for dynamic data, t.Items[i0]")
			}
			if err := t.Items[i0].Decode(data1[offset:]); err != nil {
				return err
			}
		}
	}

	return nil
}

// EncodeWithSelector encodes testMixedTypes arguments to ABI bytes including function selector
func (t TestMixedTypesCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TestMixedTypesSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const TestMixedTypesReturnStaticSize = 32

// TestMixedTypesReturn represents an ABI tuple
type TestMixedTypesReturn struct {
	Result1 bool
}

// EncodedSize returns the total encoded size of TestMixedTypesReturn
func (t TestMixedTypesReturn) EncodedSize() int {
	dynamicSize := 0

	return TestMixedTypesReturnStaticSize + dynamicSize
}

// EncodeTo encodes TestMixedTypesReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t TestMixedTypesReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := TestMixedTypesReturnStaticSize // Start dynamic data after static section

	// Result1 (static)

	if t.Result1 {
		buf[0+31] = 1
	}

	return dynamicOffset, nil
}

// Encode encodes TestMixedTypesReturn to ABI bytes
func (t TestMixedTypesReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestMixedTypesReturn from ABI bytes in the provided buffer
func (t *TestMixedTypesReturn) Decode(data0 []byte) error {
	if len(data0) < TestMixedTypesReturnStaticSize {
		return fmt.Errorf("insufficient data for TestMixedTypesReturn")
	}

	// t.Result1 (static)
	t.Result1 = data0[0+31] == 1

	return nil
}

const TestNestedDynamicArraysCallStaticSize = 64

// TestNestedDynamicArraysCall represents an ABI tuple
type TestNestedDynamicArraysCall struct {
	Matrix        [][]*big.Int
	AddressMatrix [][]common.Address
}

// EncodedSize returns the total encoded size of TestNestedDynamicArraysCall
func (t TestNestedDynamicArraysCall) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += 32 + 32*len(t.Matrix) // length + offset pointers for dynamic elements
	for _, elem := range t.Matrix {
		dynamicSize += 32 + 32*len(elem) // length + static elements
	}
	dynamicSize += 32 + 32*len(t.AddressMatrix) // length + offset pointers for dynamic elements
	for _, elem := range t.AddressMatrix {
		dynamicSize += 32 + 32*len(elem) // length + static elements
	}

	return TestNestedDynamicArraysCallStaticSize + dynamicSize
}

// EncodeTo encodes TestNestedDynamicArraysCall to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t TestNestedDynamicArraysCall) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := TestNestedDynamicArraysCallStaticSize // Start dynamic data after static section

	// Matrix (offset)
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))

	// Matrix (dynamic)
	{
		// length
		binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.Matrix)))
		dynamicOffset += 32

		var written int

		// data with dynamic region
		{
			buf := buf[dynamicOffset:]
			dynamicOffset := len(t.Matrix) * 32 // start after static region

			var offset int
			for _, item := range t.Matrix {
				// write offsets
				binary.BigEndian.PutUint64(buf[offset+24:offset+32], uint64(dynamicOffset))
				offset += 32

				// write data (dynamic)

				{
					// length
					binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(item)))
					dynamicOffset += 32

					// data without dynamic region
					buf := buf[dynamicOffset:]
					var offset int
					for _, item := range item {

						if err := abi.EncodeBigInt(item, buf[offset:offset+32], false); err != nil {
							return 0, err
						}

						offset += 32
					}
					dynamicOffset += offset

				}

			}
			written = dynamicOffset
		}
		dynamicOffset += written

	}

	// AddressMatrix (offset)
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))

	// AddressMatrix (dynamic)
	{
		// length
		binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.AddressMatrix)))
		dynamicOffset += 32

		var written int

		// data with dynamic region
		{
			buf := buf[dynamicOffset:]
			dynamicOffset := len(t.AddressMatrix) * 32 // start after static region

			var offset int
			for _, item := range t.AddressMatrix {
				// write offsets
				binary.BigEndian.PutUint64(buf[offset+24:offset+32], uint64(dynamicOffset))
				offset += 32

				// write data (dynamic)

				{
					// length
					binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(item)))
					dynamicOffset += 32

					// data without dynamic region
					buf := buf[dynamicOffset:]
					var offset int
					for _, item := range item {

						copy(buf[offset+12:offset+32], item[:])

						offset += 32
					}
					dynamicOffset += offset

				}

			}
			written = dynamicOffset
		}
		dynamicOffset += written

	}

	return dynamicOffset, nil
}

// Encode encodes TestNestedDynamicArraysCall to ABI bytes
func (t TestNestedDynamicArraysCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestNestedDynamicArraysCall from ABI bytes in the provided buffer
func (t *TestNestedDynamicArraysCall) Decode(data0 []byte) error {
	if len(data0) < TestNestedDynamicArraysCallStaticSize {
		return fmt.Errorf("insufficient data for TestNestedDynamicArraysCall")
	}

	// Matrix
	{
		offset := int(binary.BigEndian.Uint64(data0[0+24 : 0+32]))

		// t.Matrix (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// slice data
		t.Matrix = make([][]*big.Int, length)
		data1 := data0[offset:]

		// Dynamic elements with offsets (dynamic array)
		for i0 := 0; i0 < length; i0++ {
			// Read element offset
			tmp := i0 * 32
			if tmp+32 > len(data1) {
				return fmt.Errorf("insufficient data for element offset")
			}
			offset := int(binary.BigEndian.Uint64(data1[tmp+24 : tmp+32]))
			// Decode dynamic element at offset
			// t.Matrix[i0] (dynamic)
			if offset+32 > len(data1) {
				return fmt.Errorf("insufficient data for length prefix")
			}
			length := int(binary.BigEndian.Uint64(data1[offset+24 : offset+32]))
			offset += 32
			// slice data
			t.Matrix[i0] = make([]*big.Int, length)
			data2 := data1[offset:]

			offset = 0
			for i1 := 0; i1 < length; i1++ {
				// t.Matrix[i0][i1] (static)
				t.Matrix[i0][i1] = new(big.Int).SetBytes(data2[offset : offset+32])
				offset += 32
			}
		}
	}
	// AddressMatrix
	{
		offset := int(binary.BigEndian.Uint64(data0[32+24 : 32+32]))

		// t.AddressMatrix (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// slice data
		t.AddressMatrix = make([][]common.Address, length)
		data1 := data0[offset:]

		// Dynamic elements with offsets (dynamic array)
		for i0 := 0; i0 < length; i0++ {
			// Read element offset
			tmp := i0 * 32
			if tmp+32 > len(data1) {
				return fmt.Errorf("insufficient data for element offset")
			}
			offset := int(binary.BigEndian.Uint64(data1[tmp+24 : tmp+32]))
			// Decode dynamic element at offset
			// t.AddressMatrix[i0] (dynamic)
			if offset+32 > len(data1) {
				return fmt.Errorf("insufficient data for length prefix")
			}
			length := int(binary.BigEndian.Uint64(data1[offset+24 : offset+32]))
			offset += 32
			// slice data
			t.AddressMatrix[i0] = make([]common.Address, length)
			data2 := data1[offset:]

			offset = 0
			for i1 := 0; i1 < length; i1++ {
				// t.AddressMatrix[i0][i1] (static)
				copy(t.AddressMatrix[i0][i1][:], data2[offset+12:offset+32])
				offset += 32
			}
		}
	}

	return nil
}

// EncodeWithSelector encodes testNestedDynamicArrays arguments to ABI bytes including function selector
func (t TestNestedDynamicArraysCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TestNestedDynamicArraysSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const TestNestedDynamicArraysReturnStaticSize = 32

// TestNestedDynamicArraysReturn represents an ABI tuple
type TestNestedDynamicArraysReturn struct {
	Result1 bool
}

// EncodedSize returns the total encoded size of TestNestedDynamicArraysReturn
func (t TestNestedDynamicArraysReturn) EncodedSize() int {
	dynamicSize := 0

	return TestNestedDynamicArraysReturnStaticSize + dynamicSize
}

// EncodeTo encodes TestNestedDynamicArraysReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t TestNestedDynamicArraysReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := TestNestedDynamicArraysReturnStaticSize // Start dynamic data after static section

	// Result1 (static)

	if t.Result1 {
		buf[0+31] = 1
	}

	return dynamicOffset, nil
}

// Encode encodes TestNestedDynamicArraysReturn to ABI bytes
func (t TestNestedDynamicArraysReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestNestedDynamicArraysReturn from ABI bytes in the provided buffer
func (t *TestNestedDynamicArraysReturn) Decode(data0 []byte) error {
	if len(data0) < TestNestedDynamicArraysReturnStaticSize {
		return fmt.Errorf("insufficient data for TestNestedDynamicArraysReturn")
	}

	// t.Result1 (static)
	t.Result1 = data0[0+31] == 1

	return nil
}

const TestSmallIntegersCallStaticSize = 256

// TestSmallIntegersCall represents an ABI tuple
type TestSmallIntegersCall struct {
	U8  uint8
	U16 uint16
	U32 uint32
	U64 uint64
	I8  int8
	I16 int16
	I32 int32
	I64 int64
}

// EncodedSize returns the total encoded size of TestSmallIntegersCall
func (t TestSmallIntegersCall) EncodedSize() int {
	dynamicSize := 0

	return TestSmallIntegersCallStaticSize + dynamicSize
}

// EncodeTo encodes TestSmallIntegersCall to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t TestSmallIntegersCall) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := TestSmallIntegersCallStaticSize // Start dynamic data after static section

	// U8 (static)
	buf[0+31] = byte(t.U8)
	// U16 (static)
	binary.BigEndian.PutUint16(buf[32+30:32+32], uint16(t.U16))
	// U32 (static)
	binary.BigEndian.PutUint32(buf[64+28:64+32], uint32(t.U32))
	// U64 (static)
	binary.BigEndian.PutUint64(buf[96+24:96+32], uint64(t.U64))
	// I8 (static)

	if t.I8 < 0 {
		for i := 0; i < 31; i++ {
			buf[128+i] = 0xff
		}
	}
	buf[128+31] = byte(t.I8)

	// I16 (static)

	if t.I16 < 0 {
		for i := 0; i < 30; i++ {
			buf[160+i] = 0xff
		}
	}
	binary.BigEndian.PutUint16(buf[160+30:160+32], uint16(t.I16))

	// I32 (static)

	if t.I32 < 0 {
		for i := 0; i < 28; i++ {
			buf[192+i] = 0xff
		}
	}
	binary.BigEndian.PutUint32(buf[192+28:192+32], uint32(t.I32))

	// I64 (static)

	if t.I64 < 0 {
		for i := 0; i < 24; i++ {
			buf[224+i] = 0xff
		}
	}
	binary.BigEndian.PutUint64(buf[224+24:224+32], uint64(t.I64))

	return dynamicOffset, nil
}

// Encode encodes TestSmallIntegersCall to ABI bytes
func (t TestSmallIntegersCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestSmallIntegersCall from ABI bytes in the provided buffer
func (t *TestSmallIntegersCall) Decode(data0 []byte) error {
	if len(data0) < TestSmallIntegersCallStaticSize {
		return fmt.Errorf("insufficient data for TestSmallIntegersCall")
	}

	// t.U8 (static)
	t.U8 = uint8(data0[0+31])
	// t.U16 (static)
	t.U16 = uint16(binary.BigEndian.Uint16(data0[32+30 : 32+32]))
	// t.U32 (static)
	t.U32 = uint32(binary.BigEndian.Uint32(data0[64+28 : 64+32]))
	// t.U64 (static)
	t.U64 = uint64(binary.BigEndian.Uint64(data0[96+24 : 96+32]))
	// t.I8 (static)
	t.I8 = int8(data0[128+31])
	// t.I16 (static)
	t.I16 = int16(binary.BigEndian.Uint16(data0[160+30 : 160+32]))
	// t.I32 (static)
	t.I32 = int32(binary.BigEndian.Uint32(data0[192+28 : 192+32]))
	// t.I64 (static)
	t.I64 = int64(binary.BigEndian.Uint64(data0[224+24 : 224+32]))

	return nil
}

// EncodeWithSelector encodes testSmallIntegers arguments to ABI bytes including function selector
func (t TestSmallIntegersCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TestSmallIntegersSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const TestSmallIntegersReturnStaticSize = 32

// TestSmallIntegersReturn represents an ABI tuple
type TestSmallIntegersReturn struct {
	Result1 bool
}

// EncodedSize returns the total encoded size of TestSmallIntegersReturn
func (t TestSmallIntegersReturn) EncodedSize() int {
	dynamicSize := 0

	return TestSmallIntegersReturnStaticSize + dynamicSize
}

// EncodeTo encodes TestSmallIntegersReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t TestSmallIntegersReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := TestSmallIntegersReturnStaticSize // Start dynamic data after static section

	// Result1 (static)

	if t.Result1 {
		buf[0+31] = 1
	}

	return dynamicOffset, nil
}

// Encode encodes TestSmallIntegersReturn to ABI bytes
func (t TestSmallIntegersReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestSmallIntegersReturn from ABI bytes in the provided buffer
func (t *TestSmallIntegersReturn) Decode(data0 []byte) error {
	if len(data0) < TestSmallIntegersReturnStaticSize {
		return fmt.Errorf("insufficient data for TestSmallIntegersReturn")
	}

	// t.Result1 (static)
	t.Result1 = data0[0+31] == 1

	return nil
}
