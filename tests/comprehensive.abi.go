// Code generated by go-abi generator2. DO NOT EDIT.

package tests

import (
	"encoding/binary"
	"fmt"
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/yihuang/go-abi"
)

// Function selectors
var (
	// testComplexDynamicTuples((uint256,(string,string[],(uint256,string[])))[])
	TestComplexDynamicTuplesSelector = [4]byte{0xc0, 0x96, 0x4c, 0x93}
	// testDeeplyNested(((((uint256,string)))))
	TestDeeplyNestedSelector = [4]byte{0x21, 0x75, 0xe8, 0x54}
	// testExternalTuple((address,string,uint256))
	TestExternalTupleSelector = [4]byte{0x96, 0x39, 0x8b, 0x38}
	// testFixedArrays(address[5],uint256[3],bytes32[2])
	TestFixedArraysSelector = [4]byte{0x23, 0xb8, 0x46, 0x5c}
	// testMixedTypes(bytes32,bytes,bool,uint8,(uint32,bytes,bool)[])
	TestMixedTypesSelector = [4]byte{0x85, 0x8a, 0xe6, 0x15}
	// testNestedDynamicArrays(uint256[][],address[][3][],string[][])
	TestNestedDynamicArraysSelector = [4]byte{0x1a, 0xdd, 0xf6, 0x20}
	// testNestedStruct(((address,string,uint256)[]))
	TestNestedStructSelector = [4]byte{0xe8, 0x3b, 0x85, 0x67}
	// testSmallIntegers(uint8,uint16,uint32,uint64,int8,int16,int32,int64)
	TestSmallIntegersSelector = [4]byte{0x29, 0x2b, 0xd2, 0x39}
)

// Big endian integer versions of function selectors
const (
	TestComplexDynamicTuplesID = 3231075475
	TestDeeplyNestedID         = 561375316
	TestExternalTupleID        = 2520353592
	TestFixedArraysID          = 599279196
	TestMixedTypesID           = 2240472597
	TestNestedDynamicArraysID  = 450754080
	TestNestedStructID         = 3896214887
	TestSmallIntegersID        = 690737721
)

const GroupStaticSize = 32

// Group represents an ABI tuple
type Group struct {
	Users []User
}

// EncodedSize returns the total encoded size of Group
func (t Group) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += 32 + 32*len(t.Users) // length + offset pointers for dynamic elements
	for _, elem := range t.Users {
		dynamicSize += elem.EncodedSize() // dynamic tuple
	}

	return GroupStaticSize + dynamicSize
}

// EncodeTo encodes Group to ABI bytes in the provided buffer
func (value Group) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	offset := 0
	var (
		err error
		n   int
	)
	// Field 0: (address,string,uint256)[]
	n, err = encode_User_array(value.Users, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// Encode encodes Group to ABI bytes
func (t Group) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Group from ABI bytes in the provided buffer
func (t *Group) Decode(data0 []byte) error {
	// TODO: Implement decode
	return fmt.Errorf("decode not yet implemented")
}

const ItemStaticSize = 96

// Item represents an ABI tuple
type Item struct {
	Id     uint32
	Data   []byte
	Active bool
}

// EncodedSize returns the total encoded size of Item
func (t Item) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += 32 + abi.Pad32(len(t.Data)) // length + padded bytes data

	return ItemStaticSize + dynamicSize
}

// EncodeTo encodes Item to ABI bytes in the provided buffer
func (value Item) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	offset := 0
	var (
		err error
		n   int
	)
	// Field 0: uint32
	n, err = encode_uint32(value.Id, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 1: bytes
	n, err = encode_bytes(value.Data, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 2: bool
	n, err = encode_bool(value.Active, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// Encode encodes Item to ABI bytes
func (t Item) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Item from ABI bytes in the provided buffer
func (t *Item) Decode(data0 []byte) error {
	// TODO: Implement decode
	return fmt.Errorf("decode not yet implemented")
}

const Level1StaticSize = 32

// Level1 represents an ABI tuple
type Level1 struct {
	Level1 Level2
}

// EncodedSize returns the total encoded size of Level1
func (t Level1) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.Level1.EncodedSize() // dynamic tuple

	return Level1StaticSize + dynamicSize
}

// EncodeTo encodes Level1 to ABI bytes in the provided buffer
func (value Level1) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	offset := 0
	var (
		err error
		n   int
	)
	// Field 0: (((uint256,string)))
	n, err = value.Level1.EncodeTo(buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// Encode encodes Level1 to ABI bytes
func (t Level1) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Level1 from ABI bytes in the provided buffer
func (t *Level1) Decode(data0 []byte) error {
	// TODO: Implement decode
	return fmt.Errorf("decode not yet implemented")
}

const Level2StaticSize = 32

// Level2 represents an ABI tuple
type Level2 struct {
	Level2 Level3
}

// EncodedSize returns the total encoded size of Level2
func (t Level2) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.Level2.EncodedSize() // dynamic tuple

	return Level2StaticSize + dynamicSize
}

// EncodeTo encodes Level2 to ABI bytes in the provided buffer
func (value Level2) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	offset := 0
	var (
		err error
		n   int
	)
	// Field 0: ((uint256,string))
	n, err = value.Level2.EncodeTo(buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// Encode encodes Level2 to ABI bytes
func (t Level2) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Level2 from ABI bytes in the provided buffer
func (t *Level2) Decode(data0 []byte) error {
	// TODO: Implement decode
	return fmt.Errorf("decode not yet implemented")
}

const Level3StaticSize = 32

// Level3 represents an ABI tuple
type Level3 struct {
	Level3 Level4
}

// EncodedSize returns the total encoded size of Level3
func (t Level3) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.Level3.EncodedSize() // dynamic tuple

	return Level3StaticSize + dynamicSize
}

// EncodeTo encodes Level3 to ABI bytes in the provided buffer
func (value Level3) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	offset := 0
	var (
		err error
		n   int
	)
	// Field 0: (uint256,string)
	n, err = value.Level3.EncodeTo(buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// Encode encodes Level3 to ABI bytes
func (t Level3) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Level3 from ABI bytes in the provided buffer
func (t *Level3) Decode(data0 []byte) error {
	// TODO: Implement decode
	return fmt.Errorf("decode not yet implemented")
}

const Level4StaticSize = 64

// Level4 represents an ABI tuple
type Level4 struct {
	Value       *big.Int
	Description string
}

// EncodedSize returns the total encoded size of Level4
func (t Level4) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += 32 + abi.Pad32(len(t.Description)) // length + padded string data

	return Level4StaticSize + dynamicSize
}

// EncodeTo encodes Level4 to ABI bytes in the provided buffer
func (value Level4) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	offset := 0
	var (
		err error
		n   int
	)
	// Field 0: uint256
	n, err = encode_uint256(value.Value, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 1: string
	n, err = encode_string(value.Description, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// Encode encodes Level4 to ABI bytes
func (t Level4) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Level4 from ABI bytes in the provided buffer
func (t *Level4) Decode(data0 []byte) error {
	// TODO: Implement decode
	return fmt.Errorf("decode not yet implemented")
}

const User2StaticSize = 64

// User2 represents an ABI tuple
type User2 struct {
	Id      *big.Int
	Profile UserProfile
}

// EncodedSize returns the total encoded size of User2
func (t User2) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.Profile.EncodedSize() // dynamic tuple

	return User2StaticSize + dynamicSize
}

// EncodeTo encodes User2 to ABI bytes in the provided buffer
func (value User2) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	offset := 0
	var (
		err error
		n   int
	)
	// Field 0: uint256
	n, err = encode_uint256(value.Id, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 1: (string,string[],(uint256,string[]))
	n, err = value.Profile.EncodeTo(buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// Encode encodes User2 to ABI bytes
func (t User2) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes User2 from ABI bytes in the provided buffer
func (t *User2) Decode(data0 []byte) error {
	// TODO: Implement decode
	return fmt.Errorf("decode not yet implemented")
}

const UserMetadata2StaticSize = 64

// UserMetadata2 represents an ABI tuple
type UserMetadata2 struct {
	CreatedAt *big.Int
	Tags      []string
}

// EncodedSize returns the total encoded size of UserMetadata2
func (t UserMetadata2) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += 32 + 32*len(t.Tags) // length + offset pointers for dynamic elements
	for _, elem := range t.Tags {
		dynamicSize += 32 + abi.Pad32(len(elem)) // length + padded string data
	}

	return UserMetadata2StaticSize + dynamicSize
}

// EncodeTo encodes UserMetadata2 to ABI bytes in the provided buffer
func (value UserMetadata2) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	offset := 0
	var (
		err error
		n   int
	)
	// Field 0: uint256
	n, err = encode_uint256(value.CreatedAt, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 1: string[]
	n, err = encode_string_array(value.Tags, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// Encode encodes UserMetadata2 to ABI bytes
func (t UserMetadata2) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes UserMetadata2 from ABI bytes in the provided buffer
func (t *UserMetadata2) Decode(data0 []byte) error {
	// TODO: Implement decode
	return fmt.Errorf("decode not yet implemented")
}

const UserProfileStaticSize = 96

// UserProfile represents an ABI tuple
type UserProfile struct {
	Name     string
	Emails   []string
	Metadata UserMetadata2
}

// EncodedSize returns the total encoded size of UserProfile
func (t UserProfile) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += 32 + abi.Pad32(len(t.Name)) // length + padded string data
	dynamicSize += 32 + 32*len(t.Emails)       // length + offset pointers for dynamic elements
	for _, elem := range t.Emails {
		dynamicSize += 32 + abi.Pad32(len(elem)) // length + padded string data
	}
	dynamicSize += t.Metadata.EncodedSize() // dynamic tuple

	return UserProfileStaticSize + dynamicSize
}

// EncodeTo encodes UserProfile to ABI bytes in the provided buffer
func (value UserProfile) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	offset := 0
	var (
		err error
		n   int
	)
	// Field 0: string
	n, err = encode_string(value.Name, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 1: string[]
	n, err = encode_string_array(value.Emails, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 2: (uint256,string[])
	n, err = value.Metadata.EncodeTo(buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// Encode encodes UserProfile to ABI bytes
func (t UserProfile) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes UserProfile from ABI bytes in the provided buffer
func (t *UserProfile) Decode(data0 []byte) error {
	// TODO: Implement decode
	return fmt.Errorf("decode not yet implemented")
}

// encode_User2_array encodes (uint256,(string,string[],(uint256,string[])))[] to ABI bytes
func encode_User2_array(value []User2, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))

	// Encode elements
	offset := 32
	for _, elem := range value {
		n, err := elem.EncodeTo(buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset, nil
}

// encode_string_array encodes string[] to ABI bytes
func encode_string_array(value []string, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))

	// Encode elements
	offset := 32
	for _, elem := range value {
		n, err := encode_string(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset, nil
}

// encode_bool encodes bool to ABI bytes
func encode_bool(value bool, buf []byte) (int, error) {
	if value {
		buf[31] = 1
	}
	return 32, nil
}

// encode_address encodes address to ABI bytes
func encode_address(value common.Address, buf []byte) (int, error) {
	copy(buf[12:32], value[:])
	return 32, nil
}

// encode_uint256_array_3 encodes uint256[3] to ABI bytes
func encode_uint256_array_3(value [3]*big.Int, buf []byte) (int, error) {
	// Encode fixed-size array
	offset := 0
	for _, elem := range value {
		n, err := encode_uint256(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset, nil
}

// encode_address_array encodes address[] to ABI bytes
func encode_address_array(value []common.Address, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))

	// Encode elements
	offset := 32
	for _, elem := range value {
		n, err := encode_address(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset, nil
}

// encode_int32 encodes int32 to ABI bytes
func encode_int32(value int32, buf []byte) (int, error) {
	if value < 0 {
		for i := 0; i < 28; i++ {
			buf[i] = 0xff
		}
	}
	binary.BigEndian.PutUint32(buf[28:32], uint32(value))
	return 32, nil
}

// encode_address_array_5 encodes address[5] to ABI bytes
func encode_address_array_5(value [5]common.Address, buf []byte) (int, error) {
	// Encode fixed-size array
	offset := 0
	for _, elem := range value {
		n, err := encode_address(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset, nil
}

// encode_bytes32_array_2 encodes bytes32[2] to ABI bytes
func encode_bytes32_array_2(value [2][32]byte, buf []byte) (int, error) {
	// Encode fixed-size array
	offset := 0
	for _, elem := range value {
		n, err := encode_bytes32(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset, nil
}

// encode_uint64 encodes uint64 to ABI bytes
func encode_uint64(value uint64, buf []byte) (int, error) {
	binary.BigEndian.PutUint64(buf[24:32], uint64(value))
	return 32, nil
}

// encode_string encodes string to ABI bytes
func encode_string(value string, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))

	// Encode data
	copy(buf[32:], []byte(value))

	return 32 + abi.Pad32(len(value)), nil
}

// encode_Item_array encodes (uint32,bytes,bool)[] to ABI bytes
func encode_Item_array(value []Item, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))

	// Encode elements
	offset := 32
	for _, elem := range value {
		n, err := elem.EncodeTo(buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset, nil
}

// encode_uint16 encodes uint16 to ABI bytes
func encode_uint16(value uint16, buf []byte) (int, error) {
	binary.BigEndian.PutUint16(buf[30:32], uint16(value))
	return 32, nil
}

// encode_bytes encodes bytes to ABI bytes
func encode_bytes(value []byte, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))

	// Encode data
	copy(buf[32:], value)

	return 32 + abi.Pad32(len(value)), nil
}

// encode_uint8 encodes uint8 to ABI bytes
func encode_uint8(value uint8, buf []byte) (int, error) {
	buf[31] = byte(value)
	return 32, nil
}

// encode_uint256 encodes uint256 to ABI bytes
func encode_uint256(value *big.Int, buf []byte) (int, error) {
	if err := abi.EncodeBigInt(value, buf[:32], false); err != nil {
		return 0, err
	}
	return 32, nil
}

// encode_bytes32 encodes bytes32 to ABI bytes
func encode_bytes32(value [32]byte, buf []byte) (int, error) {
	copy(buf[:32], value[:])
	return 32, nil
}

// encode_User_array encodes (address,string,uint256)[] to ABI bytes
func encode_User_array(value []User, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))

	// Encode elements
	offset := 32
	for _, elem := range value {
		n, err := elem.EncodeTo(buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset, nil
}

// encode_int8 encodes int8 to ABI bytes
func encode_int8(value int8, buf []byte) (int, error) {
	if value < 0 {
		for i := 0; i < 31; i++ {
			buf[i] = 0xff
		}
	}
	buf[31] = byte(value)
	return 32, nil
}

// encode_int16 encodes int16 to ABI bytes
func encode_int16(value int16, buf []byte) (int, error) {
	if value < 0 {
		for i := 0; i < 30; i++ {
			buf[i] = 0xff
		}
	}
	binary.BigEndian.PutUint16(buf[30:32], uint16(value))
	return 32, nil
}

// encode_int64 encodes int64 to ABI bytes
func encode_int64(value int64, buf []byte) (int, error) {
	if value < 0 {
		for i := 0; i < 24; i++ {
			buf[i] = 0xff
		}
	}
	binary.BigEndian.PutUint64(buf[24:32], uint64(value))
	return 32, nil
}

// encode_uint256_array_array encodes uint256[][] to ABI bytes
func encode_uint256_array_array(value [][]*big.Int, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))

	// Encode elements
	offset := 32
	for _, elem := range value {
		n, err := encode_uint256_array(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset, nil
}

// encode_address_array_array_3_array encodes address[][3][] to ABI bytes
func encode_address_array_array_3_array(value [][3][]common.Address, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))

	// Encode elements
	offset := 32
	for _, elem := range value {
		n, err := encode_address_array_array_3(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset, nil
}

// encode_address_array_array_3 encodes address[][3] to ABI bytes
func encode_address_array_array_3(value [3][]common.Address, buf []byte) (int, error) {
	// Encode fixed-size array
	offset := 0
	for _, elem := range value {
		n, err := encode_address_array(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset, nil
}

// encode_string_array_array encodes string[][] to ABI bytes
func encode_string_array_array(value [][]string, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))

	// Encode elements
	offset := 32
	for _, elem := range value {
		n, err := encode_string_array(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset, nil
}

// encode_uint32 encodes uint32 to ABI bytes
func encode_uint32(value uint32, buf []byte) (int, error) {
	binary.BigEndian.PutUint32(buf[28:32], uint32(value))
	return 32, nil
}

// encode_uint256_array encodes uint256[] to ABI bytes
func encode_uint256_array(value []*big.Int, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))

	// Encode elements
	offset := 32
	for _, elem := range value {
		n, err := encode_uint256(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset, nil
}

const TestComplexDynamicTuplesCallStaticSize = 32

// TestComplexDynamicTuplesCall represents an ABI tuple
type TestComplexDynamicTuplesCall struct {
	Users []User2
}

// EncodedSize returns the total encoded size of TestComplexDynamicTuplesCall
func (t TestComplexDynamicTuplesCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += 32 + 32*len(t.Users) // length + offset pointers for dynamic elements
	for _, elem := range t.Users {
		dynamicSize += elem.EncodedSize() // dynamic tuple
	}

	return TestComplexDynamicTuplesCallStaticSize + dynamicSize
}

// EncodeTo encodes TestComplexDynamicTuplesCall to ABI bytes in the provided buffer
func (value TestComplexDynamicTuplesCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	offset := 0
	var (
		err error
		n   int
	)
	// Field 0: (uint256,(string,string[],(uint256,string[])))[]
	n, err = encode_User2_array(value.Users, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// Encode encodes TestComplexDynamicTuplesCall to ABI bytes
func (t TestComplexDynamicTuplesCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestComplexDynamicTuplesCall from ABI bytes in the provided buffer
func (t *TestComplexDynamicTuplesCall) Decode(data0 []byte) error {
	// TODO: Implement decode
	return fmt.Errorf("decode not yet implemented")
}

// EncodeWithSelector encodes testComplexDynamicTuples arguments to ABI bytes including function selector
func (t TestComplexDynamicTuplesCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TestComplexDynamicTuplesSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const TestDeeplyNestedCallStaticSize = 32

// TestDeeplyNestedCall represents an ABI tuple
type TestDeeplyNestedCall struct {
	Data Level1
}

// EncodedSize returns the total encoded size of TestDeeplyNestedCall
func (t TestDeeplyNestedCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.Data.EncodedSize() // dynamic tuple

	return TestDeeplyNestedCallStaticSize + dynamicSize
}

// EncodeTo encodes TestDeeplyNestedCall to ABI bytes in the provided buffer
func (value TestDeeplyNestedCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	offset := 0
	var (
		err error
		n   int
	)
	// Field 0: ((((uint256,string))))
	n, err = value.Data.EncodeTo(buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// Encode encodes TestDeeplyNestedCall to ABI bytes
func (t TestDeeplyNestedCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestDeeplyNestedCall from ABI bytes in the provided buffer
func (t *TestDeeplyNestedCall) Decode(data0 []byte) error {
	// TODO: Implement decode
	return fmt.Errorf("decode not yet implemented")
}

// EncodeWithSelector encodes testDeeplyNested arguments to ABI bytes including function selector
func (t TestDeeplyNestedCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TestDeeplyNestedSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const TestExternalTupleCallStaticSize = 32

// TestExternalTupleCall represents an ABI tuple
type TestExternalTupleCall struct {
	User User
}

// EncodedSize returns the total encoded size of TestExternalTupleCall
func (t TestExternalTupleCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.User.EncodedSize() // dynamic tuple

	return TestExternalTupleCallStaticSize + dynamicSize
}

// EncodeTo encodes TestExternalTupleCall to ABI bytes in the provided buffer
func (value TestExternalTupleCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	offset := 0
	var (
		err error
		n   int
	)
	// Field 0: (address,string,uint256)
	n, err = value.User.EncodeTo(buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// Encode encodes TestExternalTupleCall to ABI bytes
func (t TestExternalTupleCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestExternalTupleCall from ABI bytes in the provided buffer
func (t *TestExternalTupleCall) Decode(data0 []byte) error {
	// TODO: Implement decode
	return fmt.Errorf("decode not yet implemented")
}

// EncodeWithSelector encodes testExternalTuple arguments to ABI bytes including function selector
func (t TestExternalTupleCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TestExternalTupleSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const TestFixedArraysCallStaticSize = 320

// TestFixedArraysCall represents an ABI tuple
type TestFixedArraysCall struct {
	Addresses [5]common.Address
	Uints     [3]*big.Int
	Bytes32s  [2][32]byte
}

// EncodedSize returns the total encoded size of TestFixedArraysCall
func (t TestFixedArraysCall) EncodedSize() int {
	dynamicSize := 0

	return TestFixedArraysCallStaticSize + dynamicSize
}

// EncodeTo encodes TestFixedArraysCall to ABI bytes in the provided buffer
func (value TestFixedArraysCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	offset := 0
	var (
		err error
		n   int
	)
	// Field 0: address[5]
	n, err = encode_address_array_5(value.Addresses, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 1: uint256[3]
	n, err = encode_uint256_array_3(value.Uints, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 2: bytes32[2]
	n, err = encode_bytes32_array_2(value.Bytes32s, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// Encode encodes TestFixedArraysCall to ABI bytes
func (t TestFixedArraysCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestFixedArraysCall from ABI bytes in the provided buffer
func (t *TestFixedArraysCall) Decode(data0 []byte) error {
	// TODO: Implement decode
	return fmt.Errorf("decode not yet implemented")
}

// EncodeWithSelector encodes testFixedArrays arguments to ABI bytes including function selector
func (t TestFixedArraysCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TestFixedArraysSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const TestMixedTypesCallStaticSize = 160

// TestMixedTypesCall represents an ABI tuple
type TestMixedTypesCall struct {
	FixedData   [32]byte
	DynamicData []byte
	Flag        bool
	Count       uint8
	Items       []Item
}

// EncodedSize returns the total encoded size of TestMixedTypesCall
func (t TestMixedTypesCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += 32 + abi.Pad32(len(t.DynamicData)) // length + padded bytes data
	dynamicSize += 32 + 32*len(t.Items)               // length + offset pointers for dynamic elements
	for _, elem := range t.Items {
		dynamicSize += elem.EncodedSize() // dynamic tuple
	}

	return TestMixedTypesCallStaticSize + dynamicSize
}

// EncodeTo encodes TestMixedTypesCall to ABI bytes in the provided buffer
func (value TestMixedTypesCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	offset := 0
	var (
		err error
		n   int
	)
	// Field 0: bytes32
	n, err = encode_bytes32(value.FixedData, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 1: bytes
	n, err = encode_bytes(value.DynamicData, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 2: bool
	n, err = encode_bool(value.Flag, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 3: uint8
	n, err = encode_uint8(value.Count, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 4: (uint32,bytes,bool)[]
	n, err = encode_Item_array(value.Items, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// Encode encodes TestMixedTypesCall to ABI bytes
func (t TestMixedTypesCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestMixedTypesCall from ABI bytes in the provided buffer
func (t *TestMixedTypesCall) Decode(data0 []byte) error {
	// TODO: Implement decode
	return fmt.Errorf("decode not yet implemented")
}

// EncodeWithSelector encodes testMixedTypes arguments to ABI bytes including function selector
func (t TestMixedTypesCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TestMixedTypesSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const TestNestedDynamicArraysCallStaticSize = 96

// TestNestedDynamicArraysCall represents an ABI tuple
type TestNestedDynamicArraysCall struct {
	Matrix        [][]*big.Int
	AddressMatrix [][3][]common.Address
	DymMatrix     [][]string
}

// EncodedSize returns the total encoded size of TestNestedDynamicArraysCall
func (t TestNestedDynamicArraysCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += 32 + 32*len(t.Matrix) // length + offset pointers for dynamic elements
	for _, elem := range t.Matrix {
		dynamicSize += 32 + 32*len(elem) // length + static elements
	}
	dynamicSize += 32 + 32*len(t.AddressMatrix) // length + offset pointers for dynamic elements
	for _, elem := range t.AddressMatrix {
		for _, elem := range elem {
			dynamicSize += 32 + 32*len(elem) // length + static elements
		}
	}
	dynamicSize += 32 + 32*len(t.DymMatrix) // length + offset pointers for dynamic elements
	for _, elem := range t.DymMatrix {
		dynamicSize += 32 + 32*len(elem) // length + offset pointers for dynamic elements
		for _, elem := range elem {
			dynamicSize += 32 + abi.Pad32(len(elem)) // length + padded string data
		}
	}

	return TestNestedDynamicArraysCallStaticSize + dynamicSize
}

// EncodeTo encodes TestNestedDynamicArraysCall to ABI bytes in the provided buffer
func (value TestNestedDynamicArraysCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	offset := 0
	var (
		err error
		n   int
	)
	// Field 0: uint256[][]
	n, err = encode_uint256_array_array(value.Matrix, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 1: address[][3][]
	n, err = encode_address_array_array_3_array(value.AddressMatrix, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 2: string[][]
	n, err = encode_string_array_array(value.DymMatrix, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// Encode encodes TestNestedDynamicArraysCall to ABI bytes
func (t TestNestedDynamicArraysCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestNestedDynamicArraysCall from ABI bytes in the provided buffer
func (t *TestNestedDynamicArraysCall) Decode(data0 []byte) error {
	// TODO: Implement decode
	return fmt.Errorf("decode not yet implemented")
}

// EncodeWithSelector encodes testNestedDynamicArrays arguments to ABI bytes including function selector
func (t TestNestedDynamicArraysCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TestNestedDynamicArraysSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const TestNestedStructCallStaticSize = 32

// TestNestedStructCall represents an ABI tuple
type TestNestedStructCall struct {
	Group Group
}

// EncodedSize returns the total encoded size of TestNestedStructCall
func (t TestNestedStructCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.Group.EncodedSize() // dynamic tuple

	return TestNestedStructCallStaticSize + dynamicSize
}

// EncodeTo encodes TestNestedStructCall to ABI bytes in the provided buffer
func (value TestNestedStructCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	offset := 0
	var (
		err error
		n   int
	)
	// Field 0: ((address,string,uint256)[])
	n, err = value.Group.EncodeTo(buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// Encode encodes TestNestedStructCall to ABI bytes
func (t TestNestedStructCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestNestedStructCall from ABI bytes in the provided buffer
func (t *TestNestedStructCall) Decode(data0 []byte) error {
	// TODO: Implement decode
	return fmt.Errorf("decode not yet implemented")
}

// EncodeWithSelector encodes testNestedStruct arguments to ABI bytes including function selector
func (t TestNestedStructCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TestNestedStructSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const TestSmallIntegersCallStaticSize = 256

// TestSmallIntegersCall represents an ABI tuple
type TestSmallIntegersCall struct {
	U8  uint8
	U16 uint16
	U32 uint32
	U64 uint64
	I8  int8
	I16 int16
	I32 int32
	I64 int64
}

// EncodedSize returns the total encoded size of TestSmallIntegersCall
func (t TestSmallIntegersCall) EncodedSize() int {
	dynamicSize := 0

	return TestSmallIntegersCallStaticSize + dynamicSize
}

// EncodeTo encodes TestSmallIntegersCall to ABI bytes in the provided buffer
func (value TestSmallIntegersCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	offset := 0
	var (
		err error
		n   int
	)
	// Field 0: uint8
	n, err = encode_uint8(value.U8, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 1: uint16
	n, err = encode_uint16(value.U16, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 2: uint32
	n, err = encode_uint32(value.U32, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 3: uint64
	n, err = encode_uint64(value.U64, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 4: int8
	n, err = encode_int8(value.I8, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 5: int16
	n, err = encode_int16(value.I16, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 6: int32
	n, err = encode_int32(value.I32, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 7: int64
	n, err = encode_int64(value.I64, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// Encode encodes TestSmallIntegersCall to ABI bytes
func (t TestSmallIntegersCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestSmallIntegersCall from ABI bytes in the provided buffer
func (t *TestSmallIntegersCall) Decode(data0 []byte) error {
	// TODO: Implement decode
	return fmt.Errorf("decode not yet implemented")
}

// EncodeWithSelector encodes testSmallIntegers arguments to ABI bytes including function selector
func (t TestSmallIntegersCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TestSmallIntegersSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}
