// Code generated by go-abi. DO NOT EDIT.

package testdata

import (
	"encoding/binary"
	"fmt"
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/yihuang/go-abi"
)

// Function selectors
var (
	// getAddressStringPair()
	GetAddressStringPairSelector = [4]byte{0xd0, 0xbf, 0x74, 0xea}
	// getComplexNested()
	GetComplexNestedSelector = [4]byte{0xc3, 0xb9, 0xc6, 0x6e}
	// getDeeplyNested()
	GetDeeplyNestedSelector = [4]byte{0xe4, 0xba, 0x61, 0xba}
	// getMultipleReturns()
	GetMultipleReturnsSelector = [4]byte{0x3c, 0xa4, 0x69, 0x27}
	// getNestedTupleArray()
	GetNestedTupleArraySelector = [4]byte{0x94, 0x1b, 0x78, 0xaf}
	// getSimplePair()
	GetSimplePairSelector = [4]byte{0xca, 0x72, 0x93, 0xba}
	// getTupleArray()
	GetTupleArraySelector = [4]byte{0x5b, 0x0a, 0xb4, 0x41}
	// getUserWithMetadata()
	GetUserWithMetadataSelector = [4]byte{0xf4, 0x61, 0x08, 0x78}
	// getUsersArray()
	GetUsersArraySelector = [4]byte{0x99, 0xfe, 0x71, 0xef}
)

// Big endian integer versions of function selectors
const (
	GetAddressStringPairSelectorInt = 3502208234
	GetComplexNestedSelectorInt     = 3283732078
	GetDeeplyNestedSelectorInt      = 3837419962
	GetMultipleReturnsSelectorInt   = 1017407783
	GetNestedTupleArraySelectorInt  = 2484828335
	GetSimplePairSelectorInt        = 3396506554
	GetTupleArraySelectorInt        = 1527428161
	GetUserWithMetadataSelectorInt  = 4099999864
	GetUsersArraySelectorInt        = 2583589359
)

const AddressStringPairStaticSize = 64

// AddressStringPair represents an ABI tuple
type AddressStringPair struct {
	Addr common.Address
	Str  string
}

// EncodedSize returns the total encoded size of AddressStringPair
func (t AddressStringPair) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += 32 + abi.Pad32(len(t.Str)) // length + padded string data

	return AddressStringPairStaticSize + dynamicSize
}

// EncodeTo encodes AddressStringPair to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t AddressStringPair) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := AddressStringPairStaticSize // Start dynamic data after static section

	// Addr (static)
	copy(buf[0+12:0+32], t.Addr[:])

	// Str (offset)
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))

	// Str (dynamic)
	// length
	binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.Str)))
	dynamicOffset += 32

	// data
	copy(buf[dynamicOffset:], []byte(t.Str))
	dynamicOffset += abi.Pad32(len(t.Str))

	return dynamicOffset, nil
}

// Encode encodes AddressStringPair to ABI bytes
func (t AddressStringPair) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// DecodeFrom decodes AddressStringPair from ABI bytes in the provided buffer
func (t *AddressStringPair) DecodeFrom(data0 []byte) error {
	if len(data0) < AddressStringPairStaticSize {
		return fmt.Errorf("insufficient data for AddressStringPair")
	}

	// t.Addr (static)
	copy(t.Addr[:], data0[0+12:0+32])
	// Str
	{
		offset := int(binary.BigEndian.Uint64(data0[32+24 : 32+32]))

		// t.Str (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// string data
		t.Str = string(data0[offset : offset+length])
	}

	return nil
}

// Decode decodes AddressStringPair from ABI bytes
func (t *AddressStringPair) Decode(data []byte) error {
	return t.DecodeFrom(data)
}

const ComplexNestedStaticSize = 128

// ComplexNested represents an ABI tuple
type ComplexNested struct {
	Num  *big.Int
	Addr common.Address
	Str  string
	Data []byte
}

// EncodedSize returns the total encoded size of ComplexNested
func (t ComplexNested) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += 32 + abi.Pad32(len(t.Str))  // length + padded string data
	dynamicSize += 32 + abi.Pad32(len(t.Data)) // length + padded bytes data

	return ComplexNestedStaticSize + dynamicSize
}

// EncodeTo encodes ComplexNested to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t ComplexNested) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := ComplexNestedStaticSize // Start dynamic data after static section

	// Num (static)

	if err := abi.EncodeBigInt(t.Num, buf[0:32], false); err != nil {
		return 0, err
	}

	// Addr (static)
	copy(buf[32+12:32+32], t.Addr[:])

	// Str (offset)
	binary.BigEndian.PutUint64(buf[64+24:64+32], uint64(dynamicOffset))

	// Str (dynamic)
	// length
	binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.Str)))
	dynamicOffset += 32

	// data
	copy(buf[dynamicOffset:], []byte(t.Str))
	dynamicOffset += abi.Pad32(len(t.Str))

	// Data (offset)
	binary.BigEndian.PutUint64(buf[96+24:96+32], uint64(dynamicOffset))

	// Data (dynamic)
	// length
	binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.Data)))
	dynamicOffset += 32

	// data
	copy(buf[dynamicOffset:], t.Data)
	dynamicOffset += abi.Pad32(len(t.Data))

	return dynamicOffset, nil
}

// Encode encodes ComplexNested to ABI bytes
func (t ComplexNested) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// DecodeFrom decodes ComplexNested from ABI bytes in the provided buffer
func (t *ComplexNested) DecodeFrom(data0 []byte) error {
	if len(data0) < ComplexNestedStaticSize {
		return fmt.Errorf("insufficient data for ComplexNested")
	}

	// t.Num (static)
	t.Num = new(big.Int).SetBytes(data0[0:32])
	// t.Addr (static)
	copy(t.Addr[:], data0[32+12:32+32])
	// Str
	{
		offset := int(binary.BigEndian.Uint64(data0[64+24 : 64+32]))

		// t.Str (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// string data
		t.Str = string(data0[offset : offset+length])
	}
	// Data
	{
		offset := int(binary.BigEndian.Uint64(data0[96+24 : 96+32]))

		// t.Data (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// bytes data
		t.Data = data0[offset : offset+length]
	}

	return nil
}

// Decode decodes ComplexNested from ABI bytes
func (t *ComplexNested) Decode(data []byte) error {
	return t.DecodeFrom(data)
}

const DeeplyNestedStaticSize = 160

// DeeplyNested represents an ABI tuple
type DeeplyNested struct {
	Num  *big.Int
	Str  string
	Flag bool
	Addr common.Address
	Hash [32]byte
}

// EncodedSize returns the total encoded size of DeeplyNested
func (t DeeplyNested) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += 32 + abi.Pad32(len(t.Str)) // length + padded string data

	return DeeplyNestedStaticSize + dynamicSize
}

// EncodeTo encodes DeeplyNested to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t DeeplyNested) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := DeeplyNestedStaticSize // Start dynamic data after static section

	// Num (static)

	if err := abi.EncodeBigInt(t.Num, buf[0:32], false); err != nil {
		return 0, err
	}

	// Str (offset)
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))

	// Str (dynamic)
	// length
	binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.Str)))
	dynamicOffset += 32

	// data
	copy(buf[dynamicOffset:], []byte(t.Str))
	dynamicOffset += abi.Pad32(len(t.Str))

	// Flag (static)

	if t.Flag {
		buf[64+31] = 1
	}

	// Addr (static)
	copy(buf[96+12:96+32], t.Addr[:])
	// Hash (static)
	copy(buf[128:128+32], t.Hash[:])

	return dynamicOffset, nil
}

// Encode encodes DeeplyNested to ABI bytes
func (t DeeplyNested) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// DecodeFrom decodes DeeplyNested from ABI bytes in the provided buffer
func (t *DeeplyNested) DecodeFrom(data0 []byte) error {
	if len(data0) < DeeplyNestedStaticSize {
		return fmt.Errorf("insufficient data for DeeplyNested")
	}

	// t.Num (static)
	t.Num = new(big.Int).SetBytes(data0[0:32])
	// Str
	{
		offset := int(binary.BigEndian.Uint64(data0[32+24 : 32+32]))

		// t.Str (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// string data
		t.Str = string(data0[offset : offset+length])
	}
	// t.Flag (static)
	t.Flag = data0[64+31] == 1
	// t.Addr (static)
	copy(t.Addr[:], data0[96+12:96+32])
	// t.Hash (static)
	copy(t.Hash[:], data0[128:128+32])

	return nil
}

// Decode decodes DeeplyNested from ABI bytes
func (t *DeeplyNested) Decode(data []byte) error {
	return t.DecodeFrom(data)
}

const SimplePairStaticSize = 64

// SimplePair represents an ABI tuple
type SimplePair struct {
	First  *big.Int
	Second *big.Int
}

// EncodedSize returns the total encoded size of SimplePair
func (t SimplePair) EncodedSize() int {
	dynamicSize := 0

	return SimplePairStaticSize + dynamicSize
}

// EncodeTo encodes SimplePair to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t SimplePair) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := SimplePairStaticSize // Start dynamic data after static section

	// First (static)

	if err := abi.EncodeBigInt(t.First, buf[0:32], false); err != nil {
		return 0, err
	}

	// Second (static)

	if err := abi.EncodeBigInt(t.Second, buf[32:64], false); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes SimplePair to ABI bytes
func (t SimplePair) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// DecodeFrom decodes SimplePair from ABI bytes in the provided buffer
func (t *SimplePair) DecodeFrom(data0 []byte) error {
	if len(data0) < SimplePairStaticSize {
		return fmt.Errorf("insufficient data for SimplePair")
	}

	// t.First (static)
	t.First = new(big.Int).SetBytes(data0[0:32])
	// t.Second (static)
	t.Second = new(big.Int).SetBytes(data0[32:64])

	return nil
}

// Decode decodes SimplePair from ABI bytes
func (t *SimplePair) Decode(data []byte) error {
	return t.DecodeFrom(data)
}

const UserWithMetadataStaticSize = 128

// UserWithMetadata represents an ABI tuple
type UserWithMetadata struct {
	Name     string
	Id       *big.Int
	Age      *big.Int
	Metadata string
}

// EncodedSize returns the total encoded size of UserWithMetadata
func (t UserWithMetadata) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += 32 + abi.Pad32(len(t.Name))     // length + padded string data
	dynamicSize += 32 + abi.Pad32(len(t.Metadata)) // length + padded string data

	return UserWithMetadataStaticSize + dynamicSize
}

// EncodeTo encodes UserWithMetadata to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t UserWithMetadata) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := UserWithMetadataStaticSize // Start dynamic data after static section

	// Name (offset)
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))

	// Name (dynamic)
	// length
	binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.Name)))
	dynamicOffset += 32

	// data
	copy(buf[dynamicOffset:], []byte(t.Name))
	dynamicOffset += abi.Pad32(len(t.Name))

	// Id (static)

	if err := abi.EncodeBigInt(t.Id, buf[32:64], false); err != nil {
		return 0, err
	}

	// Age (static)

	if err := abi.EncodeBigInt(t.Age, buf[64:96], false); err != nil {
		return 0, err
	}

	// Metadata (offset)
	binary.BigEndian.PutUint64(buf[96+24:96+32], uint64(dynamicOffset))

	// Metadata (dynamic)
	// length
	binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.Metadata)))
	dynamicOffset += 32

	// data
	copy(buf[dynamicOffset:], []byte(t.Metadata))
	dynamicOffset += abi.Pad32(len(t.Metadata))

	return dynamicOffset, nil
}

// Encode encodes UserWithMetadata to ABI bytes
func (t UserWithMetadata) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// DecodeFrom decodes UserWithMetadata from ABI bytes in the provided buffer
func (t *UserWithMetadata) DecodeFrom(data0 []byte) error {
	if len(data0) < UserWithMetadataStaticSize {
		return fmt.Errorf("insufficient data for UserWithMetadata")
	}

	// Name
	{
		offset := int(binary.BigEndian.Uint64(data0[0+24 : 0+32]))

		// t.Name (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// string data
		t.Name = string(data0[offset : offset+length])
	}
	// t.Id (static)
	t.Id = new(big.Int).SetBytes(data0[32:64])
	// t.Age (static)
	t.Age = new(big.Int).SetBytes(data0[64:96])
	// Metadata
	{
		offset := int(binary.BigEndian.Uint64(data0[96+24 : 96+32]))

		// t.Metadata (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// string data
		t.Metadata = string(data0[offset : offset+length])
	}

	return nil
}

// Decode decodes UserWithMetadata from ABI bytes
func (t *UserWithMetadata) Decode(data []byte) error {
	return t.DecodeFrom(data)
}

const GetAddressStringPairReturnStaticSize = 32

// GetAddressStringPairReturn represents an ABI tuple
type GetAddressStringPairReturn struct {
	Result1 AddressStringPair
}

// EncodedSize returns the total encoded size of GetAddressStringPairReturn
func (t GetAddressStringPairReturn) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += t.Result1.EncodedSize() // dynamic tuple

	return GetAddressStringPairReturnStaticSize + dynamicSize
}

// EncodeTo encodes GetAddressStringPairReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t GetAddressStringPairReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := GetAddressStringPairReturnStaticSize // Start dynamic data after static section

	// Result1 (offset)
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))

	// Result1 (dynamic)
	n, err := t.Result1.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes GetAddressStringPairReturn to ABI bytes
func (t GetAddressStringPairReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// DecodeFrom decodes GetAddressStringPairReturn from ABI bytes in the provided buffer
func (t *GetAddressStringPairReturn) DecodeFrom(data0 []byte) error {
	if len(data0) < GetAddressStringPairReturnStaticSize {
		return fmt.Errorf("insufficient data for GetAddressStringPairReturn")
	}

	// Result1
	{
		offset := int(binary.BigEndian.Uint64(data0[0+24 : 0+32]))

		// t.Result1 (dynamic)
		if offset >= len(data0) {
			return fmt.Errorf("insufficient data for dynamic data, t.Result1")
		}
		if err := t.Result1.DecodeFrom(data0[offset:]); err != nil {
			return err
		}
	}

	return nil
}

// Decode decodes GetAddressStringPairReturn from ABI bytes
func (t *GetAddressStringPairReturn) Decode(data []byte) error {
	return t.DecodeFrom(data)
}

const GetComplexNestedReturnStaticSize = 32

// GetComplexNestedReturn represents an ABI tuple
type GetComplexNestedReturn struct {
	Result1 ComplexNested
}

// EncodedSize returns the total encoded size of GetComplexNestedReturn
func (t GetComplexNestedReturn) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += t.Result1.EncodedSize() // dynamic tuple

	return GetComplexNestedReturnStaticSize + dynamicSize
}

// EncodeTo encodes GetComplexNestedReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t GetComplexNestedReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := GetComplexNestedReturnStaticSize // Start dynamic data after static section

	// Result1 (offset)
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))

	// Result1 (dynamic)
	n, err := t.Result1.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes GetComplexNestedReturn to ABI bytes
func (t GetComplexNestedReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// DecodeFrom decodes GetComplexNestedReturn from ABI bytes in the provided buffer
func (t *GetComplexNestedReturn) DecodeFrom(data0 []byte) error {
	if len(data0) < GetComplexNestedReturnStaticSize {
		return fmt.Errorf("insufficient data for GetComplexNestedReturn")
	}

	// Result1
	{
		offset := int(binary.BigEndian.Uint64(data0[0+24 : 0+32]))

		// t.Result1 (dynamic)
		if offset >= len(data0) {
			return fmt.Errorf("insufficient data for dynamic data, t.Result1")
		}
		if err := t.Result1.DecodeFrom(data0[offset:]); err != nil {
			return err
		}
	}

	return nil
}

// Decode decodes GetComplexNestedReturn from ABI bytes
func (t *GetComplexNestedReturn) Decode(data []byte) error {
	return t.DecodeFrom(data)
}

const GetDeeplyNestedReturnStaticSize = 32

// GetDeeplyNestedReturn represents an ABI tuple
type GetDeeplyNestedReturn struct {
	Result1 DeeplyNested
}

// EncodedSize returns the total encoded size of GetDeeplyNestedReturn
func (t GetDeeplyNestedReturn) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += t.Result1.EncodedSize() // dynamic tuple

	return GetDeeplyNestedReturnStaticSize + dynamicSize
}

// EncodeTo encodes GetDeeplyNestedReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t GetDeeplyNestedReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := GetDeeplyNestedReturnStaticSize // Start dynamic data after static section

	// Result1 (offset)
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))

	// Result1 (dynamic)
	n, err := t.Result1.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes GetDeeplyNestedReturn to ABI bytes
func (t GetDeeplyNestedReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// DecodeFrom decodes GetDeeplyNestedReturn from ABI bytes in the provided buffer
func (t *GetDeeplyNestedReturn) DecodeFrom(data0 []byte) error {
	if len(data0) < GetDeeplyNestedReturnStaticSize {
		return fmt.Errorf("insufficient data for GetDeeplyNestedReturn")
	}

	// Result1
	{
		offset := int(binary.BigEndian.Uint64(data0[0+24 : 0+32]))

		// t.Result1 (dynamic)
		if offset >= len(data0) {
			return fmt.Errorf("insufficient data for dynamic data, t.Result1")
		}
		if err := t.Result1.DecodeFrom(data0[offset:]); err != nil {
			return err
		}
	}

	return nil
}

// Decode decodes GetDeeplyNestedReturn from ABI bytes
func (t *GetDeeplyNestedReturn) Decode(data []byte) error {
	return t.DecodeFrom(data)
}

const GetMultipleReturnsReturnStaticSize = 96

// GetMultipleReturnsReturn represents an ABI tuple
type GetMultipleReturnsReturn struct {
	Result1 *big.Int
	Result2 AddressStringPair
	Result3 bool
}

// EncodedSize returns the total encoded size of GetMultipleReturnsReturn
func (t GetMultipleReturnsReturn) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += t.Result2.EncodedSize() // dynamic tuple

	return GetMultipleReturnsReturnStaticSize + dynamicSize
}

// EncodeTo encodes GetMultipleReturnsReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t GetMultipleReturnsReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := GetMultipleReturnsReturnStaticSize // Start dynamic data after static section

	// Result1 (static)

	if err := abi.EncodeBigInt(t.Result1, buf[0:32], false); err != nil {
		return 0, err
	}

	// Result2 (offset)
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))

	// Result2 (dynamic)
	n, err := t.Result2.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Result3 (static)

	if t.Result3 {
		buf[64+31] = 1
	}

	return dynamicOffset, nil
}

// Encode encodes GetMultipleReturnsReturn to ABI bytes
func (t GetMultipleReturnsReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// DecodeFrom decodes GetMultipleReturnsReturn from ABI bytes in the provided buffer
func (t *GetMultipleReturnsReturn) DecodeFrom(data0 []byte) error {
	if len(data0) < GetMultipleReturnsReturnStaticSize {
		return fmt.Errorf("insufficient data for GetMultipleReturnsReturn")
	}

	// t.Result1 (static)
	t.Result1 = new(big.Int).SetBytes(data0[0:32])
	// Result2
	{
		offset := int(binary.BigEndian.Uint64(data0[32+24 : 32+32]))

		// t.Result2 (dynamic)
		if offset >= len(data0) {
			return fmt.Errorf("insufficient data for dynamic data, t.Result2")
		}
		if err := t.Result2.DecodeFrom(data0[offset:]); err != nil {
			return err
		}
	}
	// t.Result3 (static)
	t.Result3 = data0[64+31] == 1

	return nil
}

// Decode decodes GetMultipleReturnsReturn from ABI bytes
func (t *GetMultipleReturnsReturn) Decode(data []byte) error {
	return t.DecodeFrom(data)
}

const GetNestedTupleArrayReturnStaticSize = 32

// GetNestedTupleArrayReturn represents an ABI tuple
type GetNestedTupleArrayReturn struct {
	Result1 []ComplexNested
}

// EncodedSize returns the total encoded size of GetNestedTupleArrayReturn
func (t GetNestedTupleArrayReturn) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += 32 + 32*len(t.Result1) // length + offset pointers for dynamic elements
	for _, elem := range t.Result1 {
		dynamicSize += elem.EncodedSize() // dynamic tuple
	}

	return GetNestedTupleArrayReturnStaticSize + dynamicSize
}

// EncodeTo encodes GetNestedTupleArrayReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t GetNestedTupleArrayReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := GetNestedTupleArrayReturnStaticSize // Start dynamic data after static section

	// Result1 (offset)
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))

	// Result1 (dynamic)
	{
		// length
		binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.Result1)))
		dynamicOffset += 32

		var written int

		// data with dynamic region
		{
			buf := buf[dynamicOffset:]
			dynamicOffset := len(t.Result1) * 32 // start after static region

			var offset int
			for _, item := range t.Result1 {
				// write offsets
				binary.BigEndian.PutUint64(buf[offset+24:offset+32], uint64(dynamicOffset))
				offset += 32

				// write data (dynamic)

				n, err := item.EncodeTo(buf[dynamicOffset:])
				if err != nil {
					return 0, err
				}
				dynamicOffset += n

			}
			written = dynamicOffset
		}
		dynamicOffset += written

	}

	return dynamicOffset, nil
}

// Encode encodes GetNestedTupleArrayReturn to ABI bytes
func (t GetNestedTupleArrayReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// DecodeFrom decodes GetNestedTupleArrayReturn from ABI bytes in the provided buffer
func (t *GetNestedTupleArrayReturn) DecodeFrom(data0 []byte) error {
	if len(data0) < GetNestedTupleArrayReturnStaticSize {
		return fmt.Errorf("insufficient data for GetNestedTupleArrayReturn")
	}

	// Result1
	{
		offset := int(binary.BigEndian.Uint64(data0[0+24 : 0+32]))

		// t.Result1 (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// slice data
		t.Result1 = make([]ComplexNested, length)
		data1 := data0[offset:]

		// Dynamic elements with offsets (dynamic array)
		for i0 := 0; i0 < length; i0++ {
			// Read element offset
			tmp := i0 * 32
			if tmp+32 > len(data1) {
				return fmt.Errorf("insufficient data for element offset")
			}
			offset := int(binary.BigEndian.Uint64(data1[tmp+24 : tmp+32]))
			// Decode dynamic element at offset
			// t.Result1[i0] (dynamic)
			if offset >= len(data1) {
				return fmt.Errorf("insufficient data for dynamic data, t.Result1[i0]")
			}
			if err := t.Result1[i0].DecodeFrom(data1[offset:]); err != nil {
				return err
			}
		}
	}

	return nil
}

// Decode decodes GetNestedTupleArrayReturn from ABI bytes
func (t *GetNestedTupleArrayReturn) Decode(data []byte) error {
	return t.DecodeFrom(data)
}

const GetSimplePairReturnStaticSize = 64

// GetSimplePairReturn represents an ABI tuple
type GetSimplePairReturn struct {
	Result1 SimplePair
}

// EncodedSize returns the total encoded size of GetSimplePairReturn
func (t GetSimplePairReturn) EncodedSize() int {
	dynamicSize := 0

	return GetSimplePairReturnStaticSize + dynamicSize
}

// EncodeTo encodes GetSimplePairReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t GetSimplePairReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := GetSimplePairReturnStaticSize // Start dynamic data after static section

	// Result1 (static)

	// Encode nested tuple t.Result1
	if _, err := t.Result1.EncodeTo(buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes GetSimplePairReturn to ABI bytes
func (t GetSimplePairReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// DecodeFrom decodes GetSimplePairReturn from ABI bytes in the provided buffer
func (t *GetSimplePairReturn) DecodeFrom(data0 []byte) error {
	if len(data0) < GetSimplePairReturnStaticSize {
		return fmt.Errorf("insufficient data for GetSimplePairReturn")
	}

	// t.Result1 (static)
	if err := t.Result1.DecodeFrom(data0[0:64]); err != nil {
		return err
	}

	return nil
}

// Decode decodes GetSimplePairReturn from ABI bytes
func (t *GetSimplePairReturn) Decode(data []byte) error {
	return t.DecodeFrom(data)
}

const GetTupleArrayReturnStaticSize = 32

// GetTupleArrayReturn represents an ABI tuple
type GetTupleArrayReturn struct {
	Result1 []SimplePair
}

// EncodedSize returns the total encoded size of GetTupleArrayReturn
func (t GetTupleArrayReturn) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += 32 + 64*len(t.Result1) // length + static elements

	return GetTupleArrayReturnStaticSize + dynamicSize
}

// EncodeTo encodes GetTupleArrayReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t GetTupleArrayReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := GetTupleArrayReturnStaticSize // Start dynamic data after static section

	// Result1 (offset)
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))

	// Result1 (dynamic)
	{
		// length
		binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.Result1)))
		dynamicOffset += 32

		// data without dynamic region
		buf := buf[dynamicOffset:]
		var offset int
		for _, item := range t.Result1 {

			// Encode nested tuple item
			if _, err := item.EncodeTo(buf[offset:]); err != nil {
				return 0, err
			}

			offset += 64
		}
		dynamicOffset += offset

	}

	return dynamicOffset, nil
}

// Encode encodes GetTupleArrayReturn to ABI bytes
func (t GetTupleArrayReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// DecodeFrom decodes GetTupleArrayReturn from ABI bytes in the provided buffer
func (t *GetTupleArrayReturn) DecodeFrom(data0 []byte) error {
	if len(data0) < GetTupleArrayReturnStaticSize {
		return fmt.Errorf("insufficient data for GetTupleArrayReturn")
	}

	// Result1
	{
		offset := int(binary.BigEndian.Uint64(data0[0+24 : 0+32]))

		// t.Result1 (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// slice data
		t.Result1 = make([]SimplePair, length)
		data1 := data0[offset:]

		offset = 0
		for i0 := 0; i0 < length; i0++ {
			// t.Result1[i0] (static)
			if err := t.Result1[i0].DecodeFrom(data1[offset : offset+64]); err != nil {
				return err
			}
			offset += 64
		}
	}

	return nil
}

// Decode decodes GetTupleArrayReturn from ABI bytes
func (t *GetTupleArrayReturn) Decode(data []byte) error {
	return t.DecodeFrom(data)
}

const GetUserWithMetadataReturnStaticSize = 32

// GetUserWithMetadataReturn represents an ABI tuple
type GetUserWithMetadataReturn struct {
	Result1 UserWithMetadata
}

// EncodedSize returns the total encoded size of GetUserWithMetadataReturn
func (t GetUserWithMetadataReturn) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += t.Result1.EncodedSize() // dynamic tuple

	return GetUserWithMetadataReturnStaticSize + dynamicSize
}

// EncodeTo encodes GetUserWithMetadataReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t GetUserWithMetadataReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := GetUserWithMetadataReturnStaticSize // Start dynamic data after static section

	// Result1 (offset)
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))

	// Result1 (dynamic)
	n, err := t.Result1.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes GetUserWithMetadataReturn to ABI bytes
func (t GetUserWithMetadataReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// DecodeFrom decodes GetUserWithMetadataReturn from ABI bytes in the provided buffer
func (t *GetUserWithMetadataReturn) DecodeFrom(data0 []byte) error {
	if len(data0) < GetUserWithMetadataReturnStaticSize {
		return fmt.Errorf("insufficient data for GetUserWithMetadataReturn")
	}

	// Result1
	{
		offset := int(binary.BigEndian.Uint64(data0[0+24 : 0+32]))

		// t.Result1 (dynamic)
		if offset >= len(data0) {
			return fmt.Errorf("insufficient data for dynamic data, t.Result1")
		}
		if err := t.Result1.DecodeFrom(data0[offset:]); err != nil {
			return err
		}
	}

	return nil
}

// Decode decodes GetUserWithMetadataReturn from ABI bytes
func (t *GetUserWithMetadataReturn) Decode(data []byte) error {
	return t.DecodeFrom(data)
}

const GetUsersArrayReturnStaticSize = 32

// GetUsersArrayReturn represents an ABI tuple
type GetUsersArrayReturn struct {
	Result1 []AddressStringPair
}

// EncodedSize returns the total encoded size of GetUsersArrayReturn
func (t GetUsersArrayReturn) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += 32 + 32*len(t.Result1) // length + offset pointers for dynamic elements
	for _, elem := range t.Result1 {
		dynamicSize += elem.EncodedSize() // dynamic tuple
	}

	return GetUsersArrayReturnStaticSize + dynamicSize
}

// EncodeTo encodes GetUsersArrayReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t GetUsersArrayReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := GetUsersArrayReturnStaticSize // Start dynamic data after static section

	// Result1 (offset)
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))

	// Result1 (dynamic)
	{
		// length
		binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.Result1)))
		dynamicOffset += 32

		var written int

		// data with dynamic region
		{
			buf := buf[dynamicOffset:]
			dynamicOffset := len(t.Result1) * 32 // start after static region

			var offset int
			for _, item := range t.Result1 {
				// write offsets
				binary.BigEndian.PutUint64(buf[offset+24:offset+32], uint64(dynamicOffset))
				offset += 32

				// write data (dynamic)

				n, err := item.EncodeTo(buf[dynamicOffset:])
				if err != nil {
					return 0, err
				}
				dynamicOffset += n

			}
			written = dynamicOffset
		}
		dynamicOffset += written

	}

	return dynamicOffset, nil
}

// Encode encodes GetUsersArrayReturn to ABI bytes
func (t GetUsersArrayReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// DecodeFrom decodes GetUsersArrayReturn from ABI bytes in the provided buffer
func (t *GetUsersArrayReturn) DecodeFrom(data0 []byte) error {
	if len(data0) < GetUsersArrayReturnStaticSize {
		return fmt.Errorf("insufficient data for GetUsersArrayReturn")
	}

	// Result1
	{
		offset := int(binary.BigEndian.Uint64(data0[0+24 : 0+32]))

		// t.Result1 (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// slice data
		t.Result1 = make([]AddressStringPair, length)
		data1 := data0[offset:]

		// Dynamic elements with offsets (dynamic array)
		for i0 := 0; i0 < length; i0++ {
			// Read element offset
			tmp := i0 * 32
			if tmp+32 > len(data1) {
				return fmt.Errorf("insufficient data for element offset")
			}
			offset := int(binary.BigEndian.Uint64(data1[tmp+24 : tmp+32]))
			// Decode dynamic element at offset
			// t.Result1[i0] (dynamic)
			if offset >= len(data1) {
				return fmt.Errorf("insufficient data for dynamic data, t.Result1[i0]")
			}
			if err := t.Result1[i0].DecodeFrom(data1[offset:]); err != nil {
				return err
			}
		}
	}

	return nil
}

// Decode decodes GetUsersArrayReturn from ABI bytes
func (t *GetUsersArrayReturn) Decode(data []byte) error {
	return t.DecodeFrom(data)
}
