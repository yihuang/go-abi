//go:build uint256

// Code generated by go-abi. DO NOT EDIT.

package tests

import (
	"encoding/binary"
	"io"
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/yihuang/go-abi"
)

// Function selectors
var (
	// testComplexDynamicTuples((uint256,(string,string[],(uint256,string[])))[])
	TestComplexDynamicTuplesSelector = [4]byte{0xc0, 0x96, 0x4c, 0x93}
	// testDeeplyNested(((((uint256,string)))))
	TestDeeplyNestedSelector = [4]byte{0x21, 0x75, 0xe8, 0x54}
	// testExternalTuple((address,string,uint256))
	TestExternalTupleSelector = [4]byte{0x96, 0x39, 0x8b, 0x38}
	// testFixedArrays(address[5],uint256[3],bytes32[2])
	TestFixedArraysSelector = [4]byte{0x23, 0xb8, 0x46, 0x5c}
	// testFixedBytes(bytes3,bytes7,bytes15)
	TestFixedBytesSelector = [4]byte{0x45, 0x0f, 0xb2, 0xae}
	// testMixedTypes(bytes32,bytes,bool,uint8,(uint32,bytes,bool)[])
	TestMixedTypesSelector = [4]byte{0x85, 0x8a, 0xe6, 0x15}
	// testNestedDynamicArrays(uint256[][],address[][3][],string[][])
	TestNestedDynamicArraysSelector = [4]byte{0x1a, 0xdd, 0xf6, 0x20}
	// testNestedStruct(((address,string,uint256)[]))
	TestNestedStructSelector = [4]byte{0xe8, 0x3b, 0x85, 0x67}
	// testNonStandardIntegers(uint24,uint48,uint72,uint96,uint120,int24,int48,int72,int96,int120)
	TestNonStandardIntegersSelector = [4]byte{0x70, 0xda, 0xa4, 0x3a}
	// testSmallIntegers(uint8,uint16,uint24,uint32,uint64,int8,int16,int24,int32,int64)
	TestSmallIntegersSelector = [4]byte{0xab, 0xa8, 0x9e, 0xc2}
)

// Big endian integer versions of function selectors
const (
	TestComplexDynamicTuplesID = 3231075475
	TestDeeplyNestedID         = 561375316
	TestExternalTupleID        = 2520353592
	TestFixedArraysID          = 599279196
	TestFixedBytesID           = 1158656686
	TestMixedTypesID           = 2240472597
	TestNestedDynamicArraysID  = 450754080
	TestNestedStructID         = 3896214887
	TestNonStandardIntegersID  = 1893377082
	TestSmallIntegersID        = 2879954626
)

const GroupStaticSize = 32

var _ abi.Tuple = (*Group)(nil)

// Group represents an ABI tuple
type Group struct {
	Users []User
}

// EncodedSize returns the total encoded size of Group
func (t Group) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += SizeUserSlice(t.Users)

	return GroupStaticSize + dynamicSize
}

// EncodeTo encodes Group to ABI bytes in the provided buffer
func (value Group) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := GroupStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Users: (address,string,uint256)[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeUserSlice(value.Users, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes Group to ABI bytes
func (value Group) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Group from ABI bytes in the provided buffer
func (t *Group) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err    error
		n      int
		offset int
	)
	dynamicOffset := 32
	// Decode dynamic field Users
	{
		offset, err = abi.DecodeSize(data[0:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		t.Users, n, err = DecodeUserSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

const ItemStaticSize = 96

var _ abi.Tuple = (*Item)(nil)

// Item represents an ABI tuple
type Item struct {
	Id     uint32
	Data   []byte
	Active bool
}

// EncodedSize returns the total encoded size of Item
func (t Item) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeBytes(t.Data)

	return ItemStaticSize + dynamicSize
}

// EncodeTo encodes Item to ABI bytes in the provided buffer
func (value Item) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := ItemStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Id: uint32
	if _, err := abi.EncodeUint32(value.Id, buf[0:]); err != nil {
		return 0, err
	}

	// Field Data: bytes
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeBytes(value.Data, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Active: bool
	if _, err := abi.EncodeBool(value.Active, buf[64:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes Item to ABI bytes
func (value Item) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Item from ABI bytes in the provided buffer
func (t *Item) Decode(data []byte) (int, error) {
	if len(data) < 96 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err    error
		n      int
		offset int
	)
	dynamicOffset := 96
	// Decode static field Id: uint32
	t.Id, _, err = abi.DecodeUint32(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Data
	{
		offset, err = abi.DecodeSize(data[32:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		t.Data, n, err = abi.DecodeBytes(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode static field Active: bool
	t.Active, _, err = abi.DecodeBool(data[64:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

const Level1StaticSize = 32

var _ abi.Tuple = (*Level1)(nil)

// Level1 represents an ABI tuple
type Level1 struct {
	Level1 Level2
}

// EncodedSize returns the total encoded size of Level1
func (t Level1) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.Level1.EncodedSize()

	return Level1StaticSize + dynamicSize
}

// EncodeTo encodes Level1 to ABI bytes in the provided buffer
func (value Level1) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := Level1StaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Level1: (((uint256,string)))
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.Level1.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes Level1 to ABI bytes
func (value Level1) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Level1 from ABI bytes in the provided buffer
func (t *Level1) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err    error
		n      int
		offset int
	)
	dynamicOffset := 32
	// Decode dynamic field Level1
	{
		offset, err = abi.DecodeSize(data[0:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		n, err = t.Level1.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

const Level2StaticSize = 32

var _ abi.Tuple = (*Level2)(nil)

// Level2 represents an ABI tuple
type Level2 struct {
	Level2 Level3
}

// EncodedSize returns the total encoded size of Level2
func (t Level2) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.Level2.EncodedSize()

	return Level2StaticSize + dynamicSize
}

// EncodeTo encodes Level2 to ABI bytes in the provided buffer
func (value Level2) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := Level2StaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Level2: ((uint256,string))
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.Level2.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes Level2 to ABI bytes
func (value Level2) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Level2 from ABI bytes in the provided buffer
func (t *Level2) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err    error
		n      int
		offset int
	)
	dynamicOffset := 32
	// Decode dynamic field Level2
	{
		offset, err = abi.DecodeSize(data[0:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		n, err = t.Level2.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

const Level3StaticSize = 32

var _ abi.Tuple = (*Level3)(nil)

// Level3 represents an ABI tuple
type Level3 struct {
	Level3 Level4
}

// EncodedSize returns the total encoded size of Level3
func (t Level3) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.Level3.EncodedSize()

	return Level3StaticSize + dynamicSize
}

// EncodeTo encodes Level3 to ABI bytes in the provided buffer
func (value Level3) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := Level3StaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Level3: (uint256,string)
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.Level3.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes Level3 to ABI bytes
func (value Level3) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Level3 from ABI bytes in the provided buffer
func (t *Level3) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err    error
		n      int
		offset int
	)
	dynamicOffset := 32
	// Decode dynamic field Level3
	{
		offset, err = abi.DecodeSize(data[0:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		n, err = t.Level3.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

const Level4StaticSize = 64

var _ abi.Tuple = (*Level4)(nil)

// Level4 represents an ABI tuple
type Level4 struct {
	Value       *big.Int
	Description string
}

// EncodedSize returns the total encoded size of Level4
func (t Level4) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Description)

	return Level4StaticSize + dynamicSize
}

// EncodeTo encodes Level4 to ABI bytes in the provided buffer
func (value Level4) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := Level4StaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Value: uint256
	if _, err := abi.EncodeUint256(value.Value, buf[0:]); err != nil {
		return 0, err
	}

	// Field Description: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Description, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes Level4 to ABI bytes
func (value Level4) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Level4 from ABI bytes in the provided buffer
func (t *Level4) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err    error
		n      int
		offset int
	)
	dynamicOffset := 64
	// Decode static field Value: uint256
	t.Value, _, err = abi.DecodeUint256(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Description
	{
		offset, err = abi.DecodeSize(data[32:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		t.Description, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

const User2StaticSize = 64

var _ abi.Tuple = (*User2)(nil)

// User2 represents an ABI tuple
type User2 struct {
	Id      *big.Int
	Profile UserProfile
}

// EncodedSize returns the total encoded size of User2
func (t User2) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.Profile.EncodedSize()

	return User2StaticSize + dynamicSize
}

// EncodeTo encodes User2 to ABI bytes in the provided buffer
func (value User2) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := User2StaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Id: uint256
	if _, err := abi.EncodeUint256(value.Id, buf[0:]); err != nil {
		return 0, err
	}

	// Field Profile: (string,string[],(uint256,string[]))
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.Profile.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes User2 to ABI bytes
func (value User2) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes User2 from ABI bytes in the provided buffer
func (t *User2) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err    error
		n      int
		offset int
	)
	dynamicOffset := 64
	// Decode static field Id: uint256
	t.Id, _, err = abi.DecodeUint256(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Profile
	{
		offset, err = abi.DecodeSize(data[32:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		n, err = t.Profile.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

const UserMetadata2StaticSize = 64

var _ abi.Tuple = (*UserMetadata2)(nil)

// UserMetadata2 represents an ABI tuple
type UserMetadata2 struct {
	CreatedAt *big.Int
	Tags      []string
}

// EncodedSize returns the total encoded size of UserMetadata2
func (t UserMetadata2) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeStringSlice(t.Tags)

	return UserMetadata2StaticSize + dynamicSize
}

// EncodeTo encodes UserMetadata2 to ABI bytes in the provided buffer
func (value UserMetadata2) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := UserMetadata2StaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field CreatedAt: uint256
	if _, err := abi.EncodeUint256(value.CreatedAt, buf[0:]); err != nil {
		return 0, err
	}

	// Field Tags: string[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeStringSlice(value.Tags, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes UserMetadata2 to ABI bytes
func (value UserMetadata2) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes UserMetadata2 from ABI bytes in the provided buffer
func (t *UserMetadata2) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err    error
		n      int
		offset int
	)
	dynamicOffset := 64
	// Decode static field CreatedAt: uint256
	t.CreatedAt, _, err = abi.DecodeUint256(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Tags
	{
		offset, err = abi.DecodeSize(data[32:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		t.Tags, n, err = abi.DecodeStringSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

const UserProfileStaticSize = 96

var _ abi.Tuple = (*UserProfile)(nil)

// UserProfile represents an ABI tuple
type UserProfile struct {
	Name     string
	Emails   []string
	Metadata UserMetadata2
}

// EncodedSize returns the total encoded size of UserProfile
func (t UserProfile) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Name)
	dynamicSize += abi.SizeStringSlice(t.Emails)
	dynamicSize += t.Metadata.EncodedSize()

	return UserProfileStaticSize + dynamicSize
}

// EncodeTo encodes UserProfile to ABI bytes in the provided buffer
func (value UserProfile) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := UserProfileStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Name: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Name, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Emails: string[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeStringSlice(value.Emails, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Metadata: (uint256,string[])
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[64+24:64+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.Metadata.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes UserProfile to ABI bytes
func (value UserProfile) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes UserProfile from ABI bytes in the provided buffer
func (t *UserProfile) Decode(data []byte) (int, error) {
	if len(data) < 96 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err    error
		n      int
		offset int
	)
	dynamicOffset := 96
	// Decode dynamic field Name
	{
		offset, err = abi.DecodeSize(data[0:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		t.Name, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Emails
	{
		offset, err = abi.DecodeSize(data[32:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		t.Emails, n, err = abi.DecodeStringSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Metadata
	{
		offset, err = abi.DecodeSize(data[64:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		n, err = t.Metadata.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// EncodeAddressArray5 encodes address[5] to ABI bytes
func EncodeAddressArray5(value [5]common.Address, buf []byte) (int, error) {
	// Encode fixed-size array with static elements
	if _, err := abi.EncodeAddress(value[0], buf[0:]); err != nil {
		return 0, err
	}
	if _, err := abi.EncodeAddress(value[1], buf[32:]); err != nil {
		return 0, err
	}
	if _, err := abi.EncodeAddress(value[2], buf[64:]); err != nil {
		return 0, err
	}
	if _, err := abi.EncodeAddress(value[3], buf[96:]); err != nil {
		return 0, err
	}
	if _, err := abi.EncodeAddress(value[4], buf[128:]); err != nil {
		return 0, err
	}

	return 160, nil
}

// EncodeAddressSliceArray3 encodes address[][3] to ABI bytes
func EncodeAddressSliceArray3(value [3][]common.Address, buf []byte) (int, error) {
	// Encode fixed-size array with dynamic elements
	var (
		n   int
		err error
	)
	dynamicOffset := 32 * 3
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	n, err = abi.EncodeAddressSlice(value[0], buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	n, err = abi.EncodeAddressSlice(value[1], buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	binary.BigEndian.PutUint64(buf[64+24:64+32], uint64(dynamicOffset))
	n, err = abi.EncodeAddressSlice(value[2], buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// EncodeAddressSliceArray3Slice encodes address[][3][] to ABI bytes
func EncodeAddressSliceArray3Slice(value [][3][]common.Address, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with dynamic types
	var offset int
	dynamicOffset := len(value) * 32
	for _, elem := range value {
		// Write offset for element
		offset += 32
		binary.BigEndian.PutUint64(buf[offset-8:offset], uint64(dynamicOffset))

		// Write element at dynamic region
		n, err := EncodeAddressSliceArray3(elem, buf[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}

	return dynamicOffset + 32, nil
}

// EncodeBytes32Array2 encodes bytes32[2] to ABI bytes
func EncodeBytes32Array2(value [2][32]byte, buf []byte) (int, error) {
	// Encode fixed-size array with static elements
	if _, err := abi.EncodeBytes32(value[0], buf[0:]); err != nil {
		return 0, err
	}
	if _, err := abi.EncodeBytes32(value[1], buf[32:]); err != nil {
		return 0, err
	}

	return 64, nil
}

// EncodeItemSlice encodes (uint32,bytes,bool)[] to ABI bytes
func EncodeItemSlice(value []Item, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with dynamic types
	var offset int
	dynamicOffset := len(value) * 32
	for _, elem := range value {
		// Write offset for element
		offset += 32
		binary.BigEndian.PutUint64(buf[offset-8:offset], uint64(dynamicOffset))

		// Write element at dynamic region
		n, err := elem.EncodeTo(buf[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}

	return dynamicOffset + 32, nil
}

// EncodeStringSliceSlice encodes string[][] to ABI bytes
func EncodeStringSliceSlice(value [][]string, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with dynamic types
	var offset int
	dynamicOffset := len(value) * 32
	for _, elem := range value {
		// Write offset for element
		offset += 32
		binary.BigEndian.PutUint64(buf[offset-8:offset], uint64(dynamicOffset))

		// Write element at dynamic region
		n, err := abi.EncodeStringSlice(elem, buf[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}

	return dynamicOffset + 32, nil
}

// EncodeUint256Array3 encodes uint256[3] to ABI bytes
func EncodeUint256Array3(value [3]*big.Int, buf []byte) (int, error) {
	// Encode fixed-size array with static elements
	if _, err := abi.EncodeUint256(value[0], buf[0:]); err != nil {
		return 0, err
	}
	if _, err := abi.EncodeUint256(value[1], buf[32:]); err != nil {
		return 0, err
	}
	if _, err := abi.EncodeUint256(value[2], buf[64:]); err != nil {
		return 0, err
	}

	return 96, nil
}

// EncodeUint256SliceSlice encodes uint256[][] to ABI bytes
func EncodeUint256SliceSlice(value [][]*big.Int, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with dynamic types
	var offset int
	dynamicOffset := len(value) * 32
	for _, elem := range value {
		// Write offset for element
		offset += 32
		binary.BigEndian.PutUint64(buf[offset-8:offset], uint64(dynamicOffset))

		// Write element at dynamic region
		n, err := abi.EncodeUint256Slice(elem, buf[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}

	return dynamicOffset + 32, nil
}

// EncodeUser2Slice encodes (uint256,(string,string[],(uint256,string[])))[] to ABI bytes
func EncodeUser2Slice(value []User2, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with dynamic types
	var offset int
	dynamicOffset := len(value) * 32
	for _, elem := range value {
		// Write offset for element
		offset += 32
		binary.BigEndian.PutUint64(buf[offset-8:offset], uint64(dynamicOffset))

		// Write element at dynamic region
		n, err := elem.EncodeTo(buf[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}

	return dynamicOffset + 32, nil
}

// EncodeUserSlice encodes (address,string,uint256)[] to ABI bytes
func EncodeUserSlice(value []User, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with dynamic types
	var offset int
	dynamicOffset := len(value) * 32
	for _, elem := range value {
		// Write offset for element
		offset += 32
		binary.BigEndian.PutUint64(buf[offset-8:offset], uint64(dynamicOffset))

		// Write element at dynamic region
		n, err := elem.EncodeTo(buf[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}

	return dynamicOffset + 32, nil
}

// SizeAddressSliceArray3 returns the encoded size of address[][3]
func SizeAddressSliceArray3(value [3][]common.Address) int {
	size := 32 * 3 // offsets
	size += abi.SizeAddressSlice(value[0])
	size += abi.SizeAddressSlice(value[1])
	size += abi.SizeAddressSlice(value[2])
	return size
}

// SizeAddressSliceArray3Slice returns the encoded size of address[][3][]
func SizeAddressSliceArray3Slice(value [][3][]common.Address) int {
	size := 32 + 32*len(value) // length + offset pointers for dynamic elements
	for _, elem := range value {
		size += SizeAddressSliceArray3(elem)
	}
	return size
}

// SizeItemSlice returns the encoded size of (uint32,bytes,bool)[]
func SizeItemSlice(value []Item) int {
	size := 32 + 32*len(value) // length + offset pointers for dynamic elements
	for _, elem := range value {
		size += elem.EncodedSize()
	}
	return size
}

// SizeStringSliceSlice returns the encoded size of string[][]
func SizeStringSliceSlice(value [][]string) int {
	size := 32 + 32*len(value) // length + offset pointers for dynamic elements
	for _, elem := range value {
		size += abi.SizeStringSlice(elem)
	}
	return size
}

// SizeUint256SliceSlice returns the encoded size of uint256[][]
func SizeUint256SliceSlice(value [][]*big.Int) int {
	size := 32 + 32*len(value) // length + offset pointers for dynamic elements
	for _, elem := range value {
		size += abi.SizeUint256Slice(elem)
	}
	return size
}

// SizeUser2Slice returns the encoded size of (uint256,(string,string[],(uint256,string[])))[]
func SizeUser2Slice(value []User2) int {
	size := 32 + 32*len(value) // length + offset pointers for dynamic elements
	for _, elem := range value {
		size += elem.EncodedSize()
	}
	return size
}

// SizeUserSlice returns the encoded size of (address,string,uint256)[]
func SizeUserSlice(value []User) int {
	size := 32 + 32*len(value) // length + offset pointers for dynamic elements
	for _, elem := range value {
		size += elem.EncodedSize()
	}
	return size
}

// DecodeAddressArray5 decodes address[5] from ABI bytes
func DecodeAddressArray5(data []byte) ([5]common.Address, int, error) {
	// Decode fixed-size array with static elements
	var (
		result [5]common.Address
		err    error
	)
	if len(data) < 160 {
		return result, 0, io.ErrUnexpectedEOF
	}
	// Element 0
	result[0], _, err = abi.DecodeAddress(data[0:])
	if err != nil {
		return result, 0, err
	}
	// Element 1
	result[1], _, err = abi.DecodeAddress(data[32:])
	if err != nil {
		return result, 0, err
	}
	// Element 2
	result[2], _, err = abi.DecodeAddress(data[64:])
	if err != nil {
		return result, 0, err
	}
	// Element 3
	result[3], _, err = abi.DecodeAddress(data[96:])
	if err != nil {
		return result, 0, err
	}
	// Element 4
	result[4], _, err = abi.DecodeAddress(data[128:])
	if err != nil {
		return result, 0, err
	}
	return result, 160, nil
}

// DecodeAddressSliceArray3 decodes address[][3] from ABI bytes
func DecodeAddressSliceArray3(data []byte) ([3][]common.Address, int, error) {
	// Decode fixed-size array with dynamic elements
	var result [3][]common.Address
	if len(data) < 96 {
		return result, 0, io.ErrUnexpectedEOF
	}
	var (
		n   int
		err error
		tmp int
	)
	offset := 0
	dynamicOffset := 96
	for i := 0; i < 3; i++ {
		tmp, err = abi.DecodeSize(data[offset:])
		if err != nil {
			return result, 0, err
		}
		offset += 32

		if dynamicOffset != tmp {
			return result, 0, abi.ErrInvalidOffsetForArrayElement
		}
		result[i], n, err = abi.DecodeAddressSlice(data[dynamicOffset:])
		if err != nil {
			return result, 0, err
		}
		dynamicOffset += n
	}
	return result, dynamicOffset, nil
}

// DecodeAddressSliceArray3Slice decodes address[][3][] from ABI bytes
func DecodeAddressSliceArray3Slice(data []byte) ([][3][]common.Address, int, error) {
	// Decode length
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	length, err := abi.DecodeSize(data)
	if err != nil {
		return nil, 0, err
	}
	data = data[32:]
	if length > len(data) || length*32 > len(data) {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		offset int
	)
	// Decode elements with dynamic types
	result := make([][3][]common.Address, length)
	dynamicOffset := length * 32
	for i := 0; i < length; i++ {
		tmp, err := abi.DecodeSize(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += 32

		if dynamicOffset != tmp {
			return nil, 0, abi.ErrInvalidOffsetForSliceElement
		}
		result[i], n, err = DecodeAddressSliceArray3(data[dynamicOffset:])
		if err != nil {
			return nil, 0, err
		}
		dynamicOffset += n
	}
	return result, dynamicOffset + 32, nil
}

// DecodeBytes32Array2 decodes bytes32[2] from ABI bytes
func DecodeBytes32Array2(data []byte) ([2][32]byte, int, error) {
	// Decode fixed-size array with static elements
	var (
		result [2][32]byte
		err    error
	)
	if len(data) < 64 {
		return result, 0, io.ErrUnexpectedEOF
	}
	// Element 0
	result[0], _, err = abi.DecodeBytes32(data[0:])
	if err != nil {
		return result, 0, err
	}
	// Element 1
	result[1], _, err = abi.DecodeBytes32(data[32:])
	if err != nil {
		return result, 0, err
	}
	return result, 64, nil
}

// DecodeItemSlice decodes (uint32,bytes,bool)[] from ABI bytes
func DecodeItemSlice(data []byte) ([]Item, int, error) {
	// Decode length
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	length, err := abi.DecodeSize(data)
	if err != nil {
		return nil, 0, err
	}
	data = data[32:]
	if length > len(data) || length*32 > len(data) {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		offset int
	)
	// Decode elements with dynamic types
	result := make([]Item, length)
	dynamicOffset := length * 32
	for i := 0; i < length; i++ {
		tmp, err := abi.DecodeSize(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += 32

		if dynamicOffset != tmp {
			return nil, 0, abi.ErrInvalidOffsetForSliceElement
		}
		n, err = result[i].Decode(data[dynamicOffset:])
		if err != nil {
			return nil, 0, err
		}
		dynamicOffset += n
	}
	return result, dynamicOffset + 32, nil
}

// DecodeStringSliceSlice decodes string[][] from ABI bytes
func DecodeStringSliceSlice(data []byte) ([][]string, int, error) {
	// Decode length
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	length, err := abi.DecodeSize(data)
	if err != nil {
		return nil, 0, err
	}
	data = data[32:]
	if length > len(data) || length*32 > len(data) {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		offset int
	)
	// Decode elements with dynamic types
	result := make([][]string, length)
	dynamicOffset := length * 32
	for i := 0; i < length; i++ {
		tmp, err := abi.DecodeSize(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += 32

		if dynamicOffset != tmp {
			return nil, 0, abi.ErrInvalidOffsetForSliceElement
		}
		result[i], n, err = abi.DecodeStringSlice(data[dynamicOffset:])
		if err != nil {
			return nil, 0, err
		}
		dynamicOffset += n
	}
	return result, dynamicOffset + 32, nil
}

// DecodeUint256Array3 decodes uint256[3] from ABI bytes
func DecodeUint256Array3(data []byte) ([3]*big.Int, int, error) {
	// Decode fixed-size array with static elements
	var (
		result [3]*big.Int
		err    error
	)
	if len(data) < 96 {
		return result, 0, io.ErrUnexpectedEOF
	}
	// Element 0
	result[0], _, err = abi.DecodeUint256(data[0:])
	if err != nil {
		return result, 0, err
	}
	// Element 1
	result[1], _, err = abi.DecodeUint256(data[32:])
	if err != nil {
		return result, 0, err
	}
	// Element 2
	result[2], _, err = abi.DecodeUint256(data[64:])
	if err != nil {
		return result, 0, err
	}
	return result, 96, nil
}

// DecodeUint256SliceSlice decodes uint256[][] from ABI bytes
func DecodeUint256SliceSlice(data []byte) ([][]*big.Int, int, error) {
	// Decode length
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	length, err := abi.DecodeSize(data)
	if err != nil {
		return nil, 0, err
	}
	data = data[32:]
	if length > len(data) || length*32 > len(data) {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		offset int
	)
	// Decode elements with dynamic types
	result := make([][]*big.Int, length)
	dynamicOffset := length * 32
	for i := 0; i < length; i++ {
		tmp, err := abi.DecodeSize(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += 32

		if dynamicOffset != tmp {
			return nil, 0, abi.ErrInvalidOffsetForSliceElement
		}
		result[i], n, err = abi.DecodeUint256Slice(data[dynamicOffset:])
		if err != nil {
			return nil, 0, err
		}
		dynamicOffset += n
	}
	return result, dynamicOffset + 32, nil
}

// DecodeUser2Slice decodes (uint256,(string,string[],(uint256,string[])))[] from ABI bytes
func DecodeUser2Slice(data []byte) ([]User2, int, error) {
	// Decode length
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	length, err := abi.DecodeSize(data)
	if err != nil {
		return nil, 0, err
	}
	data = data[32:]
	if length > len(data) || length*32 > len(data) {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		offset int
	)
	// Decode elements with dynamic types
	result := make([]User2, length)
	dynamicOffset := length * 32
	for i := 0; i < length; i++ {
		tmp, err := abi.DecodeSize(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += 32

		if dynamicOffset != tmp {
			return nil, 0, abi.ErrInvalidOffsetForSliceElement
		}
		n, err = result[i].Decode(data[dynamicOffset:])
		if err != nil {
			return nil, 0, err
		}
		dynamicOffset += n
	}
	return result, dynamicOffset + 32, nil
}

// DecodeUserSlice decodes (address,string,uint256)[] from ABI bytes
func DecodeUserSlice(data []byte) ([]User, int, error) {
	// Decode length
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	length, err := abi.DecodeSize(data)
	if err != nil {
		return nil, 0, err
	}
	data = data[32:]
	if length > len(data) || length*32 > len(data) {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		offset int
	)
	// Decode elements with dynamic types
	result := make([]User, length)
	dynamicOffset := length * 32
	for i := 0; i < length; i++ {
		tmp, err := abi.DecodeSize(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += 32

		if dynamicOffset != tmp {
			return nil, 0, abi.ErrInvalidOffsetForSliceElement
		}
		n, err = result[i].Decode(data[dynamicOffset:])
		if err != nil {
			return nil, 0, err
		}
		dynamicOffset += n
	}
	return result, dynamicOffset + 32, nil
}

// PackedEncodeAddressArray5 encodes address[5] to packed ABI bytes (no padding)
func PackedEncodeAddressArray5(value [5]common.Address, buf []byte) (int, error) {
	if len(buf) < 100 {
		return 0, io.ErrShortBuffer
	}
	// Encode fixed-size array elements sequentially (no padding)
	var offset int
	for i := 0; i < 5; i++ {
		n, err := abi.PackedEncodeAddress(value[i], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return 100, nil
}

// PackedEncodeBytes32Array2 encodes bytes32[2] to packed ABI bytes (no padding)
func PackedEncodeBytes32Array2(value [2][32]byte, buf []byte) (int, error) {
	if len(buf) < 64 {
		return 0, io.ErrShortBuffer
	}
	// Encode fixed-size array elements sequentially (no padding)
	var offset int
	for i := 0; i < 2; i++ {
		n, err := abi.PackedEncodeBytes32(value[i], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return 64, nil
}

// PackedEncodeUint256Array3 encodes uint256[3] to packed ABI bytes (no padding)
func PackedEncodeUint256Array3(value [3]*big.Int, buf []byte) (int, error) {
	if len(buf) < 96 {
		return 0, io.ErrShortBuffer
	}
	// Encode fixed-size array elements sequentially (no padding)
	var offset int
	for i := 0; i < 3; i++ {
		n, err := abi.PackedEncodeUint256(value[i], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return 96, nil
}

// PackedDecodeAddressArray5 decodes address[5] from packed ABI bytes (no padding)
func PackedDecodeAddressArray5(data []byte) ([5]common.Address, int, error) {
	if len(data) < 100 {
		return [5]common.Address{}, 0, io.ErrUnexpectedEOF
	}
	var (
		result [5]common.Address
		offset int
		n      int
		err    error
	)
	for i := 0; i < 5; i++ {
		result[i], n, err = abi.PackedDecodeAddress(data[offset:])
		if err != nil {
			return result, 0, err
		}
		offset += n
	}
	return result, 100, nil
}

// PackedDecodeBytes32Array2 decodes bytes32[2] from packed ABI bytes (no padding)
func PackedDecodeBytes32Array2(data []byte) ([2][32]byte, int, error) {
	if len(data) < 64 {
		return [2][32]byte{}, 0, io.ErrUnexpectedEOF
	}
	var (
		result [2][32]byte
		offset int
		n      int
		err    error
	)
	for i := 0; i < 2; i++ {
		result[i], n, err = abi.PackedDecodeBytes32(data[offset:])
		if err != nil {
			return result, 0, err
		}
		offset += n
	}
	return result, 64, nil
}

// PackedDecodeUint256Array3 decodes uint256[3] from packed ABI bytes (no padding)
func PackedDecodeUint256Array3(data []byte) ([3]*big.Int, int, error) {
	if len(data) < 96 {
		return [3]*big.Int{}, 0, io.ErrUnexpectedEOF
	}
	var (
		result [3]*big.Int
		offset int
		n      int
		err    error
	)
	for i := 0; i < 3; i++ {
		result[i], n, err = abi.PackedDecodeUint256(data[offset:])
		if err != nil {
			return result, 0, err
		}
		offset += n
	}
	return result, 96, nil
}

var _ abi.Method = (*TestComplexDynamicTuplesCall)(nil)

const TestComplexDynamicTuplesCallStaticSize = 32

var _ abi.Tuple = (*TestComplexDynamicTuplesCall)(nil)

// TestComplexDynamicTuplesCall represents an ABI tuple
type TestComplexDynamicTuplesCall struct {
	Users []User2
}

// EncodedSize returns the total encoded size of TestComplexDynamicTuplesCall
func (t TestComplexDynamicTuplesCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += SizeUser2Slice(t.Users)

	return TestComplexDynamicTuplesCallStaticSize + dynamicSize
}

// EncodeTo encodes TestComplexDynamicTuplesCall to ABI bytes in the provided buffer
func (value TestComplexDynamicTuplesCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestComplexDynamicTuplesCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Users: (uint256,(string,string[],(uint256,string[])))[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeUser2Slice(value.Users, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes TestComplexDynamicTuplesCall to ABI bytes
func (value TestComplexDynamicTuplesCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestComplexDynamicTuplesCall from ABI bytes in the provided buffer
func (t *TestComplexDynamicTuplesCall) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err    error
		n      int
		offset int
	)
	dynamicOffset := 32
	// Decode dynamic field Users
	{
		offset, err = abi.DecodeSize(data[0:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		t.Users, n, err = DecodeUser2Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t TestComplexDynamicTuplesCall) GetMethodName() string {
	return "testComplexDynamicTuples"
}

// GetMethodID returns the function id
func (t TestComplexDynamicTuplesCall) GetMethodID() uint32 {
	return TestComplexDynamicTuplesID
}

// GetMethodSelector returns the function selector
func (t TestComplexDynamicTuplesCall) GetMethodSelector() [4]byte {
	return TestComplexDynamicTuplesSelector
}

// EncodeWithSelector encodes testComplexDynamicTuples arguments to ABI bytes including function selector
func (t TestComplexDynamicTuplesCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TestComplexDynamicTuplesSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewTestComplexDynamicTuplesCall constructs a new TestComplexDynamicTuplesCall
func NewTestComplexDynamicTuplesCall(
	users []User2,
) *TestComplexDynamicTuplesCall {
	return &TestComplexDynamicTuplesCall{
		Users: users,
	}
}

const TestComplexDynamicTuplesReturnStaticSize = 32

var _ abi.Tuple = (*TestComplexDynamicTuplesReturn)(nil)
var _ abi.PackedTuple = (*TestComplexDynamicTuplesReturn)(nil)

// TestComplexDynamicTuplesReturn represents an ABI tuple
type TestComplexDynamicTuplesReturn struct {
	Field1 bool
}

// EncodedSize returns the total encoded size of TestComplexDynamicTuplesReturn
func (t TestComplexDynamicTuplesReturn) EncodedSize() int {
	dynamicSize := 0

	return TestComplexDynamicTuplesReturnStaticSize + dynamicSize
}

// EncodeTo encodes TestComplexDynamicTuplesReturn to ABI bytes in the provided buffer
func (value TestComplexDynamicTuplesReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestComplexDynamicTuplesReturnStaticSize // Start dynamic data after static section
	// Field Field1: bool
	if _, err := abi.EncodeBool(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TestComplexDynamicTuplesReturn to ABI bytes
func (value TestComplexDynamicTuplesReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestComplexDynamicTuplesReturn from ABI bytes in the provided buffer
func (t *TestComplexDynamicTuplesReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bool
	t.Field1, _, err = abi.DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// PackedEncodedSize returns the packed encoded size of TestComplexDynamicTuplesReturn
func (t TestComplexDynamicTuplesReturn) PackedEncodedSize() int {
	return 1
}

// PackedEncodeTo encodes TestComplexDynamicTuplesReturn to packed ABI bytes in the provided buffer
func (value TestComplexDynamicTuplesReturn) PackedEncodeTo(buf []byte) (int, error) {
	// Encode tuple fields sequentially (packed, no dynamic section)
	var (
		offset int
		n      int
		err    error
	)
	// Field Field1: bool
	n, err = abi.PackedEncodeBool(value.Field1, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// PackedEncode encodes TestComplexDynamicTuplesReturn to packed ABI bytes
func (value TestComplexDynamicTuplesReturn) PackedEncode() ([]byte, error) {
	buf := make([]byte, value.PackedEncodedSize())
	if _, err := value.PackedEncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// PackedDecode decodes TestComplexDynamicTuplesReturn from packed ABI bytes
func (t *TestComplexDynamicTuplesReturn) PackedDecode(data []byte) (int, error) {
	if len(data) < 1 {
		return 0, io.ErrUnexpectedEOF
	}
	var err error
	// Decode field Field1: bool
	t.Field1, _, err = abi.PackedDecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return 1, nil
}

var _ abi.Method = (*TestDeeplyNestedCall)(nil)

const TestDeeplyNestedCallStaticSize = 32

var _ abi.Tuple = (*TestDeeplyNestedCall)(nil)

// TestDeeplyNestedCall represents an ABI tuple
type TestDeeplyNestedCall struct {
	Data Level1
}

// EncodedSize returns the total encoded size of TestDeeplyNestedCall
func (t TestDeeplyNestedCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.Data.EncodedSize()

	return TestDeeplyNestedCallStaticSize + dynamicSize
}

// EncodeTo encodes TestDeeplyNestedCall to ABI bytes in the provided buffer
func (value TestDeeplyNestedCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestDeeplyNestedCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Data: ((((uint256,string))))
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.Data.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes TestDeeplyNestedCall to ABI bytes
func (value TestDeeplyNestedCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestDeeplyNestedCall from ABI bytes in the provided buffer
func (t *TestDeeplyNestedCall) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err    error
		n      int
		offset int
	)
	dynamicOffset := 32
	// Decode dynamic field Data
	{
		offset, err = abi.DecodeSize(data[0:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		n, err = t.Data.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t TestDeeplyNestedCall) GetMethodName() string {
	return "testDeeplyNested"
}

// GetMethodID returns the function id
func (t TestDeeplyNestedCall) GetMethodID() uint32 {
	return TestDeeplyNestedID
}

// GetMethodSelector returns the function selector
func (t TestDeeplyNestedCall) GetMethodSelector() [4]byte {
	return TestDeeplyNestedSelector
}

// EncodeWithSelector encodes testDeeplyNested arguments to ABI bytes including function selector
func (t TestDeeplyNestedCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TestDeeplyNestedSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewTestDeeplyNestedCall constructs a new TestDeeplyNestedCall
func NewTestDeeplyNestedCall(
	data Level1,
) *TestDeeplyNestedCall {
	return &TestDeeplyNestedCall{
		Data: data,
	}
}

const TestDeeplyNestedReturnStaticSize = 32

var _ abi.Tuple = (*TestDeeplyNestedReturn)(nil)
var _ abi.PackedTuple = (*TestDeeplyNestedReturn)(nil)

// TestDeeplyNestedReturn represents an ABI tuple
type TestDeeplyNestedReturn struct {
	Field1 bool
}

// EncodedSize returns the total encoded size of TestDeeplyNestedReturn
func (t TestDeeplyNestedReturn) EncodedSize() int {
	dynamicSize := 0

	return TestDeeplyNestedReturnStaticSize + dynamicSize
}

// EncodeTo encodes TestDeeplyNestedReturn to ABI bytes in the provided buffer
func (value TestDeeplyNestedReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestDeeplyNestedReturnStaticSize // Start dynamic data after static section
	// Field Field1: bool
	if _, err := abi.EncodeBool(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TestDeeplyNestedReturn to ABI bytes
func (value TestDeeplyNestedReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestDeeplyNestedReturn from ABI bytes in the provided buffer
func (t *TestDeeplyNestedReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bool
	t.Field1, _, err = abi.DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// PackedEncodedSize returns the packed encoded size of TestDeeplyNestedReturn
func (t TestDeeplyNestedReturn) PackedEncodedSize() int {
	return 1
}

// PackedEncodeTo encodes TestDeeplyNestedReturn to packed ABI bytes in the provided buffer
func (value TestDeeplyNestedReturn) PackedEncodeTo(buf []byte) (int, error) {
	// Encode tuple fields sequentially (packed, no dynamic section)
	var (
		offset int
		n      int
		err    error
	)
	// Field Field1: bool
	n, err = abi.PackedEncodeBool(value.Field1, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// PackedEncode encodes TestDeeplyNestedReturn to packed ABI bytes
func (value TestDeeplyNestedReturn) PackedEncode() ([]byte, error) {
	buf := make([]byte, value.PackedEncodedSize())
	if _, err := value.PackedEncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// PackedDecode decodes TestDeeplyNestedReturn from packed ABI bytes
func (t *TestDeeplyNestedReturn) PackedDecode(data []byte) (int, error) {
	if len(data) < 1 {
		return 0, io.ErrUnexpectedEOF
	}
	var err error
	// Decode field Field1: bool
	t.Field1, _, err = abi.PackedDecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return 1, nil
}

var _ abi.Method = (*TestExternalTupleCall)(nil)

const TestExternalTupleCallStaticSize = 32

var _ abi.Tuple = (*TestExternalTupleCall)(nil)

// TestExternalTupleCall represents an ABI tuple
type TestExternalTupleCall struct {
	User User
}

// EncodedSize returns the total encoded size of TestExternalTupleCall
func (t TestExternalTupleCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.User.EncodedSize()

	return TestExternalTupleCallStaticSize + dynamicSize
}

// EncodeTo encodes TestExternalTupleCall to ABI bytes in the provided buffer
func (value TestExternalTupleCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestExternalTupleCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field User: (address,string,uint256)
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.User.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes TestExternalTupleCall to ABI bytes
func (value TestExternalTupleCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestExternalTupleCall from ABI bytes in the provided buffer
func (t *TestExternalTupleCall) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err    error
		n      int
		offset int
	)
	dynamicOffset := 32
	// Decode dynamic field User
	{
		offset, err = abi.DecodeSize(data[0:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		n, err = t.User.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t TestExternalTupleCall) GetMethodName() string {
	return "testExternalTuple"
}

// GetMethodID returns the function id
func (t TestExternalTupleCall) GetMethodID() uint32 {
	return TestExternalTupleID
}

// GetMethodSelector returns the function selector
func (t TestExternalTupleCall) GetMethodSelector() [4]byte {
	return TestExternalTupleSelector
}

// EncodeWithSelector encodes testExternalTuple arguments to ABI bytes including function selector
func (t TestExternalTupleCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TestExternalTupleSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewTestExternalTupleCall constructs a new TestExternalTupleCall
func NewTestExternalTupleCall(
	user User,
) *TestExternalTupleCall {
	return &TestExternalTupleCall{
		User: user,
	}
}

const TestExternalTupleReturnStaticSize = 32

var _ abi.Tuple = (*TestExternalTupleReturn)(nil)
var _ abi.PackedTuple = (*TestExternalTupleReturn)(nil)

// TestExternalTupleReturn represents an ABI tuple
type TestExternalTupleReturn struct {
	Field1 bool
}

// EncodedSize returns the total encoded size of TestExternalTupleReturn
func (t TestExternalTupleReturn) EncodedSize() int {
	dynamicSize := 0

	return TestExternalTupleReturnStaticSize + dynamicSize
}

// EncodeTo encodes TestExternalTupleReturn to ABI bytes in the provided buffer
func (value TestExternalTupleReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestExternalTupleReturnStaticSize // Start dynamic data after static section
	// Field Field1: bool
	if _, err := abi.EncodeBool(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TestExternalTupleReturn to ABI bytes
func (value TestExternalTupleReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestExternalTupleReturn from ABI bytes in the provided buffer
func (t *TestExternalTupleReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bool
	t.Field1, _, err = abi.DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// PackedEncodedSize returns the packed encoded size of TestExternalTupleReturn
func (t TestExternalTupleReturn) PackedEncodedSize() int {
	return 1
}

// PackedEncodeTo encodes TestExternalTupleReturn to packed ABI bytes in the provided buffer
func (value TestExternalTupleReturn) PackedEncodeTo(buf []byte) (int, error) {
	// Encode tuple fields sequentially (packed, no dynamic section)
	var (
		offset int
		n      int
		err    error
	)
	// Field Field1: bool
	n, err = abi.PackedEncodeBool(value.Field1, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// PackedEncode encodes TestExternalTupleReturn to packed ABI bytes
func (value TestExternalTupleReturn) PackedEncode() ([]byte, error) {
	buf := make([]byte, value.PackedEncodedSize())
	if _, err := value.PackedEncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// PackedDecode decodes TestExternalTupleReturn from packed ABI bytes
func (t *TestExternalTupleReturn) PackedDecode(data []byte) (int, error) {
	if len(data) < 1 {
		return 0, io.ErrUnexpectedEOF
	}
	var err error
	// Decode field Field1: bool
	t.Field1, _, err = abi.PackedDecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return 1, nil
}

var _ abi.Method = (*TestFixedArraysCall)(nil)

const TestFixedArraysCallStaticSize = 320

var _ abi.Tuple = (*TestFixedArraysCall)(nil)
var _ abi.PackedTuple = (*TestFixedArraysCall)(nil)

// TestFixedArraysCall represents an ABI tuple
type TestFixedArraysCall struct {
	Addresses [5]common.Address
	Uints     [3]*big.Int
	Bytes32s  [2][32]byte
}

// EncodedSize returns the total encoded size of TestFixedArraysCall
func (t TestFixedArraysCall) EncodedSize() int {
	dynamicSize := 0

	return TestFixedArraysCallStaticSize + dynamicSize
}

// EncodeTo encodes TestFixedArraysCall to ABI bytes in the provided buffer
func (value TestFixedArraysCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestFixedArraysCallStaticSize // Start dynamic data after static section
	// Field Addresses: address[5]
	if _, err := EncodeAddressArray5(value.Addresses, buf[0:]); err != nil {
		return 0, err
	}

	// Field Uints: uint256[3]
	if _, err := EncodeUint256Array3(value.Uints, buf[160:]); err != nil {
		return 0, err
	}

	// Field Bytes32s: bytes32[2]
	if _, err := EncodeBytes32Array2(value.Bytes32s, buf[256:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TestFixedArraysCall to ABI bytes
func (value TestFixedArraysCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestFixedArraysCall from ABI bytes in the provided buffer
func (t *TestFixedArraysCall) Decode(data []byte) (int, error) {
	if len(data) < 320 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 320
	// Decode static field Addresses: address[5]
	t.Addresses, _, err = DecodeAddressArray5(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode static field Uints: uint256[3]
	t.Uints, _, err = DecodeUint256Array3(data[160:])
	if err != nil {
		return 0, err
	}
	// Decode static field Bytes32s: bytes32[2]
	t.Bytes32s, _, err = DecodeBytes32Array2(data[256:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// PackedEncodedSize returns the packed encoded size of TestFixedArraysCall
func (t TestFixedArraysCall) PackedEncodedSize() int {
	return 260
}

// PackedEncodeTo encodes TestFixedArraysCall to packed ABI bytes in the provided buffer
func (value TestFixedArraysCall) PackedEncodeTo(buf []byte) (int, error) {
	// Encode tuple fields sequentially (packed, no dynamic section)
	var (
		offset int
		n      int
		err    error
	)
	// Field Addresses: address[5]
	n, err = PackedEncodeAddressArray5(value.Addresses, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field Uints: uint256[3]
	n, err = PackedEncodeUint256Array3(value.Uints, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field Bytes32s: bytes32[2]
	n, err = PackedEncodeBytes32Array2(value.Bytes32s, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// PackedEncode encodes TestFixedArraysCall to packed ABI bytes
func (value TestFixedArraysCall) PackedEncode() ([]byte, error) {
	buf := make([]byte, value.PackedEncodedSize())
	if _, err := value.PackedEncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// PackedDecode decodes TestFixedArraysCall from packed ABI bytes
func (t *TestFixedArraysCall) PackedDecode(data []byte) (int, error) {
	if len(data) < 260 {
		return 0, io.ErrUnexpectedEOF
	}
	var err error
	// Decode field Addresses: address[5]
	t.Addresses, _, err = PackedDecodeAddressArray5(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode field Uints: uint256[3]
	t.Uints, _, err = PackedDecodeUint256Array3(data[100:])
	if err != nil {
		return 0, err
	}
	// Decode field Bytes32s: bytes32[2]
	t.Bytes32s, _, err = PackedDecodeBytes32Array2(data[196:])
	if err != nil {
		return 0, err
	}
	return 260, nil
}

// GetMethodName returns the function name
func (t TestFixedArraysCall) GetMethodName() string {
	return "testFixedArrays"
}

// GetMethodID returns the function id
func (t TestFixedArraysCall) GetMethodID() uint32 {
	return TestFixedArraysID
}

// GetMethodSelector returns the function selector
func (t TestFixedArraysCall) GetMethodSelector() [4]byte {
	return TestFixedArraysSelector
}

// EncodeWithSelector encodes testFixedArrays arguments to ABI bytes including function selector
func (t TestFixedArraysCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TestFixedArraysSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewTestFixedArraysCall constructs a new TestFixedArraysCall
func NewTestFixedArraysCall(
	addresses [5]common.Address,
	uints [3]*big.Int,
	bytes32s [2][32]byte,
) *TestFixedArraysCall {
	return &TestFixedArraysCall{
		Addresses: addresses,
		Uints:     uints,
		Bytes32s:  bytes32s,
	}
}

const TestFixedArraysReturnStaticSize = 32

var _ abi.Tuple = (*TestFixedArraysReturn)(nil)
var _ abi.PackedTuple = (*TestFixedArraysReturn)(nil)

// TestFixedArraysReturn represents an ABI tuple
type TestFixedArraysReturn struct {
	Field1 bool
}

// EncodedSize returns the total encoded size of TestFixedArraysReturn
func (t TestFixedArraysReturn) EncodedSize() int {
	dynamicSize := 0

	return TestFixedArraysReturnStaticSize + dynamicSize
}

// EncodeTo encodes TestFixedArraysReturn to ABI bytes in the provided buffer
func (value TestFixedArraysReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestFixedArraysReturnStaticSize // Start dynamic data after static section
	// Field Field1: bool
	if _, err := abi.EncodeBool(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TestFixedArraysReturn to ABI bytes
func (value TestFixedArraysReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestFixedArraysReturn from ABI bytes in the provided buffer
func (t *TestFixedArraysReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bool
	t.Field1, _, err = abi.DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// PackedEncodedSize returns the packed encoded size of TestFixedArraysReturn
func (t TestFixedArraysReturn) PackedEncodedSize() int {
	return 1
}

// PackedEncodeTo encodes TestFixedArraysReturn to packed ABI bytes in the provided buffer
func (value TestFixedArraysReturn) PackedEncodeTo(buf []byte) (int, error) {
	// Encode tuple fields sequentially (packed, no dynamic section)
	var (
		offset int
		n      int
		err    error
	)
	// Field Field1: bool
	n, err = abi.PackedEncodeBool(value.Field1, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// PackedEncode encodes TestFixedArraysReturn to packed ABI bytes
func (value TestFixedArraysReturn) PackedEncode() ([]byte, error) {
	buf := make([]byte, value.PackedEncodedSize())
	if _, err := value.PackedEncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// PackedDecode decodes TestFixedArraysReturn from packed ABI bytes
func (t *TestFixedArraysReturn) PackedDecode(data []byte) (int, error) {
	if len(data) < 1 {
		return 0, io.ErrUnexpectedEOF
	}
	var err error
	// Decode field Field1: bool
	t.Field1, _, err = abi.PackedDecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return 1, nil
}

var _ abi.Method = (*TestFixedBytesCall)(nil)

const TestFixedBytesCallStaticSize = 96

var _ abi.Tuple = (*TestFixedBytesCall)(nil)
var _ abi.PackedTuple = (*TestFixedBytesCall)(nil)

// TestFixedBytesCall represents an ABI tuple
type TestFixedBytesCall struct {
	Data3  [3]byte
	Data7  [7]byte
	Data15 [15]byte
}

// EncodedSize returns the total encoded size of TestFixedBytesCall
func (t TestFixedBytesCall) EncodedSize() int {
	dynamicSize := 0

	return TestFixedBytesCallStaticSize + dynamicSize
}

// EncodeTo encodes TestFixedBytesCall to ABI bytes in the provided buffer
func (value TestFixedBytesCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestFixedBytesCallStaticSize // Start dynamic data after static section
	// Field Data3: bytes3
	if _, err := abi.EncodeBytes3(value.Data3, buf[0:]); err != nil {
		return 0, err
	}

	// Field Data7: bytes7
	if _, err := abi.EncodeBytes7(value.Data7, buf[32:]); err != nil {
		return 0, err
	}

	// Field Data15: bytes15
	if _, err := abi.EncodeBytes15(value.Data15, buf[64:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TestFixedBytesCall to ABI bytes
func (value TestFixedBytesCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestFixedBytesCall from ABI bytes in the provided buffer
func (t *TestFixedBytesCall) Decode(data []byte) (int, error) {
	if len(data) < 96 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 96
	// Decode static field Data3: bytes3
	t.Data3, _, err = abi.DecodeBytes3(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode static field Data7: bytes7
	t.Data7, _, err = abi.DecodeBytes7(data[32:])
	if err != nil {
		return 0, err
	}
	// Decode static field Data15: bytes15
	t.Data15, _, err = abi.DecodeBytes15(data[64:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// PackedEncodedSize returns the packed encoded size of TestFixedBytesCall
func (t TestFixedBytesCall) PackedEncodedSize() int {
	return 25
}

// PackedEncodeTo encodes TestFixedBytesCall to packed ABI bytes in the provided buffer
func (value TestFixedBytesCall) PackedEncodeTo(buf []byte) (int, error) {
	// Encode tuple fields sequentially (packed, no dynamic section)
	var (
		offset int
		n      int
		err    error
	)
	// Field Data3: bytes3
	n, err = abi.PackedEncodeBytes3(value.Data3, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field Data7: bytes7
	n, err = abi.PackedEncodeBytes7(value.Data7, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field Data15: bytes15
	n, err = abi.PackedEncodeBytes15(value.Data15, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// PackedEncode encodes TestFixedBytesCall to packed ABI bytes
func (value TestFixedBytesCall) PackedEncode() ([]byte, error) {
	buf := make([]byte, value.PackedEncodedSize())
	if _, err := value.PackedEncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// PackedDecode decodes TestFixedBytesCall from packed ABI bytes
func (t *TestFixedBytesCall) PackedDecode(data []byte) (int, error) {
	if len(data) < 25 {
		return 0, io.ErrUnexpectedEOF
	}
	var err error
	// Decode field Data3: bytes3
	t.Data3, _, err = abi.PackedDecodeBytes3(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode field Data7: bytes7
	t.Data7, _, err = abi.PackedDecodeBytes7(data[3:])
	if err != nil {
		return 0, err
	}
	// Decode field Data15: bytes15
	t.Data15, _, err = abi.PackedDecodeBytes15(data[10:])
	if err != nil {
		return 0, err
	}
	return 25, nil
}

// GetMethodName returns the function name
func (t TestFixedBytesCall) GetMethodName() string {
	return "testFixedBytes"
}

// GetMethodID returns the function id
func (t TestFixedBytesCall) GetMethodID() uint32 {
	return TestFixedBytesID
}

// GetMethodSelector returns the function selector
func (t TestFixedBytesCall) GetMethodSelector() [4]byte {
	return TestFixedBytesSelector
}

// EncodeWithSelector encodes testFixedBytes arguments to ABI bytes including function selector
func (t TestFixedBytesCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TestFixedBytesSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewTestFixedBytesCall constructs a new TestFixedBytesCall
func NewTestFixedBytesCall(
	data3 [3]byte,
	data7 [7]byte,
	data15 [15]byte,
) *TestFixedBytesCall {
	return &TestFixedBytesCall{
		Data3:  data3,
		Data7:  data7,
		Data15: data15,
	}
}

const TestFixedBytesReturnStaticSize = 32

var _ abi.Tuple = (*TestFixedBytesReturn)(nil)
var _ abi.PackedTuple = (*TestFixedBytesReturn)(nil)

// TestFixedBytesReturn represents an ABI tuple
type TestFixedBytesReturn struct {
	Field1 [32]byte
}

// EncodedSize returns the total encoded size of TestFixedBytesReturn
func (t TestFixedBytesReturn) EncodedSize() int {
	dynamicSize := 0

	return TestFixedBytesReturnStaticSize + dynamicSize
}

// EncodeTo encodes TestFixedBytesReturn to ABI bytes in the provided buffer
func (value TestFixedBytesReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestFixedBytesReturnStaticSize // Start dynamic data after static section
	// Field Field1: bytes32
	if _, err := abi.EncodeBytes32(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TestFixedBytesReturn to ABI bytes
func (value TestFixedBytesReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestFixedBytesReturn from ABI bytes in the provided buffer
func (t *TestFixedBytesReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bytes32
	t.Field1, _, err = abi.DecodeBytes32(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// PackedEncodedSize returns the packed encoded size of TestFixedBytesReturn
func (t TestFixedBytesReturn) PackedEncodedSize() int {
	return 32
}

// PackedEncodeTo encodes TestFixedBytesReturn to packed ABI bytes in the provided buffer
func (value TestFixedBytesReturn) PackedEncodeTo(buf []byte) (int, error) {
	// Encode tuple fields sequentially (packed, no dynamic section)
	var (
		offset int
		n      int
		err    error
	)
	// Field Field1: bytes32
	n, err = abi.PackedEncodeBytes32(value.Field1, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// PackedEncode encodes TestFixedBytesReturn to packed ABI bytes
func (value TestFixedBytesReturn) PackedEncode() ([]byte, error) {
	buf := make([]byte, value.PackedEncodedSize())
	if _, err := value.PackedEncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// PackedDecode decodes TestFixedBytesReturn from packed ABI bytes
func (t *TestFixedBytesReturn) PackedDecode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var err error
	// Decode field Field1: bytes32
	t.Field1, _, err = abi.PackedDecodeBytes32(data[0:])
	if err != nil {
		return 0, err
	}
	return 32, nil
}

var _ abi.Method = (*TestMixedTypesCall)(nil)

const TestMixedTypesCallStaticSize = 160

var _ abi.Tuple = (*TestMixedTypesCall)(nil)

// TestMixedTypesCall represents an ABI tuple
type TestMixedTypesCall struct {
	FixedData   [32]byte
	DynamicData []byte
	Flag        bool
	Count       uint8
	Items       []Item
}

// EncodedSize returns the total encoded size of TestMixedTypesCall
func (t TestMixedTypesCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeBytes(t.DynamicData)
	dynamicSize += SizeItemSlice(t.Items)

	return TestMixedTypesCallStaticSize + dynamicSize
}

// EncodeTo encodes TestMixedTypesCall to ABI bytes in the provided buffer
func (value TestMixedTypesCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestMixedTypesCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field FixedData: bytes32
	if _, err := abi.EncodeBytes32(value.FixedData, buf[0:]); err != nil {
		return 0, err
	}

	// Field DynamicData: bytes
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeBytes(value.DynamicData, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Flag: bool
	if _, err := abi.EncodeBool(value.Flag, buf[64:]); err != nil {
		return 0, err
	}

	// Field Count: uint8
	if _, err := abi.EncodeUint8(value.Count, buf[96:]); err != nil {
		return 0, err
	}

	// Field Items: (uint32,bytes,bool)[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[128+24:128+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeItemSlice(value.Items, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes TestMixedTypesCall to ABI bytes
func (value TestMixedTypesCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestMixedTypesCall from ABI bytes in the provided buffer
func (t *TestMixedTypesCall) Decode(data []byte) (int, error) {
	if len(data) < 160 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err    error
		n      int
		offset int
	)
	dynamicOffset := 160
	// Decode static field FixedData: bytes32
	t.FixedData, _, err = abi.DecodeBytes32(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field DynamicData
	{
		offset, err = abi.DecodeSize(data[32:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		t.DynamicData, n, err = abi.DecodeBytes(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode static field Flag: bool
	t.Flag, _, err = abi.DecodeBool(data[64:])
	if err != nil {
		return 0, err
	}
	// Decode static field Count: uint8
	t.Count, _, err = abi.DecodeUint8(data[96:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Items
	{
		offset, err = abi.DecodeSize(data[128:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		t.Items, n, err = DecodeItemSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t TestMixedTypesCall) GetMethodName() string {
	return "testMixedTypes"
}

// GetMethodID returns the function id
func (t TestMixedTypesCall) GetMethodID() uint32 {
	return TestMixedTypesID
}

// GetMethodSelector returns the function selector
func (t TestMixedTypesCall) GetMethodSelector() [4]byte {
	return TestMixedTypesSelector
}

// EncodeWithSelector encodes testMixedTypes arguments to ABI bytes including function selector
func (t TestMixedTypesCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TestMixedTypesSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewTestMixedTypesCall constructs a new TestMixedTypesCall
func NewTestMixedTypesCall(
	fixedData [32]byte,
	dynamicData []byte,
	flag bool,
	count uint8,
	items []Item,
) *TestMixedTypesCall {
	return &TestMixedTypesCall{
		FixedData:   fixedData,
		DynamicData: dynamicData,
		Flag:        flag,
		Count:       count,
		Items:       items,
	}
}

const TestMixedTypesReturnStaticSize = 32

var _ abi.Tuple = (*TestMixedTypesReturn)(nil)
var _ abi.PackedTuple = (*TestMixedTypesReturn)(nil)

// TestMixedTypesReturn represents an ABI tuple
type TestMixedTypesReturn struct {
	Field1 bool
}

// EncodedSize returns the total encoded size of TestMixedTypesReturn
func (t TestMixedTypesReturn) EncodedSize() int {
	dynamicSize := 0

	return TestMixedTypesReturnStaticSize + dynamicSize
}

// EncodeTo encodes TestMixedTypesReturn to ABI bytes in the provided buffer
func (value TestMixedTypesReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestMixedTypesReturnStaticSize // Start dynamic data after static section
	// Field Field1: bool
	if _, err := abi.EncodeBool(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TestMixedTypesReturn to ABI bytes
func (value TestMixedTypesReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestMixedTypesReturn from ABI bytes in the provided buffer
func (t *TestMixedTypesReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bool
	t.Field1, _, err = abi.DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// PackedEncodedSize returns the packed encoded size of TestMixedTypesReturn
func (t TestMixedTypesReturn) PackedEncodedSize() int {
	return 1
}

// PackedEncodeTo encodes TestMixedTypesReturn to packed ABI bytes in the provided buffer
func (value TestMixedTypesReturn) PackedEncodeTo(buf []byte) (int, error) {
	// Encode tuple fields sequentially (packed, no dynamic section)
	var (
		offset int
		n      int
		err    error
	)
	// Field Field1: bool
	n, err = abi.PackedEncodeBool(value.Field1, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// PackedEncode encodes TestMixedTypesReturn to packed ABI bytes
func (value TestMixedTypesReturn) PackedEncode() ([]byte, error) {
	buf := make([]byte, value.PackedEncodedSize())
	if _, err := value.PackedEncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// PackedDecode decodes TestMixedTypesReturn from packed ABI bytes
func (t *TestMixedTypesReturn) PackedDecode(data []byte) (int, error) {
	if len(data) < 1 {
		return 0, io.ErrUnexpectedEOF
	}
	var err error
	// Decode field Field1: bool
	t.Field1, _, err = abi.PackedDecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return 1, nil
}

var _ abi.Method = (*TestNestedDynamicArraysCall)(nil)

const TestNestedDynamicArraysCallStaticSize = 96

var _ abi.Tuple = (*TestNestedDynamicArraysCall)(nil)

// TestNestedDynamicArraysCall represents an ABI tuple
type TestNestedDynamicArraysCall struct {
	Matrix        [][]*big.Int
	AddressMatrix [][3][]common.Address
	DymMatrix     [][]string
}

// EncodedSize returns the total encoded size of TestNestedDynamicArraysCall
func (t TestNestedDynamicArraysCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += SizeUint256SliceSlice(t.Matrix)
	dynamicSize += SizeAddressSliceArray3Slice(t.AddressMatrix)
	dynamicSize += SizeStringSliceSlice(t.DymMatrix)

	return TestNestedDynamicArraysCallStaticSize + dynamicSize
}

// EncodeTo encodes TestNestedDynamicArraysCall to ABI bytes in the provided buffer
func (value TestNestedDynamicArraysCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestNestedDynamicArraysCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Matrix: uint256[][]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeUint256SliceSlice(value.Matrix, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field AddressMatrix: address[][3][]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeAddressSliceArray3Slice(value.AddressMatrix, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field DymMatrix: string[][]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[64+24:64+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeStringSliceSlice(value.DymMatrix, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes TestNestedDynamicArraysCall to ABI bytes
func (value TestNestedDynamicArraysCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestNestedDynamicArraysCall from ABI bytes in the provided buffer
func (t *TestNestedDynamicArraysCall) Decode(data []byte) (int, error) {
	if len(data) < 96 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err    error
		n      int
		offset int
	)
	dynamicOffset := 96
	// Decode dynamic field Matrix
	{
		offset, err = abi.DecodeSize(data[0:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		t.Matrix, n, err = DecodeUint256SliceSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field AddressMatrix
	{
		offset, err = abi.DecodeSize(data[32:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		t.AddressMatrix, n, err = DecodeAddressSliceArray3Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field DymMatrix
	{
		offset, err = abi.DecodeSize(data[64:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		t.DymMatrix, n, err = DecodeStringSliceSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t TestNestedDynamicArraysCall) GetMethodName() string {
	return "testNestedDynamicArrays"
}

// GetMethodID returns the function id
func (t TestNestedDynamicArraysCall) GetMethodID() uint32 {
	return TestNestedDynamicArraysID
}

// GetMethodSelector returns the function selector
func (t TestNestedDynamicArraysCall) GetMethodSelector() [4]byte {
	return TestNestedDynamicArraysSelector
}

// EncodeWithSelector encodes testNestedDynamicArrays arguments to ABI bytes including function selector
func (t TestNestedDynamicArraysCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TestNestedDynamicArraysSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewTestNestedDynamicArraysCall constructs a new TestNestedDynamicArraysCall
func NewTestNestedDynamicArraysCall(
	matrix [][]*big.Int,
	addressMatrix [][3][]common.Address,
	dymMatrix [][]string,
) *TestNestedDynamicArraysCall {
	return &TestNestedDynamicArraysCall{
		Matrix:        matrix,
		AddressMatrix: addressMatrix,
		DymMatrix:     dymMatrix,
	}
}

const TestNestedDynamicArraysReturnStaticSize = 32

var _ abi.Tuple = (*TestNestedDynamicArraysReturn)(nil)
var _ abi.PackedTuple = (*TestNestedDynamicArraysReturn)(nil)

// TestNestedDynamicArraysReturn represents an ABI tuple
type TestNestedDynamicArraysReturn struct {
	Field1 bool
}

// EncodedSize returns the total encoded size of TestNestedDynamicArraysReturn
func (t TestNestedDynamicArraysReturn) EncodedSize() int {
	dynamicSize := 0

	return TestNestedDynamicArraysReturnStaticSize + dynamicSize
}

// EncodeTo encodes TestNestedDynamicArraysReturn to ABI bytes in the provided buffer
func (value TestNestedDynamicArraysReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestNestedDynamicArraysReturnStaticSize // Start dynamic data after static section
	// Field Field1: bool
	if _, err := abi.EncodeBool(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TestNestedDynamicArraysReturn to ABI bytes
func (value TestNestedDynamicArraysReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestNestedDynamicArraysReturn from ABI bytes in the provided buffer
func (t *TestNestedDynamicArraysReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bool
	t.Field1, _, err = abi.DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// PackedEncodedSize returns the packed encoded size of TestNestedDynamicArraysReturn
func (t TestNestedDynamicArraysReturn) PackedEncodedSize() int {
	return 1
}

// PackedEncodeTo encodes TestNestedDynamicArraysReturn to packed ABI bytes in the provided buffer
func (value TestNestedDynamicArraysReturn) PackedEncodeTo(buf []byte) (int, error) {
	// Encode tuple fields sequentially (packed, no dynamic section)
	var (
		offset int
		n      int
		err    error
	)
	// Field Field1: bool
	n, err = abi.PackedEncodeBool(value.Field1, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// PackedEncode encodes TestNestedDynamicArraysReturn to packed ABI bytes
func (value TestNestedDynamicArraysReturn) PackedEncode() ([]byte, error) {
	buf := make([]byte, value.PackedEncodedSize())
	if _, err := value.PackedEncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// PackedDecode decodes TestNestedDynamicArraysReturn from packed ABI bytes
func (t *TestNestedDynamicArraysReturn) PackedDecode(data []byte) (int, error) {
	if len(data) < 1 {
		return 0, io.ErrUnexpectedEOF
	}
	var err error
	// Decode field Field1: bool
	t.Field1, _, err = abi.PackedDecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return 1, nil
}

var _ abi.Method = (*TestNestedStructCall)(nil)

const TestNestedStructCallStaticSize = 32

var _ abi.Tuple = (*TestNestedStructCall)(nil)

// TestNestedStructCall represents an ABI tuple
type TestNestedStructCall struct {
	Group Group
}

// EncodedSize returns the total encoded size of TestNestedStructCall
func (t TestNestedStructCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.Group.EncodedSize()

	return TestNestedStructCallStaticSize + dynamicSize
}

// EncodeTo encodes TestNestedStructCall to ABI bytes in the provided buffer
func (value TestNestedStructCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestNestedStructCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Group: ((address,string,uint256)[])
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.Group.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes TestNestedStructCall to ABI bytes
func (value TestNestedStructCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestNestedStructCall from ABI bytes in the provided buffer
func (t *TestNestedStructCall) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err    error
		n      int
		offset int
	)
	dynamicOffset := 32
	// Decode dynamic field Group
	{
		offset, err = abi.DecodeSize(data[0:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		n, err = t.Group.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t TestNestedStructCall) GetMethodName() string {
	return "testNestedStruct"
}

// GetMethodID returns the function id
func (t TestNestedStructCall) GetMethodID() uint32 {
	return TestNestedStructID
}

// GetMethodSelector returns the function selector
func (t TestNestedStructCall) GetMethodSelector() [4]byte {
	return TestNestedStructSelector
}

// EncodeWithSelector encodes testNestedStruct arguments to ABI bytes including function selector
func (t TestNestedStructCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TestNestedStructSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewTestNestedStructCall constructs a new TestNestedStructCall
func NewTestNestedStructCall(
	group Group,
) *TestNestedStructCall {
	return &TestNestedStructCall{
		Group: group,
	}
}

const TestNestedStructReturnStaticSize = 32

var _ abi.Tuple = (*TestNestedStructReturn)(nil)
var _ abi.PackedTuple = (*TestNestedStructReturn)(nil)

// TestNestedStructReturn represents an ABI tuple
type TestNestedStructReturn struct {
	Field1 bool
}

// EncodedSize returns the total encoded size of TestNestedStructReturn
func (t TestNestedStructReturn) EncodedSize() int {
	dynamicSize := 0

	return TestNestedStructReturnStaticSize + dynamicSize
}

// EncodeTo encodes TestNestedStructReturn to ABI bytes in the provided buffer
func (value TestNestedStructReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestNestedStructReturnStaticSize // Start dynamic data after static section
	// Field Field1: bool
	if _, err := abi.EncodeBool(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TestNestedStructReturn to ABI bytes
func (value TestNestedStructReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestNestedStructReturn from ABI bytes in the provided buffer
func (t *TestNestedStructReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bool
	t.Field1, _, err = abi.DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// PackedEncodedSize returns the packed encoded size of TestNestedStructReturn
func (t TestNestedStructReturn) PackedEncodedSize() int {
	return 1
}

// PackedEncodeTo encodes TestNestedStructReturn to packed ABI bytes in the provided buffer
func (value TestNestedStructReturn) PackedEncodeTo(buf []byte) (int, error) {
	// Encode tuple fields sequentially (packed, no dynamic section)
	var (
		offset int
		n      int
		err    error
	)
	// Field Field1: bool
	n, err = abi.PackedEncodeBool(value.Field1, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// PackedEncode encodes TestNestedStructReturn to packed ABI bytes
func (value TestNestedStructReturn) PackedEncode() ([]byte, error) {
	buf := make([]byte, value.PackedEncodedSize())
	if _, err := value.PackedEncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// PackedDecode decodes TestNestedStructReturn from packed ABI bytes
func (t *TestNestedStructReturn) PackedDecode(data []byte) (int, error) {
	if len(data) < 1 {
		return 0, io.ErrUnexpectedEOF
	}
	var err error
	// Decode field Field1: bool
	t.Field1, _, err = abi.PackedDecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return 1, nil
}

var _ abi.Method = (*TestNonStandardIntegersCall)(nil)

const TestNonStandardIntegersCallStaticSize = 320

var _ abi.Tuple = (*TestNonStandardIntegersCall)(nil)
var _ abi.PackedTuple = (*TestNonStandardIntegersCall)(nil)

// TestNonStandardIntegersCall represents an ABI tuple
type TestNonStandardIntegersCall struct {
	U24  uint32
	U48  uint64
	U72  *big.Int
	U96  *big.Int
	U120 *big.Int
	I24  int32
	I48  int64
	I72  *big.Int
	I96  *big.Int
	I120 *big.Int
}

// EncodedSize returns the total encoded size of TestNonStandardIntegersCall
func (t TestNonStandardIntegersCall) EncodedSize() int {
	dynamicSize := 0

	return TestNonStandardIntegersCallStaticSize + dynamicSize
}

// EncodeTo encodes TestNonStandardIntegersCall to ABI bytes in the provided buffer
func (value TestNonStandardIntegersCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestNonStandardIntegersCallStaticSize // Start dynamic data after static section
	// Field U24: uint24
	if _, err := abi.EncodeUint24(value.U24, buf[0:]); err != nil {
		return 0, err
	}

	// Field U48: uint48
	if _, err := abi.EncodeUint48(value.U48, buf[32:]); err != nil {
		return 0, err
	}

	// Field U72: uint72
	if _, err := abi.EncodeUint72(value.U72, buf[64:]); err != nil {
		return 0, err
	}

	// Field U96: uint96
	if _, err := abi.EncodeUint96(value.U96, buf[96:]); err != nil {
		return 0, err
	}

	// Field U120: uint120
	if _, err := abi.EncodeUint120(value.U120, buf[128:]); err != nil {
		return 0, err
	}

	// Field I24: int24
	if _, err := abi.EncodeInt24(value.I24, buf[160:]); err != nil {
		return 0, err
	}

	// Field I48: int48
	if _, err := abi.EncodeInt48(value.I48, buf[192:]); err != nil {
		return 0, err
	}

	// Field I72: int72
	if _, err := abi.EncodeInt72(value.I72, buf[224:]); err != nil {
		return 0, err
	}

	// Field I96: int96
	if _, err := abi.EncodeInt96(value.I96, buf[256:]); err != nil {
		return 0, err
	}

	// Field I120: int120
	if _, err := abi.EncodeInt120(value.I120, buf[288:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TestNonStandardIntegersCall to ABI bytes
func (value TestNonStandardIntegersCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestNonStandardIntegersCall from ABI bytes in the provided buffer
func (t *TestNonStandardIntegersCall) Decode(data []byte) (int, error) {
	if len(data) < 320 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 320
	// Decode static field U24: uint24
	t.U24, _, err = abi.DecodeUint24(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode static field U48: uint48
	t.U48, _, err = abi.DecodeUint48(data[32:])
	if err != nil {
		return 0, err
	}
	// Decode static field U72: uint72
	t.U72, _, err = abi.DecodeUint72(data[64:])
	if err != nil {
		return 0, err
	}
	// Decode static field U96: uint96
	t.U96, _, err = abi.DecodeUint96(data[96:])
	if err != nil {
		return 0, err
	}
	// Decode static field U120: uint120
	t.U120, _, err = abi.DecodeUint120(data[128:])
	if err != nil {
		return 0, err
	}
	// Decode static field I24: int24
	t.I24, _, err = abi.DecodeInt24(data[160:])
	if err != nil {
		return 0, err
	}
	// Decode static field I48: int48
	t.I48, _, err = abi.DecodeInt48(data[192:])
	if err != nil {
		return 0, err
	}
	// Decode static field I72: int72
	t.I72, _, err = abi.DecodeInt72(data[224:])
	if err != nil {
		return 0, err
	}
	// Decode static field I96: int96
	t.I96, _, err = abi.DecodeInt96(data[256:])
	if err != nil {
		return 0, err
	}
	// Decode static field I120: int120
	t.I120, _, err = abi.DecodeInt120(data[288:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// PackedEncodedSize returns the packed encoded size of TestNonStandardIntegersCall
func (t TestNonStandardIntegersCall) PackedEncodedSize() int {
	return 90
}

// PackedEncodeTo encodes TestNonStandardIntegersCall to packed ABI bytes in the provided buffer
func (value TestNonStandardIntegersCall) PackedEncodeTo(buf []byte) (int, error) {
	// Encode tuple fields sequentially (packed, no dynamic section)
	var (
		offset int
		n      int
		err    error
	)
	// Field U24: uint24
	n, err = abi.PackedEncodeUint24(value.U24, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field U48: uint48
	n, err = abi.PackedEncodeUint48(value.U48, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field U72: uint72
	n, err = abi.PackedEncodeUint72(value.U72, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field U96: uint96
	n, err = abi.PackedEncodeUint96(value.U96, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field U120: uint120
	n, err = abi.PackedEncodeUint120(value.U120, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field I24: int24
	n, err = abi.PackedEncodeInt24(value.I24, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field I48: int48
	n, err = abi.PackedEncodeInt48(value.I48, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field I72: int72
	n, err = abi.PackedEncodeInt72(value.I72, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field I96: int96
	n, err = abi.PackedEncodeInt96(value.I96, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field I120: int120
	n, err = abi.PackedEncodeInt120(value.I120, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// PackedEncode encodes TestNonStandardIntegersCall to packed ABI bytes
func (value TestNonStandardIntegersCall) PackedEncode() ([]byte, error) {
	buf := make([]byte, value.PackedEncodedSize())
	if _, err := value.PackedEncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// PackedDecode decodes TestNonStandardIntegersCall from packed ABI bytes
func (t *TestNonStandardIntegersCall) PackedDecode(data []byte) (int, error) {
	if len(data) < 90 {
		return 0, io.ErrUnexpectedEOF
	}
	var err error
	// Decode field U24: uint24
	t.U24, _, err = abi.PackedDecodeUint24(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode field U48: uint48
	t.U48, _, err = abi.PackedDecodeUint48(data[3:])
	if err != nil {
		return 0, err
	}
	// Decode field U72: uint72
	t.U72, _, err = abi.PackedDecodeUint72(data[9:])
	if err != nil {
		return 0, err
	}
	// Decode field U96: uint96
	t.U96, _, err = abi.PackedDecodeUint96(data[18:])
	if err != nil {
		return 0, err
	}
	// Decode field U120: uint120
	t.U120, _, err = abi.PackedDecodeUint120(data[30:])
	if err != nil {
		return 0, err
	}
	// Decode field I24: int24
	t.I24, _, err = abi.PackedDecodeInt24(data[45:])
	if err != nil {
		return 0, err
	}
	// Decode field I48: int48
	t.I48, _, err = abi.PackedDecodeInt48(data[48:])
	if err != nil {
		return 0, err
	}
	// Decode field I72: int72
	t.I72, _, err = abi.PackedDecodeInt72(data[54:])
	if err != nil {
		return 0, err
	}
	// Decode field I96: int96
	t.I96, _, err = abi.PackedDecodeInt96(data[63:])
	if err != nil {
		return 0, err
	}
	// Decode field I120: int120
	t.I120, _, err = abi.PackedDecodeInt120(data[75:])
	if err != nil {
		return 0, err
	}
	return 90, nil
}

// GetMethodName returns the function name
func (t TestNonStandardIntegersCall) GetMethodName() string {
	return "testNonStandardIntegers"
}

// GetMethodID returns the function id
func (t TestNonStandardIntegersCall) GetMethodID() uint32 {
	return TestNonStandardIntegersID
}

// GetMethodSelector returns the function selector
func (t TestNonStandardIntegersCall) GetMethodSelector() [4]byte {
	return TestNonStandardIntegersSelector
}

// EncodeWithSelector encodes testNonStandardIntegers arguments to ABI bytes including function selector
func (t TestNonStandardIntegersCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TestNonStandardIntegersSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewTestNonStandardIntegersCall constructs a new TestNonStandardIntegersCall
func NewTestNonStandardIntegersCall(
	u24 uint32,
	u48 uint64,
	u72 *big.Int,
	u96 *big.Int,
	u120 *big.Int,
	i24 int32,
	i48 int64,
	i72 *big.Int,
	i96 *big.Int,
	i120 *big.Int,
) *TestNonStandardIntegersCall {
	return &TestNonStandardIntegersCall{
		U24:  u24,
		U48:  u48,
		U72:  u72,
		U96:  u96,
		U120: u120,
		I24:  i24,
		I48:  i48,
		I72:  i72,
		I96:  i96,
		I120: i120,
	}
}

const TestNonStandardIntegersReturnStaticSize = 32

var _ abi.Tuple = (*TestNonStandardIntegersReturn)(nil)
var _ abi.PackedTuple = (*TestNonStandardIntegersReturn)(nil)

// TestNonStandardIntegersReturn represents an ABI tuple
type TestNonStandardIntegersReturn struct {
	Field1 bool
}

// EncodedSize returns the total encoded size of TestNonStandardIntegersReturn
func (t TestNonStandardIntegersReturn) EncodedSize() int {
	dynamicSize := 0

	return TestNonStandardIntegersReturnStaticSize + dynamicSize
}

// EncodeTo encodes TestNonStandardIntegersReturn to ABI bytes in the provided buffer
func (value TestNonStandardIntegersReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestNonStandardIntegersReturnStaticSize // Start dynamic data after static section
	// Field Field1: bool
	if _, err := abi.EncodeBool(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TestNonStandardIntegersReturn to ABI bytes
func (value TestNonStandardIntegersReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestNonStandardIntegersReturn from ABI bytes in the provided buffer
func (t *TestNonStandardIntegersReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bool
	t.Field1, _, err = abi.DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// PackedEncodedSize returns the packed encoded size of TestNonStandardIntegersReturn
func (t TestNonStandardIntegersReturn) PackedEncodedSize() int {
	return 1
}

// PackedEncodeTo encodes TestNonStandardIntegersReturn to packed ABI bytes in the provided buffer
func (value TestNonStandardIntegersReturn) PackedEncodeTo(buf []byte) (int, error) {
	// Encode tuple fields sequentially (packed, no dynamic section)
	var (
		offset int
		n      int
		err    error
	)
	// Field Field1: bool
	n, err = abi.PackedEncodeBool(value.Field1, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// PackedEncode encodes TestNonStandardIntegersReturn to packed ABI bytes
func (value TestNonStandardIntegersReturn) PackedEncode() ([]byte, error) {
	buf := make([]byte, value.PackedEncodedSize())
	if _, err := value.PackedEncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// PackedDecode decodes TestNonStandardIntegersReturn from packed ABI bytes
func (t *TestNonStandardIntegersReturn) PackedDecode(data []byte) (int, error) {
	if len(data) < 1 {
		return 0, io.ErrUnexpectedEOF
	}
	var err error
	// Decode field Field1: bool
	t.Field1, _, err = abi.PackedDecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return 1, nil
}

var _ abi.Method = (*TestSmallIntegersCall)(nil)

const TestSmallIntegersCallStaticSize = 320

var _ abi.Tuple = (*TestSmallIntegersCall)(nil)
var _ abi.PackedTuple = (*TestSmallIntegersCall)(nil)

// TestSmallIntegersCall represents an ABI tuple
type TestSmallIntegersCall struct {
	U8  uint8
	U16 uint16
	U24 uint32
	U32 uint32
	U64 uint64
	I8  int8
	I16 int16
	I24 int32
	I32 int32
	I64 int64
}

// EncodedSize returns the total encoded size of TestSmallIntegersCall
func (t TestSmallIntegersCall) EncodedSize() int {
	dynamicSize := 0

	return TestSmallIntegersCallStaticSize + dynamicSize
}

// EncodeTo encodes TestSmallIntegersCall to ABI bytes in the provided buffer
func (value TestSmallIntegersCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestSmallIntegersCallStaticSize // Start dynamic data after static section
	// Field U8: uint8
	if _, err := abi.EncodeUint8(value.U8, buf[0:]); err != nil {
		return 0, err
	}

	// Field U16: uint16
	if _, err := abi.EncodeUint16(value.U16, buf[32:]); err != nil {
		return 0, err
	}

	// Field U24: uint24
	if _, err := abi.EncodeUint24(value.U24, buf[64:]); err != nil {
		return 0, err
	}

	// Field U32: uint32
	if _, err := abi.EncodeUint32(value.U32, buf[96:]); err != nil {
		return 0, err
	}

	// Field U64: uint64
	if _, err := abi.EncodeUint64(value.U64, buf[128:]); err != nil {
		return 0, err
	}

	// Field I8: int8
	if _, err := abi.EncodeInt8(value.I8, buf[160:]); err != nil {
		return 0, err
	}

	// Field I16: int16
	if _, err := abi.EncodeInt16(value.I16, buf[192:]); err != nil {
		return 0, err
	}

	// Field I24: int24
	if _, err := abi.EncodeInt24(value.I24, buf[224:]); err != nil {
		return 0, err
	}

	// Field I32: int32
	if _, err := abi.EncodeInt32(value.I32, buf[256:]); err != nil {
		return 0, err
	}

	// Field I64: int64
	if _, err := abi.EncodeInt64(value.I64, buf[288:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TestSmallIntegersCall to ABI bytes
func (value TestSmallIntegersCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestSmallIntegersCall from ABI bytes in the provided buffer
func (t *TestSmallIntegersCall) Decode(data []byte) (int, error) {
	if len(data) < 320 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 320
	// Decode static field U8: uint8
	t.U8, _, err = abi.DecodeUint8(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode static field U16: uint16
	t.U16, _, err = abi.DecodeUint16(data[32:])
	if err != nil {
		return 0, err
	}
	// Decode static field U24: uint24
	t.U24, _, err = abi.DecodeUint24(data[64:])
	if err != nil {
		return 0, err
	}
	// Decode static field U32: uint32
	t.U32, _, err = abi.DecodeUint32(data[96:])
	if err != nil {
		return 0, err
	}
	// Decode static field U64: uint64
	t.U64, _, err = abi.DecodeUint64(data[128:])
	if err != nil {
		return 0, err
	}
	// Decode static field I8: int8
	t.I8, _, err = abi.DecodeInt8(data[160:])
	if err != nil {
		return 0, err
	}
	// Decode static field I16: int16
	t.I16, _, err = abi.DecodeInt16(data[192:])
	if err != nil {
		return 0, err
	}
	// Decode static field I24: int24
	t.I24, _, err = abi.DecodeInt24(data[224:])
	if err != nil {
		return 0, err
	}
	// Decode static field I32: int32
	t.I32, _, err = abi.DecodeInt32(data[256:])
	if err != nil {
		return 0, err
	}
	// Decode static field I64: int64
	t.I64, _, err = abi.DecodeInt64(data[288:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// PackedEncodedSize returns the packed encoded size of TestSmallIntegersCall
func (t TestSmallIntegersCall) PackedEncodedSize() int {
	return 36
}

// PackedEncodeTo encodes TestSmallIntegersCall to packed ABI bytes in the provided buffer
func (value TestSmallIntegersCall) PackedEncodeTo(buf []byte) (int, error) {
	// Encode tuple fields sequentially (packed, no dynamic section)
	var (
		offset int
		n      int
		err    error
	)
	// Field U8: uint8
	n, err = abi.PackedEncodeUint8(value.U8, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field U16: uint16
	n, err = abi.PackedEncodeUint16(value.U16, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field U24: uint24
	n, err = abi.PackedEncodeUint24(value.U24, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field U32: uint32
	n, err = abi.PackedEncodeUint32(value.U32, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field U64: uint64
	n, err = abi.PackedEncodeUint64(value.U64, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field I8: int8
	n, err = abi.PackedEncodeInt8(value.I8, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field I16: int16
	n, err = abi.PackedEncodeInt16(value.I16, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field I24: int24
	n, err = abi.PackedEncodeInt24(value.I24, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field I32: int32
	n, err = abi.PackedEncodeInt32(value.I32, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field I64: int64
	n, err = abi.PackedEncodeInt64(value.I64, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// PackedEncode encodes TestSmallIntegersCall to packed ABI bytes
func (value TestSmallIntegersCall) PackedEncode() ([]byte, error) {
	buf := make([]byte, value.PackedEncodedSize())
	if _, err := value.PackedEncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// PackedDecode decodes TestSmallIntegersCall from packed ABI bytes
func (t *TestSmallIntegersCall) PackedDecode(data []byte) (int, error) {
	if len(data) < 36 {
		return 0, io.ErrUnexpectedEOF
	}
	var err error
	// Decode field U8: uint8
	t.U8, _, err = abi.PackedDecodeUint8(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode field U16: uint16
	t.U16, _, err = abi.PackedDecodeUint16(data[1:])
	if err != nil {
		return 0, err
	}
	// Decode field U24: uint24
	t.U24, _, err = abi.PackedDecodeUint24(data[3:])
	if err != nil {
		return 0, err
	}
	// Decode field U32: uint32
	t.U32, _, err = abi.PackedDecodeUint32(data[6:])
	if err != nil {
		return 0, err
	}
	// Decode field U64: uint64
	t.U64, _, err = abi.PackedDecodeUint64(data[10:])
	if err != nil {
		return 0, err
	}
	// Decode field I8: int8
	t.I8, _, err = abi.PackedDecodeInt8(data[18:])
	if err != nil {
		return 0, err
	}
	// Decode field I16: int16
	t.I16, _, err = abi.PackedDecodeInt16(data[19:])
	if err != nil {
		return 0, err
	}
	// Decode field I24: int24
	t.I24, _, err = abi.PackedDecodeInt24(data[21:])
	if err != nil {
		return 0, err
	}
	// Decode field I32: int32
	t.I32, _, err = abi.PackedDecodeInt32(data[24:])
	if err != nil {
		return 0, err
	}
	// Decode field I64: int64
	t.I64, _, err = abi.PackedDecodeInt64(data[28:])
	if err != nil {
		return 0, err
	}
	return 36, nil
}

// GetMethodName returns the function name
func (t TestSmallIntegersCall) GetMethodName() string {
	return "testSmallIntegers"
}

// GetMethodID returns the function id
func (t TestSmallIntegersCall) GetMethodID() uint32 {
	return TestSmallIntegersID
}

// GetMethodSelector returns the function selector
func (t TestSmallIntegersCall) GetMethodSelector() [4]byte {
	return TestSmallIntegersSelector
}

// EncodeWithSelector encodes testSmallIntegers arguments to ABI bytes including function selector
func (t TestSmallIntegersCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TestSmallIntegersSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewTestSmallIntegersCall constructs a new TestSmallIntegersCall
func NewTestSmallIntegersCall(
	u8 uint8,
	u16 uint16,
	u24 uint32,
	u32 uint32,
	u64 uint64,
	i8 int8,
	i16 int16,
	i24 int32,
	i32 int32,
	i64 int64,
) *TestSmallIntegersCall {
	return &TestSmallIntegersCall{
		U8:  u8,
		U16: u16,
		U24: u24,
		U32: u32,
		U64: u64,
		I8:  i8,
		I16: i16,
		I24: i24,
		I32: i32,
		I64: i64,
	}
}

const TestSmallIntegersReturnStaticSize = 32

var _ abi.Tuple = (*TestSmallIntegersReturn)(nil)
var _ abi.PackedTuple = (*TestSmallIntegersReturn)(nil)

// TestSmallIntegersReturn represents an ABI tuple
type TestSmallIntegersReturn struct {
	Field1 bool
}

// EncodedSize returns the total encoded size of TestSmallIntegersReturn
func (t TestSmallIntegersReturn) EncodedSize() int {
	dynamicSize := 0

	return TestSmallIntegersReturnStaticSize + dynamicSize
}

// EncodeTo encodes TestSmallIntegersReturn to ABI bytes in the provided buffer
func (value TestSmallIntegersReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TestSmallIntegersReturnStaticSize // Start dynamic data after static section
	// Field Field1: bool
	if _, err := abi.EncodeBool(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TestSmallIntegersReturn to ABI bytes
func (value TestSmallIntegersReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TestSmallIntegersReturn from ABI bytes in the provided buffer
func (t *TestSmallIntegersReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bool
	t.Field1, _, err = abi.DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// PackedEncodedSize returns the packed encoded size of TestSmallIntegersReturn
func (t TestSmallIntegersReturn) PackedEncodedSize() int {
	return 1
}

// PackedEncodeTo encodes TestSmallIntegersReturn to packed ABI bytes in the provided buffer
func (value TestSmallIntegersReturn) PackedEncodeTo(buf []byte) (int, error) {
	// Encode tuple fields sequentially (packed, no dynamic section)
	var (
		offset int
		n      int
		err    error
	)
	// Field Field1: bool
	n, err = abi.PackedEncodeBool(value.Field1, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// PackedEncode encodes TestSmallIntegersReturn to packed ABI bytes
func (value TestSmallIntegersReturn) PackedEncode() ([]byte, error) {
	buf := make([]byte, value.PackedEncodedSize())
	if _, err := value.PackedEncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// PackedDecode decodes TestSmallIntegersReturn from packed ABI bytes
func (t *TestSmallIntegersReturn) PackedDecode(data []byte) (int, error) {
	if len(data) < 1 {
		return 0, io.ErrUnexpectedEOF
	}
	var err error
	// Decode field Field1: bool
	t.Field1, _, err = abi.PackedDecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return 1, nil
}

// Event signatures
var (
	// Complex(string,uint256[],address)
	ComplexEventTopic = common.Hash{0x56, 0x22, 0xe4, 0xd3, 0x12, 0xf8, 0xdd, 0x97, 0xbb, 0x32, 0x6c, 0x82, 0x99, 0x40, 0xc0, 0x6e, 0x5f, 0x3f, 0xf7, 0x2b, 0x31, 0x1a, 0x4d, 0xee, 0x95, 0x97, 0x35, 0x15, 0x88, 0x7d, 0x0d, 0xc7}
	// IndexOnly(address)
	IndexOnlyEventTopic = common.Hash{0x97, 0x3c, 0xfd, 0x69, 0xe6, 0x55, 0xa7, 0xff, 0xc7, 0x50, 0xd3, 0x74, 0x5d, 0x6c, 0xd2, 0xb0, 0xef, 0x78, 0xe9, 0x8c, 0x28, 0x84, 0x0b, 0xa3, 0xc7, 0x16, 0x3a, 0x5a, 0xe6, 0x37, 0x1f, 0x27}
	// Transfer(address,address,uint256)
	TransferEventTopic = common.Hash{0xdd, 0xf2, 0x52, 0xad, 0x1b, 0xe2, 0xc8, 0x9b, 0x69, 0xc2, 0xb0, 0x68, 0xfc, 0x37, 0x8d, 0xaa, 0x95, 0x2b, 0xa7, 0xf1, 0x63, 0xc4, 0xa1, 0x16, 0x28, 0xf5, 0x5a, 0x4d, 0xf5, 0x23, 0xb3, 0xef}
	// UserCreated((address,string,uint256),address)
	UserCreatedEventTopic = common.Hash{0x34, 0xd6, 0x8f, 0x2d, 0xec, 0x91, 0xef, 0x13, 0x0d, 0xe9, 0x21, 0x4e, 0x8e, 0xa8, 0x6e, 0x02, 0x29, 0xf7, 0x22, 0xee, 0x89, 0x41, 0xc9, 0x9f, 0x75, 0xbf, 0xa5, 0x38, 0x17, 0xd9, 0x97, 0x82}
)

// ComplexEvent represents the Complex event
var _ abi.Event = (*ComplexEvent)(nil)

type ComplexEvent struct {
	ComplexEventIndexed
	ComplexEventData
}

// NewComplexEvent constructs a new Complex event
func NewComplexEvent(
	message string,
	numbers []*big.Int,
	sender common.Address,
) *ComplexEvent {
	return &ComplexEvent{
		ComplexEventIndexed: ComplexEventIndexed{
			Sender: sender,
		},
		ComplexEventData: ComplexEventData{
			Message: message,
			Numbers: numbers,
		},
	}
}

// GetEventName returns the event name
func (e ComplexEvent) GetEventName() string {
	return "Complex"
}

// GetEventID returns the event ID (topic)
func (e ComplexEvent) GetEventID() common.Hash {
	return ComplexEventTopic
}

// Complex represents an ABI event
type ComplexEventIndexed struct {
	Sender common.Address
}

// EncodeTopics encodes indexed fields of Complex event to topics
func (e ComplexEventIndexed) EncodeTopics() ([]common.Hash, error) {
	topics := make([]common.Hash, 0, 2)
	topics = append(topics, ComplexEventTopic)
	{
		// Sender
		var hash common.Hash
		if _, err := abi.EncodeAddress(e.Sender, hash[:]); err != nil {
			return nil, err
		}
		topics = append(topics, hash)
	}
	return topics, nil
}

// DecodeTopics decodes indexed fields of Complex event from topics, ignore hash topics
func (e *ComplexEventIndexed) DecodeTopics(topics []common.Hash) error {
	if len(topics) != 2 {
		return abi.ErrInvalidNumberOfTopics
	}
	if topics[0] != ComplexEventTopic {
		return abi.ErrInvalidEventTopic
	}
	var err error
	e.Sender, _, err = abi.DecodeAddress(topics[1][:])
	if err != nil {
		return err
	}
	return nil
}

const ComplexEventDataStaticSize = 64

var _ abi.Tuple = (*ComplexEventData)(nil)

// ComplexEventData represents an ABI tuple
type ComplexEventData struct {
	Message string
	Numbers []*big.Int
}

// EncodedSize returns the total encoded size of ComplexEventData
func (t ComplexEventData) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Message)
	dynamicSize += abi.SizeUint256Slice(t.Numbers)

	return ComplexEventDataStaticSize + dynamicSize
}

// EncodeTo encodes ComplexEventData to ABI bytes in the provided buffer
func (value ComplexEventData) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := ComplexEventDataStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Message: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Message, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Numbers: uint256[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeUint256Slice(value.Numbers, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes ComplexEventData to ABI bytes
func (value ComplexEventData) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes ComplexEventData from ABI bytes in the provided buffer
func (t *ComplexEventData) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err    error
		n      int
		offset int
	)
	dynamicOffset := 64
	// Decode dynamic field Message
	{
		offset, err = abi.DecodeSize(data[0:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		t.Message, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Numbers
	{
		offset, err = abi.DecodeSize(data[32:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		t.Numbers, n, err = abi.DecodeUint256Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// IndexOnlyEvent represents the IndexOnly event
var _ abi.Event = (*IndexOnlyEvent)(nil)

type IndexOnlyEvent struct {
	IndexOnlyEventIndexed
	IndexOnlyEventData
}

// NewIndexOnlyEvent constructs a new IndexOnly event
func NewIndexOnlyEvent(
	sender common.Address,
) *IndexOnlyEvent {
	return &IndexOnlyEvent{
		IndexOnlyEventIndexed: IndexOnlyEventIndexed{
			Sender: sender,
		},
		IndexOnlyEventData: IndexOnlyEventData{},
	}
}

// GetEventName returns the event name
func (e IndexOnlyEvent) GetEventName() string {
	return "IndexOnly"
}

// GetEventID returns the event ID (topic)
func (e IndexOnlyEvent) GetEventID() common.Hash {
	return IndexOnlyEventTopic
}

// IndexOnly represents an ABI event
type IndexOnlyEventIndexed struct {
	Sender common.Address
}

// EncodeTopics encodes indexed fields of IndexOnly event to topics
func (e IndexOnlyEventIndexed) EncodeTopics() ([]common.Hash, error) {
	topics := make([]common.Hash, 0, 2)
	topics = append(topics, IndexOnlyEventTopic)
	{
		// Sender
		var hash common.Hash
		if _, err := abi.EncodeAddress(e.Sender, hash[:]); err != nil {
			return nil, err
		}
		topics = append(topics, hash)
	}
	return topics, nil
}

// DecodeTopics decodes indexed fields of IndexOnly event from topics, ignore hash topics
func (e *IndexOnlyEventIndexed) DecodeTopics(topics []common.Hash) error {
	if len(topics) != 2 {
		return abi.ErrInvalidNumberOfTopics
	}
	if topics[0] != IndexOnlyEventTopic {
		return abi.ErrInvalidEventTopic
	}
	var err error
	e.Sender, _, err = abi.DecodeAddress(topics[1][:])
	if err != nil {
		return err
	}
	return nil
}

type IndexOnlyEventData struct {
	abi.EmptyTuple
}

// TransferEvent represents the Transfer event
var _ abi.Event = (*TransferEvent)(nil)

type TransferEvent struct {
	TransferEventIndexed
	TransferEventData
}

// NewTransferEvent constructs a new Transfer event
func NewTransferEvent(
	from common.Address,
	to common.Address,
	value *big.Int,
) *TransferEvent {
	return &TransferEvent{
		TransferEventIndexed: TransferEventIndexed{
			From: from,
			To:   to,
		},
		TransferEventData: TransferEventData{
			Value: value,
		},
	}
}

// GetEventName returns the event name
func (e TransferEvent) GetEventName() string {
	return "Transfer"
}

// GetEventID returns the event ID (topic)
func (e TransferEvent) GetEventID() common.Hash {
	return TransferEventTopic
}

// Transfer represents an ABI event
type TransferEventIndexed struct {
	From common.Address
	To   common.Address
}

// EncodeTopics encodes indexed fields of Transfer event to topics
func (e TransferEventIndexed) EncodeTopics() ([]common.Hash, error) {
	topics := make([]common.Hash, 0, 3)
	topics = append(topics, TransferEventTopic)
	{
		// From
		var hash common.Hash
		if _, err := abi.EncodeAddress(e.From, hash[:]); err != nil {
			return nil, err
		}
		topics = append(topics, hash)
	}
	{
		// To
		var hash common.Hash
		if _, err := abi.EncodeAddress(e.To, hash[:]); err != nil {
			return nil, err
		}
		topics = append(topics, hash)
	}
	return topics, nil
}

// DecodeTopics decodes indexed fields of Transfer event from topics, ignore hash topics
func (e *TransferEventIndexed) DecodeTopics(topics []common.Hash) error {
	if len(topics) != 3 {
		return abi.ErrInvalidNumberOfTopics
	}
	if topics[0] != TransferEventTopic {
		return abi.ErrInvalidEventTopic
	}
	var err error
	e.From, _, err = abi.DecodeAddress(topics[1][:])
	if err != nil {
		return err
	}
	e.To, _, err = abi.DecodeAddress(topics[2][:])
	if err != nil {
		return err
	}
	return nil
}

const TransferEventDataStaticSize = 32

var _ abi.Tuple = (*TransferEventData)(nil)
var _ abi.PackedTuple = (*TransferEventData)(nil)

// TransferEventData represents an ABI tuple
type TransferEventData struct {
	Value *big.Int
}

// EncodedSize returns the total encoded size of TransferEventData
func (t TransferEventData) EncodedSize() int {
	dynamicSize := 0

	return TransferEventDataStaticSize + dynamicSize
}

// EncodeTo encodes TransferEventData to ABI bytes in the provided buffer
func (value TransferEventData) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TransferEventDataStaticSize // Start dynamic data after static section
	// Field Value: uint256
	if _, err := abi.EncodeUint256(value.Value, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TransferEventData to ABI bytes
func (value TransferEventData) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TransferEventData from ABI bytes in the provided buffer
func (t *TransferEventData) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Value: uint256
	t.Value, _, err = abi.DecodeUint256(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// PackedEncodedSize returns the packed encoded size of TransferEventData
func (t TransferEventData) PackedEncodedSize() int {
	return 32
}

// PackedEncodeTo encodes TransferEventData to packed ABI bytes in the provided buffer
func (value TransferEventData) PackedEncodeTo(buf []byte) (int, error) {
	// Encode tuple fields sequentially (packed, no dynamic section)
	var (
		offset int
		n      int
		err    error
	)
	// Field Value: uint256
	n, err = abi.PackedEncodeUint256(value.Value, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// PackedEncode encodes TransferEventData to packed ABI bytes
func (value TransferEventData) PackedEncode() ([]byte, error) {
	buf := make([]byte, value.PackedEncodedSize())
	if _, err := value.PackedEncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// PackedDecode decodes TransferEventData from packed ABI bytes
func (t *TransferEventData) PackedDecode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var err error
	// Decode field Value: uint256
	t.Value, _, err = abi.PackedDecodeUint256(data[0:])
	if err != nil {
		return 0, err
	}
	return 32, nil
}

// UserCreatedEvent represents the UserCreated event
var _ abi.Event = (*UserCreatedEvent)(nil)

type UserCreatedEvent struct {
	UserCreatedEventIndexed
	UserCreatedEventData
}

// NewUserCreatedEvent constructs a new UserCreated event
func NewUserCreatedEvent(
	user User,
	creator common.Address,
) *UserCreatedEvent {
	return &UserCreatedEvent{
		UserCreatedEventIndexed: UserCreatedEventIndexed{
			Creator: creator,
		},
		UserCreatedEventData: UserCreatedEventData{
			User: user,
		},
	}
}

// GetEventName returns the event name
func (e UserCreatedEvent) GetEventName() string {
	return "UserCreated"
}

// GetEventID returns the event ID (topic)
func (e UserCreatedEvent) GetEventID() common.Hash {
	return UserCreatedEventTopic
}

// UserCreated represents an ABI event
type UserCreatedEventIndexed struct {
	Creator common.Address
}

// EncodeTopics encodes indexed fields of UserCreated event to topics
func (e UserCreatedEventIndexed) EncodeTopics() ([]common.Hash, error) {
	topics := make([]common.Hash, 0, 2)
	topics = append(topics, UserCreatedEventTopic)
	{
		// Creator
		var hash common.Hash
		if _, err := abi.EncodeAddress(e.Creator, hash[:]); err != nil {
			return nil, err
		}
		topics = append(topics, hash)
	}
	return topics, nil
}

// DecodeTopics decodes indexed fields of UserCreated event from topics, ignore hash topics
func (e *UserCreatedEventIndexed) DecodeTopics(topics []common.Hash) error {
	if len(topics) != 2 {
		return abi.ErrInvalidNumberOfTopics
	}
	if topics[0] != UserCreatedEventTopic {
		return abi.ErrInvalidEventTopic
	}
	var err error
	e.Creator, _, err = abi.DecodeAddress(topics[1][:])
	if err != nil {
		return err
	}
	return nil
}

const UserCreatedEventDataStaticSize = 32

var _ abi.Tuple = (*UserCreatedEventData)(nil)

// UserCreatedEventData represents an ABI tuple
type UserCreatedEventData struct {
	User User
}

// EncodedSize returns the total encoded size of UserCreatedEventData
func (t UserCreatedEventData) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.User.EncodedSize()

	return UserCreatedEventDataStaticSize + dynamicSize
}

// EncodeTo encodes UserCreatedEventData to ABI bytes in the provided buffer
func (value UserCreatedEventData) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := UserCreatedEventDataStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field User: (address,string,uint256)
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.User.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes UserCreatedEventData to ABI bytes
func (value UserCreatedEventData) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes UserCreatedEventData from ABI bytes in the provided buffer
func (t *UserCreatedEventData) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err    error
		n      int
		offset int
	)
	dynamicOffset := 32
	// Decode dynamic field User
	{
		offset, err = abi.DecodeSize(data[0:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		n, err = t.User.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}
