// Code generated by go-abi. DO NOT EDIT.

package tests

import (
	"encoding/binary"
	"fmt"
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/yihuang/go-abi"
)

// Function selectors
var (
	// overloaded1(address,uint256)
	Overloaded1Selector = [4]byte{0x6d, 0xd8, 0x31, 0x3d}
	// overloaded1(address,address,uint256)
	Overloaded10Selector = [4]byte{0x16, 0xa1, 0x17, 0x8e}
	// overloaded1(address,address,uint256,bytes)
	Overloaded11Selector = [4]byte{0x4f, 0xc2, 0x5c, 0x7f}
	// overloaded2(address)
	Overloaded2Selector = [4]byte{0x07, 0x4c, 0x37, 0x24}
	// overloaded2()
	Overloaded20Selector = [4]byte{0x31, 0x09, 0x77, 0x2b}
)

// Big endian integer versions of function selectors
const (
	Overloaded1ID  = 1842884925
	Overloaded10ID = 379656078
	Overloaded11ID = 1338137727
	Overloaded2ID  = 122435364
	Overloaded20ID = 822703915
)

const Overloaded1CallStaticSize = 64

// Overloaded1Call represents an ABI tuple
type Overloaded1Call struct {
	To     common.Address
	Amount *big.Int
}

// EncodedSize returns the total encoded size of Overloaded1Call
func (t Overloaded1Call) EncodedSize() int {
	dynamicSize := 0

	return Overloaded1CallStaticSize + dynamicSize
}

// EncodeTo encodes Overloaded1Call to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t Overloaded1Call) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := Overloaded1CallStaticSize // Start dynamic data after static section

	// To (static)
	copy(buf[0+12:0+32], t.To[:])
	// Amount (static)

	if err := abi.EncodeBigInt(t.Amount, buf[32:64], false); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes Overloaded1Call to ABI bytes
func (t Overloaded1Call) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Overloaded1Call from ABI bytes in the provided buffer
func (t *Overloaded1Call) Decode(data0 []byte) error {
	if len(data0) < Overloaded1CallStaticSize {
		return fmt.Errorf("insufficient data for Overloaded1Call")
	}

	// t.To (static)
	copy(t.To[:], data0[0+12:0+32])
	// t.Amount (static)
	t.Amount = new(big.Int).SetBytes(data0[32:64])

	return nil
}

// EncodeWithSelector encodes overloaded1 arguments to ABI bytes including function selector
func (t Overloaded1Call) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], Overloaded1Selector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const Overloaded1ReturnStaticSize = 32

// Overloaded1Return represents an ABI tuple
type Overloaded1Return struct {
	Result1 bool
}

// EncodedSize returns the total encoded size of Overloaded1Return
func (t Overloaded1Return) EncodedSize() int {
	dynamicSize := 0

	return Overloaded1ReturnStaticSize + dynamicSize
}

// EncodeTo encodes Overloaded1Return to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t Overloaded1Return) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := Overloaded1ReturnStaticSize // Start dynamic data after static section

	// Result1 (static)
	if t.Result1 {
		buf[0+31] = 1
	}

	return dynamicOffset, nil
}

// Encode encodes Overloaded1Return to ABI bytes
func (t Overloaded1Return) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Overloaded1Return from ABI bytes in the provided buffer
func (t *Overloaded1Return) Decode(data0 []byte) error {
	if len(data0) < Overloaded1ReturnStaticSize {
		return fmt.Errorf("insufficient data for Overloaded1Return")
	}

	// t.Result1 (static)
	t.Result1 = data0[0+31] == 1

	return nil
}

const Overloaded10CallStaticSize = 96

// Overloaded10Call represents an ABI tuple
type Overloaded10Call struct {
	From   common.Address
	To     common.Address
	Amount *big.Int
}

// EncodedSize returns the total encoded size of Overloaded10Call
func (t Overloaded10Call) EncodedSize() int {
	dynamicSize := 0

	return Overloaded10CallStaticSize + dynamicSize
}

// EncodeTo encodes Overloaded10Call to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t Overloaded10Call) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := Overloaded10CallStaticSize // Start dynamic data after static section

	// From (static)
	copy(buf[0+12:0+32], t.From[:])
	// To (static)
	copy(buf[32+12:32+32], t.To[:])
	// Amount (static)

	if err := abi.EncodeBigInt(t.Amount, buf[64:96], false); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes Overloaded10Call to ABI bytes
func (t Overloaded10Call) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Overloaded10Call from ABI bytes in the provided buffer
func (t *Overloaded10Call) Decode(data0 []byte) error {
	if len(data0) < Overloaded10CallStaticSize {
		return fmt.Errorf("insufficient data for Overloaded10Call")
	}

	// t.From (static)
	copy(t.From[:], data0[0+12:0+32])
	// t.To (static)
	copy(t.To[:], data0[32+12:32+32])
	// t.Amount (static)
	t.Amount = new(big.Int).SetBytes(data0[64:96])

	return nil
}

// EncodeWithSelector encodes overloaded10 arguments to ABI bytes including function selector
func (t Overloaded10Call) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], Overloaded10Selector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const Overloaded10ReturnStaticSize = 32

// Overloaded10Return represents an ABI tuple
type Overloaded10Return struct {
	Result1 bool
}

// EncodedSize returns the total encoded size of Overloaded10Return
func (t Overloaded10Return) EncodedSize() int {
	dynamicSize := 0

	return Overloaded10ReturnStaticSize + dynamicSize
}

// EncodeTo encodes Overloaded10Return to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t Overloaded10Return) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := Overloaded10ReturnStaticSize // Start dynamic data after static section

	// Result1 (static)
	if t.Result1 {
		buf[0+31] = 1
	}

	return dynamicOffset, nil
}

// Encode encodes Overloaded10Return to ABI bytes
func (t Overloaded10Return) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Overloaded10Return from ABI bytes in the provided buffer
func (t *Overloaded10Return) Decode(data0 []byte) error {
	if len(data0) < Overloaded10ReturnStaticSize {
		return fmt.Errorf("insufficient data for Overloaded10Return")
	}

	// t.Result1 (static)
	t.Result1 = data0[0+31] == 1

	return nil
}

const Overloaded11CallStaticSize = 128

// Overloaded11Call represents an ABI tuple
type Overloaded11Call struct {
	From   common.Address
	To     common.Address
	Amount *big.Int
	Data   []byte
}

// EncodedSize returns the total encoded size of Overloaded11Call
func (t Overloaded11Call) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += 32 + abi.Pad32(len(t.Data)) // length + padded bytes data

	return Overloaded11CallStaticSize + dynamicSize
}

// EncodeTo encodes Overloaded11Call to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t Overloaded11Call) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := Overloaded11CallStaticSize // Start dynamic data after static section

	// From (static)
	copy(buf[0+12:0+32], t.From[:])
	// To (static)
	copy(buf[32+12:32+32], t.To[:])
	// Amount (static)

	if err := abi.EncodeBigInt(t.Amount, buf[64:96], false); err != nil {
		return 0, err
	}

	// Data (offset)
	binary.BigEndian.PutUint64(buf[96+24:96+32], uint64(dynamicOffset))

	// Data (dynamic)
	// length
	binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.Data)))
	dynamicOffset += 32

	// data
	copy(buf[dynamicOffset:], t.Data)
	dynamicOffset += abi.Pad32(len(t.Data))

	return dynamicOffset, nil
}

// Encode encodes Overloaded11Call to ABI bytes
func (t Overloaded11Call) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Overloaded11Call from ABI bytes in the provided buffer
func (t *Overloaded11Call) Decode(data0 []byte) error {
	if len(data0) < Overloaded11CallStaticSize {
		return fmt.Errorf("insufficient data for Overloaded11Call")
	}

	// t.From (static)
	copy(t.From[:], data0[0+12:0+32])
	// t.To (static)
	copy(t.To[:], data0[32+12:32+32])
	// t.Amount (static)
	t.Amount = new(big.Int).SetBytes(data0[64:96])
	// Data
	{
		offset := int(binary.BigEndian.Uint64(data0[96+24 : 96+32]))

		// t.Data (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// bytes data
		t.Data = data0[offset : offset+length]
	}

	return nil
}

// EncodeWithSelector encodes overloaded11 arguments to ABI bytes including function selector
func (t Overloaded11Call) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], Overloaded11Selector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const Overloaded11ReturnStaticSize = 32

// Overloaded11Return represents an ABI tuple
type Overloaded11Return struct {
	Result1 bool
}

// EncodedSize returns the total encoded size of Overloaded11Return
func (t Overloaded11Return) EncodedSize() int {
	dynamicSize := 0

	return Overloaded11ReturnStaticSize + dynamicSize
}

// EncodeTo encodes Overloaded11Return to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t Overloaded11Return) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := Overloaded11ReturnStaticSize // Start dynamic data after static section

	// Result1 (static)
	if t.Result1 {
		buf[0+31] = 1
	}

	return dynamicOffset, nil
}

// Encode encodes Overloaded11Return to ABI bytes
func (t Overloaded11Return) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Overloaded11Return from ABI bytes in the provided buffer
func (t *Overloaded11Return) Decode(data0 []byte) error {
	if len(data0) < Overloaded11ReturnStaticSize {
		return fmt.Errorf("insufficient data for Overloaded11Return")
	}

	// t.Result1 (static)
	t.Result1 = data0[0+31] == 1

	return nil
}

const Overloaded2CallStaticSize = 32

// Overloaded2Call represents an ABI tuple
type Overloaded2Call struct {
	Account common.Address
}

// EncodedSize returns the total encoded size of Overloaded2Call
func (t Overloaded2Call) EncodedSize() int {
	dynamicSize := 0

	return Overloaded2CallStaticSize + dynamicSize
}

// EncodeTo encodes Overloaded2Call to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t Overloaded2Call) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := Overloaded2CallStaticSize // Start dynamic data after static section

	// Account (static)
	copy(buf[0+12:0+32], t.Account[:])

	return dynamicOffset, nil
}

// Encode encodes Overloaded2Call to ABI bytes
func (t Overloaded2Call) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Overloaded2Call from ABI bytes in the provided buffer
func (t *Overloaded2Call) Decode(data0 []byte) error {
	if len(data0) < Overloaded2CallStaticSize {
		return fmt.Errorf("insufficient data for Overloaded2Call")
	}

	// t.Account (static)
	copy(t.Account[:], data0[0+12:0+32])

	return nil
}

// EncodeWithSelector encodes overloaded2 arguments to ABI bytes including function selector
func (t Overloaded2Call) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], Overloaded2Selector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const Overloaded2ReturnStaticSize = 32

// Overloaded2Return represents an ABI tuple
type Overloaded2Return struct {
	Result1 *big.Int
}

// EncodedSize returns the total encoded size of Overloaded2Return
func (t Overloaded2Return) EncodedSize() int {
	dynamicSize := 0

	return Overloaded2ReturnStaticSize + dynamicSize
}

// EncodeTo encodes Overloaded2Return to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t Overloaded2Return) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := Overloaded2ReturnStaticSize // Start dynamic data after static section

	// Result1 (static)

	if err := abi.EncodeBigInt(t.Result1, buf[0:32], false); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes Overloaded2Return to ABI bytes
func (t Overloaded2Return) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Overloaded2Return from ABI bytes in the provided buffer
func (t *Overloaded2Return) Decode(data0 []byte) error {
	if len(data0) < Overloaded2ReturnStaticSize {
		return fmt.Errorf("insufficient data for Overloaded2Return")
	}

	// t.Result1 (static)
	t.Result1 = new(big.Int).SetBytes(data0[0:32])

	return nil
}

const Overloaded20ReturnStaticSize = 32

// Overloaded20Return represents an ABI tuple
type Overloaded20Return struct {
	Result1 *big.Int
}

// EncodedSize returns the total encoded size of Overloaded20Return
func (t Overloaded20Return) EncodedSize() int {
	dynamicSize := 0

	return Overloaded20ReturnStaticSize + dynamicSize
}

// EncodeTo encodes Overloaded20Return to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t Overloaded20Return) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := Overloaded20ReturnStaticSize // Start dynamic data after static section

	// Result1 (static)

	if err := abi.EncodeBigInt(t.Result1, buf[0:32], false); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes Overloaded20Return to ABI bytes
func (t Overloaded20Return) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Overloaded20Return from ABI bytes in the provided buffer
func (t *Overloaded20Return) Decode(data0 []byte) error {
	if len(data0) < Overloaded20ReturnStaticSize {
		return fmt.Errorf("insufficient data for Overloaded20Return")
	}

	// t.Result1 (static)
	t.Result1 = new(big.Int).SetBytes(data0[0:32])

	return nil
}
