// Code generated by go-abi. DO NOT EDIT.

package testdata

import (
	"encoding/binary"
	"fmt"
	"github.com/ethereum/go-ethereum/common"
	"github.com/yihuang/go-abi"
	"math/big"
)

// Function selectors
var (
	// overloaded1(address,uint256)
	Overloaded1Selector = [4]byte{0x6d, 0xd8, 0x31, 0x3d}
	// overloaded1(address,address,uint256)
	Overloaded10Selector = [4]byte{0x16, 0xa1, 0x17, 0x8e}
	// overloaded1(address,address,uint256,bytes)
	Overloaded11Selector = [4]byte{0x4f, 0xc2, 0x5c, 0x7f}
	// overloaded2(address)
	Overloaded2Selector = [4]byte{0x07, 0x4c, 0x37, 0x24}
	// overloaded2()
	Overloaded20Selector = [4]byte{0x31, 0x09, 0x77, 0x2b}
)

// Big endian integer versions of function selectors
const (
	Overloaded1SelectorInt  = 1842884925
	Overloaded10SelectorInt = 379656078
	Overloaded11SelectorInt = 1338137727
	Overloaded2SelectorInt  = 122435364
	Overloaded20SelectorInt = 822703915
)

const Overloaded1CallStaticSize = 64

// Overloaded1Call represents an ABI tuple
type Overloaded1Call struct {
	To     common.Address
	Amount *big.Int
}

// EncodedSize returns the total encoded size of Overloaded1Call
func (t Overloaded1Call) EncodedSize() int {
	dynamicSize := 0

	return Overloaded1CallStaticSize + dynamicSize
}

// EncodeTo encodes Overloaded1Call to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t Overloaded1Call) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := Overloaded1CallStaticSize // Start dynamic data after static section

	// To (static)
	copy(buf[0+12:0+32], t.To[:])
	// Amount (static)

	if err := abi.EncodeBigInt(t.Amount, buf[32:64], false); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes Overloaded1Call to ABI bytes
func (t Overloaded1Call) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// DecodeFrom decodes Overloaded1Call from ABI bytes in the provided buffer
func (t *Overloaded1Call) DecodeFrom(data0 []byte) error {
	if len(data0) < Overloaded1CallStaticSize {
		return fmt.Errorf("insufficient data for Overloaded1Call")
	}

	// t.To (static)
	copy(t.To[:], data0[0+12:0+32])
	// t.Amount (static)
	t.Amount = new(big.Int).SetBytes(data0[32:64])

	return nil
}

// Decode decodes Overloaded1Call from ABI bytes
func (t *Overloaded1Call) Decode(data []byte) error {
	return t.DecodeFrom(data)
}

// EncodeWithSelector encodes overloaded1 arguments to ABI bytes including function selector
func (t Overloaded1Call) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], Overloaded1Selector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const Overloaded10CallStaticSize = 96

// Overloaded10Call represents an ABI tuple
type Overloaded10Call struct {
	From   common.Address
	To     common.Address
	Amount *big.Int
}

// EncodedSize returns the total encoded size of Overloaded10Call
func (t Overloaded10Call) EncodedSize() int {
	dynamicSize := 0

	return Overloaded10CallStaticSize + dynamicSize
}

// EncodeTo encodes Overloaded10Call to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t Overloaded10Call) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := Overloaded10CallStaticSize // Start dynamic data after static section

	// From (static)
	copy(buf[0+12:0+32], t.From[:])
	// To (static)
	copy(buf[32+12:32+32], t.To[:])
	// Amount (static)

	if err := abi.EncodeBigInt(t.Amount, buf[64:96], false); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes Overloaded10Call to ABI bytes
func (t Overloaded10Call) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// DecodeFrom decodes Overloaded10Call from ABI bytes in the provided buffer
func (t *Overloaded10Call) DecodeFrom(data0 []byte) error {
	if len(data0) < Overloaded10CallStaticSize {
		return fmt.Errorf("insufficient data for Overloaded10Call")
	}

	// t.From (static)
	copy(t.From[:], data0[0+12:0+32])
	// t.To (static)
	copy(t.To[:], data0[32+12:32+32])
	// t.Amount (static)
	t.Amount = new(big.Int).SetBytes(data0[64:96])

	return nil
}

// Decode decodes Overloaded10Call from ABI bytes
func (t *Overloaded10Call) Decode(data []byte) error {
	return t.DecodeFrom(data)
}

// EncodeWithSelector encodes overloaded10 arguments to ABI bytes including function selector
func (t Overloaded10Call) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], Overloaded10Selector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const Overloaded11CallStaticSize = 128

// Overloaded11Call represents an ABI tuple
type Overloaded11Call struct {
	From   common.Address
	To     common.Address
	Amount *big.Int
	Data   []byte
}

// EncodedSize returns the total encoded size of Overloaded11Call
func (t Overloaded11Call) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += 32 + abi.Pad32(len(t.Data)) // length + padded bytes data

	return Overloaded11CallStaticSize + dynamicSize
}

// EncodeTo encodes Overloaded11Call to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t Overloaded11Call) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := Overloaded11CallStaticSize // Start dynamic data after static section

	// From (static)
	copy(buf[0+12:0+32], t.From[:])
	// To (static)
	copy(buf[32+12:32+32], t.To[:])
	// Amount (static)

	if err := abi.EncodeBigInt(t.Amount, buf[64:96], false); err != nil {
		return 0, err
	}

	// Data (offset)
	binary.BigEndian.PutUint64(buf[96+24:96+32], uint64(dynamicOffset))

	// Data (dynamic)
	// length
	binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.Data)))
	dynamicOffset += 32

	// data
	copy(buf[dynamicOffset:], t.Data)
	dynamicOffset += abi.Pad32(len(t.Data))

	return dynamicOffset, nil
}

// Encode encodes Overloaded11Call to ABI bytes
func (t Overloaded11Call) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// DecodeFrom decodes Overloaded11Call from ABI bytes in the provided buffer
func (t *Overloaded11Call) DecodeFrom(data0 []byte) error {
	if len(data0) < Overloaded11CallStaticSize {
		return fmt.Errorf("insufficient data for Overloaded11Call")
	}

	// t.From (static)
	copy(t.From[:], data0[0+12:0+32])
	// t.To (static)
	copy(t.To[:], data0[32+12:32+32])
	// t.Amount (static)
	t.Amount = new(big.Int).SetBytes(data0[64:96])
	// Data
	{
		offset := int(binary.BigEndian.Uint64(data0[96+24 : 96+32]))

		// t.Data (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// bytes data
		t.Data = data0[offset : offset+length]
	}

	return nil
}

// Decode decodes Overloaded11Call from ABI bytes
func (t *Overloaded11Call) Decode(data []byte) error {
	return t.DecodeFrom(data)
}

// EncodeWithSelector encodes overloaded11 arguments to ABI bytes including function selector
func (t Overloaded11Call) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], Overloaded11Selector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const Overloaded2CallStaticSize = 32

// Overloaded2Call represents an ABI tuple
type Overloaded2Call struct {
	Account common.Address
}

// EncodedSize returns the total encoded size of Overloaded2Call
func (t Overloaded2Call) EncodedSize() int {
	dynamicSize := 0

	return Overloaded2CallStaticSize + dynamicSize
}

// EncodeTo encodes Overloaded2Call to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t Overloaded2Call) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := Overloaded2CallStaticSize // Start dynamic data after static section

	// Account (static)
	copy(buf[0+12:0+32], t.Account[:])

	return dynamicOffset, nil
}

// Encode encodes Overloaded2Call to ABI bytes
func (t Overloaded2Call) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// DecodeFrom decodes Overloaded2Call from ABI bytes in the provided buffer
func (t *Overloaded2Call) DecodeFrom(data0 []byte) error {
	if len(data0) < Overloaded2CallStaticSize {
		return fmt.Errorf("insufficient data for Overloaded2Call")
	}

	// t.Account (static)
	copy(t.Account[:], data0[0+12:0+32])

	return nil
}

// Decode decodes Overloaded2Call from ABI bytes
func (t *Overloaded2Call) Decode(data []byte) error {
	return t.DecodeFrom(data)
}

// EncodeWithSelector encodes overloaded2 arguments to ABI bytes including function selector
func (t Overloaded2Call) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], Overloaded2Selector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}
