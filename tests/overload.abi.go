// Code generated by go-abi. DO NOT EDIT.

package testdata

import (
	"encoding/binary"
	"fmt"
	"github.com/ethereum/go-ethereum/common"
	"github.com/yihuang/go-abi"
	"math/big"
)

const Overloaded1ArgsStaticSize = 64

// Overloaded1Args represents an ABI tuple
type Overloaded1Args struct {
	To     common.Address
	Amount *big.Int
}

// EncodedSize returns the total encoded size of Overloaded1Args
func (t Overloaded1Args) EncodedSize() int {
	dynamicSize := 0

	return Overloaded1ArgsStaticSize + dynamicSize
}

// EncodeTo encodes Overloaded1Args to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t Overloaded1Args) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := Overloaded1ArgsStaticSize // Start dynamic data after static section

	// To (static)
	copy(buf[0+12:0+32], t.To[:])
	// Amount (static)

	if err := abi.EncodeBigInt(t.Amount, buf[32:64], false); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes Overloaded1Args to ABI bytes
func (t Overloaded1Args) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// DecodeFrom decodes Overloaded1Args from ABI bytes in the provided buffer
func (t *Overloaded1Args) DecodeFrom(data0 []byte) error {
	if len(data0) < Overloaded1ArgsStaticSize {
		return fmt.Errorf("insufficient data for Overloaded1Args")
	}

	// t.To (static)
	copy(t.To[:], data0[0+12:0+32])
	// t.Amount (static)
	t.Amount = new(big.Int).SetBytes(data0[32:64])

	return nil
}

// Decode decodes Overloaded1Args from ABI bytes
func (t *Overloaded1Args) Decode(data []byte) error {
	return t.DecodeFrom(data)
}

// EncodeWithSelector encodes overloaded1 arguments to ABI bytes including function selector
func (t Overloaded1Args) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], Overloaded1ArgsSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// Overloaded1ArgsSelector is the function selector for overloaded1(address,uint256)
var Overloaded1ArgsSelector = [4]byte{0x6d, 0xd8, 0x31, 0x3d}

// Selector returns the function selector for overloaded1
func (Overloaded1Args) Selector() [4]byte {
	return Overloaded1ArgsSelector
}

const Overloaded10ArgsStaticSize = 96

// Overloaded10Args represents an ABI tuple
type Overloaded10Args struct {
	From   common.Address
	To     common.Address
	Amount *big.Int
}

// EncodedSize returns the total encoded size of Overloaded10Args
func (t Overloaded10Args) EncodedSize() int {
	dynamicSize := 0

	return Overloaded10ArgsStaticSize + dynamicSize
}

// EncodeTo encodes Overloaded10Args to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t Overloaded10Args) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := Overloaded10ArgsStaticSize // Start dynamic data after static section

	// From (static)
	copy(buf[0+12:0+32], t.From[:])
	// To (static)
	copy(buf[32+12:32+32], t.To[:])
	// Amount (static)

	if err := abi.EncodeBigInt(t.Amount, buf[64:96], false); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes Overloaded10Args to ABI bytes
func (t Overloaded10Args) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// DecodeFrom decodes Overloaded10Args from ABI bytes in the provided buffer
func (t *Overloaded10Args) DecodeFrom(data0 []byte) error {
	if len(data0) < Overloaded10ArgsStaticSize {
		return fmt.Errorf("insufficient data for Overloaded10Args")
	}

	// t.From (static)
	copy(t.From[:], data0[0+12:0+32])
	// t.To (static)
	copy(t.To[:], data0[32+12:32+32])
	// t.Amount (static)
	t.Amount = new(big.Int).SetBytes(data0[64:96])

	return nil
}

// Decode decodes Overloaded10Args from ABI bytes
func (t *Overloaded10Args) Decode(data []byte) error {
	return t.DecodeFrom(data)
}

// EncodeWithSelector encodes overloaded10 arguments to ABI bytes including function selector
func (t Overloaded10Args) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], Overloaded10ArgsSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// Overloaded10ArgsSelector is the function selector for overloaded1(address,address,uint256)
var Overloaded10ArgsSelector = [4]byte{0x16, 0xa1, 0x17, 0x8e}

// Selector returns the function selector for overloaded10
func (Overloaded10Args) Selector() [4]byte {
	return Overloaded10ArgsSelector
}

const Overloaded11ArgsStaticSize = 128

// Overloaded11Args represents an ABI tuple
type Overloaded11Args struct {
	From   common.Address
	To     common.Address
	Amount *big.Int
	Data   []byte
}

// EncodedSize returns the total encoded size of Overloaded11Args
func (t Overloaded11Args) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += 32 + abi.Pad32(len(t.Data)) // length + padded bytes data

	return Overloaded11ArgsStaticSize + dynamicSize
}

// EncodeTo encodes Overloaded11Args to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t Overloaded11Args) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := Overloaded11ArgsStaticSize // Start dynamic data after static section

	// From (static)
	copy(buf[0+12:0+32], t.From[:])
	// To (static)
	copy(buf[32+12:32+32], t.To[:])
	// Amount (static)

	if err := abi.EncodeBigInt(t.Amount, buf[64:96], false); err != nil {
		return 0, err
	}

	// Data (offset)
	binary.BigEndian.PutUint64(buf[96+24:96+32], uint64(dynamicOffset))

	// Data (dynamic)
	// length
	binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.Data)))
	dynamicOffset += 32

	// data
	copy(buf[dynamicOffset:], t.Data)
	dynamicOffset += abi.Pad32(len(t.Data))

	return dynamicOffset, nil
}

// Encode encodes Overloaded11Args to ABI bytes
func (t Overloaded11Args) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// DecodeFrom decodes Overloaded11Args from ABI bytes in the provided buffer
func (t *Overloaded11Args) DecodeFrom(data0 []byte) error {
	if len(data0) < Overloaded11ArgsStaticSize {
		return fmt.Errorf("insufficient data for Overloaded11Args")
	}

	// t.From (static)
	copy(t.From[:], data0[0+12:0+32])
	// t.To (static)
	copy(t.To[:], data0[32+12:32+32])
	// t.Amount (static)
	t.Amount = new(big.Int).SetBytes(data0[64:96])
	// Data
	{
		offset := int(binary.BigEndian.Uint64(data0[96+24 : 96+32]))

		// t.Data (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// bytes data
		t.Data = data0[offset : offset+length]
	}

	return nil
}

// Decode decodes Overloaded11Args from ABI bytes
func (t *Overloaded11Args) Decode(data []byte) error {
	return t.DecodeFrom(data)
}

// EncodeWithSelector encodes overloaded11 arguments to ABI bytes including function selector
func (t Overloaded11Args) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], Overloaded11ArgsSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// Overloaded11ArgsSelector is the function selector for overloaded1(address,address,uint256,bytes)
var Overloaded11ArgsSelector = [4]byte{0x4f, 0xc2, 0x5c, 0x7f}

// Selector returns the function selector for overloaded11
func (Overloaded11Args) Selector() [4]byte {
	return Overloaded11ArgsSelector
}

const Overloaded2ArgsStaticSize = 32

// Overloaded2Args represents an ABI tuple
type Overloaded2Args struct {
	Account common.Address
}

// EncodedSize returns the total encoded size of Overloaded2Args
func (t Overloaded2Args) EncodedSize() int {
	dynamicSize := 0

	return Overloaded2ArgsStaticSize + dynamicSize
}

// EncodeTo encodes Overloaded2Args to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t Overloaded2Args) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := Overloaded2ArgsStaticSize // Start dynamic data after static section

	// Account (static)
	copy(buf[0+12:0+32], t.Account[:])

	return dynamicOffset, nil
}

// Encode encodes Overloaded2Args to ABI bytes
func (t Overloaded2Args) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// DecodeFrom decodes Overloaded2Args from ABI bytes in the provided buffer
func (t *Overloaded2Args) DecodeFrom(data0 []byte) error {
	if len(data0) < Overloaded2ArgsStaticSize {
		return fmt.Errorf("insufficient data for Overloaded2Args")
	}

	// t.Account (static)
	copy(t.Account[:], data0[0+12:0+32])

	return nil
}

// Decode decodes Overloaded2Args from ABI bytes
func (t *Overloaded2Args) Decode(data []byte) error {
	return t.DecodeFrom(data)
}

// EncodeWithSelector encodes overloaded2 arguments to ABI bytes including function selector
func (t Overloaded2Args) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], Overloaded2ArgsSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// Overloaded2ArgsSelector is the function selector for overloaded2(address)
var Overloaded2ArgsSelector = [4]byte{0x07, 0x4c, 0x37, 0x24}

// Selector returns the function selector for overloaded2
func (Overloaded2Args) Selector() [4]byte {
	return Overloaded2ArgsSelector
}
