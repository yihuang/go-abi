// Code generated by go-abi. DO NOT EDIT.

package tests

import (
	"encoding/binary"
	"fmt"
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/yihuang/go-abi"
)

// Function selectors
var (
	// balanceOf(address)
	BalanceOfSelector = [4]byte{0x70, 0xa0, 0x82, 0x31}
	// batchProcess((uint256,(bytes32,string))[])
	BatchProcessSelector = [4]byte{0xb7, 0x78, 0x31, 0x64}
	// communityPool()
	CommunityPoolSelector = [4]byte{0x14, 0xd1, 0x40, 0xb0}
	// getBalances(address[10])
	GetBalancesSelector = [4]byte{0x51, 0x68, 0x3d, 0x7d}
	// processUserData((address,string,uint256),(address,string,uint256))
	ProcessUserDataSelector = [4]byte{0xe0, 0x33, 0x24, 0x04}
	// setData(bytes32,bytes)
	SetDataSelector = [4]byte{0x7f, 0x23, 0x69, 0x0c}
	// setMessage(string)
	SetMessageSelector = [4]byte{0x36, 0x8b, 0x87, 0x72}
	// smallIntegers(uint8,uint16,uint32,uint64,int8,int16,int32,int64)
	SmallIntegersSelector = [4]byte{0x98, 0x83, 0xfe, 0x4a}
	// transfer(address,uint256)
	TransferSelector = [4]byte{0xa9, 0x05, 0x9c, 0xbb}
	// transferBatch(address[],uint256[])
	TransferBatchSelector = [4]byte{0x3b, 0x3e, 0x67, 0x2f}
	// updateProfile(address,string,uint256)
	UpdateProfileSelector = [4]byte{0x6d, 0xe9, 0x52, 0x01}
)

// Big endian integer versions of function selectors
const (
	BalanceOfID       = 1889567281
	BatchProcessID    = 3078107492
	CommunityPoolID   = 349257904
	GetBalancesID     = 1365785981
	ProcessUserDataID = 3761447940
	SetDataID         = 2133027084
	SetMessageID      = 915113842
	SmallIntegersID   = 2558787146
	TransferID        = 2835717307
	TransferBatchID   = 993945391
	UpdateProfileID   = 1844007425
)

const Tuple_45c89796StaticSize = 64

// Tuple_45c89796 represents an ABI tuple
type Tuple_45c89796 struct {
	Denom  string
	Amount *big.Int
}

// EncodedSize returns the total encoded size of Tuple_45c89796
func (t Tuple_45c89796) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += 32 + abi.Pad32(len(t.Denom)) // length + padded string data

	return Tuple_45c89796StaticSize + dynamicSize
}

// EncodeTo encodes Tuple_45c89796 to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t Tuple_45c89796) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := Tuple_45c89796StaticSize // Start dynamic data after static section

	// Denom (offset)
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))

	// Denom (dynamic)
	// length
	binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.Denom)))
	dynamicOffset += 32

	// data
	copy(buf[dynamicOffset:], []byte(t.Denom))
	dynamicOffset += abi.Pad32(len(t.Denom))

	// Amount (static)

	if err := abi.EncodeBigInt(t.Amount, buf[32:64], false); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes Tuple_45c89796 to ABI bytes
func (t Tuple_45c89796) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Tuple_45c89796 from ABI bytes in the provided buffer
func (t *Tuple_45c89796) Decode(data0 []byte) error {
	if len(data0) < Tuple_45c89796StaticSize {
		return fmt.Errorf("insufficient data for Tuple_45c89796")
	}

	// Denom
	{
		offset := int(binary.BigEndian.Uint64(data0[0+24 : 0+32]))

		// t.Denom (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// string data
		t.Denom = string(data0[offset : offset+length])
	}
	// t.Amount (static)
	t.Amount = new(big.Int).SetBytes(data0[32:64])

	return nil
}

const UserStaticSize = 96

// User represents an ABI tuple
type User struct {
	Address common.Address
	Name    string
	Age     *big.Int
}

// EncodedSize returns the total encoded size of User
func (t User) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += 32 + abi.Pad32(len(t.Name)) // length + padded string data

	return UserStaticSize + dynamicSize
}

// EncodeTo encodes User to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t User) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := UserStaticSize // Start dynamic data after static section

	// Address (static)
	copy(buf[0+12:0+32], t.Address[:])

	// Name (offset)
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))

	// Name (dynamic)
	// length
	binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.Name)))
	dynamicOffset += 32

	// data
	copy(buf[dynamicOffset:], []byte(t.Name))
	dynamicOffset += abi.Pad32(len(t.Name))

	// Age (static)

	if err := abi.EncodeBigInt(t.Age, buf[64:96], false); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes User to ABI bytes
func (t User) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes User from ABI bytes in the provided buffer
func (t *User) Decode(data0 []byte) error {
	if len(data0) < UserStaticSize {
		return fmt.Errorf("insufficient data for User")
	}

	// t.Address (static)
	copy(t.Address[:], data0[0+12:0+32])
	// Name
	{
		offset := int(binary.BigEndian.Uint64(data0[32+24 : 32+32]))

		// t.Name (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// string data
		t.Name = string(data0[offset : offset+length])
	}
	// t.Age (static)
	t.Age = new(big.Int).SetBytes(data0[64:96])

	return nil
}

const UserDataStaticSize = 64

// UserData represents an ABI tuple
type UserData struct {
	Id   *big.Int
	Data UserMetadata
}

// EncodedSize returns the total encoded size of UserData
func (t UserData) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += t.Data.EncodedSize() // dynamic tuple

	return UserDataStaticSize + dynamicSize
}

// EncodeTo encodes UserData to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t UserData) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := UserDataStaticSize // Start dynamic data after static section

	// Id (static)

	if err := abi.EncodeBigInt(t.Id, buf[0:32], false); err != nil {
		return 0, err
	}

	// Data (offset)
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))

	// Data (dynamic)
	{
		n, err := t.Data.EncodeTo(buf[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}

	return dynamicOffset, nil
}

// Encode encodes UserData to ABI bytes
func (t UserData) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes UserData from ABI bytes in the provided buffer
func (t *UserData) Decode(data0 []byte) error {
	if len(data0) < UserDataStaticSize {
		return fmt.Errorf("insufficient data for UserData")
	}

	// t.Id (static)
	t.Id = new(big.Int).SetBytes(data0[0:32])
	// Data
	{
		offset := int(binary.BigEndian.Uint64(data0[32+24 : 32+32]))

		// t.Data (dynamic)
		if offset >= len(data0) {
			return fmt.Errorf("insufficient data for dynamic data, t.Data")
		}
		if err := t.Data.Decode(data0[offset:]); err != nil {
			return err
		}
	}

	return nil
}

const UserMetadataStaticSize = 64

// UserMetadata represents an ABI tuple
type UserMetadata struct {
	Key   [32]byte
	Value string
}

// EncodedSize returns the total encoded size of UserMetadata
func (t UserMetadata) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += 32 + abi.Pad32(len(t.Value)) // length + padded string data

	return UserMetadataStaticSize + dynamicSize
}

// EncodeTo encodes UserMetadata to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t UserMetadata) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := UserMetadataStaticSize // Start dynamic data after static section

	// Key (static)
	copy(buf[0:0+32], t.Key[:])

	// Value (offset)
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))

	// Value (dynamic)
	// length
	binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.Value)))
	dynamicOffset += 32

	// data
	copy(buf[dynamicOffset:], []byte(t.Value))
	dynamicOffset += abi.Pad32(len(t.Value))

	return dynamicOffset, nil
}

// Encode encodes UserMetadata to ABI bytes
func (t UserMetadata) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes UserMetadata from ABI bytes in the provided buffer
func (t *UserMetadata) Decode(data0 []byte) error {
	if len(data0) < UserMetadataStaticSize {
		return fmt.Errorf("insufficient data for UserMetadata")
	}

	// t.Key (static)
	copy(t.Key[:], data0[0:0+32])
	// Value
	{
		offset := int(binary.BigEndian.Uint64(data0[32+24 : 32+32]))

		// t.Value (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// string data
		t.Value = string(data0[offset : offset+length])
	}

	return nil
}

const BalanceOfCallStaticSize = 32

// BalanceOfCall represents an ABI tuple
type BalanceOfCall struct {
	Account common.Address
}

// EncodedSize returns the total encoded size of BalanceOfCall
func (t BalanceOfCall) EncodedSize() int {
	dynamicSize := 0

	return BalanceOfCallStaticSize + dynamicSize
}

// EncodeTo encodes BalanceOfCall to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t BalanceOfCall) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := BalanceOfCallStaticSize // Start dynamic data after static section

	// Account (static)
	copy(buf[0+12:0+32], t.Account[:])

	return dynamicOffset, nil
}

// Encode encodes BalanceOfCall to ABI bytes
func (t BalanceOfCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes BalanceOfCall from ABI bytes in the provided buffer
func (t *BalanceOfCall) Decode(data0 []byte) error {
	if len(data0) < BalanceOfCallStaticSize {
		return fmt.Errorf("insufficient data for BalanceOfCall")
	}

	// t.Account (static)
	copy(t.Account[:], data0[0+12:0+32])

	return nil
}

// EncodeWithSelector encodes balanceOf arguments to ABI bytes including function selector
func (t BalanceOfCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], BalanceOfSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const BalanceOfReturnStaticSize = 32

// BalanceOfReturn represents an ABI tuple
type BalanceOfReturn struct {
	Result1 *big.Int
}

// EncodedSize returns the total encoded size of BalanceOfReturn
func (t BalanceOfReturn) EncodedSize() int {
	dynamicSize := 0

	return BalanceOfReturnStaticSize + dynamicSize
}

// EncodeTo encodes BalanceOfReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t BalanceOfReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := BalanceOfReturnStaticSize // Start dynamic data after static section

	// Result1 (static)

	if err := abi.EncodeBigInt(t.Result1, buf[0:32], false); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes BalanceOfReturn to ABI bytes
func (t BalanceOfReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes BalanceOfReturn from ABI bytes in the provided buffer
func (t *BalanceOfReturn) Decode(data0 []byte) error {
	if len(data0) < BalanceOfReturnStaticSize {
		return fmt.Errorf("insufficient data for BalanceOfReturn")
	}

	// t.Result1 (static)
	t.Result1 = new(big.Int).SetBytes(data0[0:32])

	return nil
}

const BatchProcessCallStaticSize = 32

// BatchProcessCall represents an ABI tuple
type BatchProcessCall struct {
	Users []UserData
}

// EncodedSize returns the total encoded size of BatchProcessCall
func (t BatchProcessCall) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += 32 + 32*len(t.Users) // length + offset pointers for dynamic elements
	for _, elem := range t.Users {
		dynamicSize += elem.EncodedSize() // dynamic tuple
	}

	return BatchProcessCallStaticSize + dynamicSize
}

// EncodeTo encodes BatchProcessCall to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t BatchProcessCall) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := BatchProcessCallStaticSize // Start dynamic data after static section

	// Users (offset)
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))

	// Users (dynamic)
	{
		// length
		binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.Users)))
		dynamicOffset += 32

		var written int

		// data with dynamic region
		{
			buf := buf[dynamicOffset:]
			dynamicOffset := len(t.Users) * 32 // start after static region

			var offset int
			for _, item := range t.Users {
				// write offsets
				binary.BigEndian.PutUint64(buf[offset+24:offset+32], uint64(dynamicOffset))
				offset += 32

				// write data (dynamic)

				{
					n, err := item.EncodeTo(buf[dynamicOffset:])
					if err != nil {
						return 0, err
					}
					dynamicOffset += n
				}

			}
			written = dynamicOffset
		}
		dynamicOffset += written

	}

	return dynamicOffset, nil
}

// Encode encodes BatchProcessCall to ABI bytes
func (t BatchProcessCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes BatchProcessCall from ABI bytes in the provided buffer
func (t *BatchProcessCall) Decode(data0 []byte) error {
	if len(data0) < BatchProcessCallStaticSize {
		return fmt.Errorf("insufficient data for BatchProcessCall")
	}

	// Users
	{
		offset := int(binary.BigEndian.Uint64(data0[0+24 : 0+32]))

		// t.Users (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// slice data
		t.Users = make([]UserData, length)
		data1 := data0[offset:]

		// Dynamic elements with offsets (dynamic array)
		for i0 := 0; i0 < length; i0++ {
			// Read element offset
			tmp := i0 * 32
			if tmp+32 > len(data1) {
				return fmt.Errorf("insufficient data for element offset")
			}
			offset := int(binary.BigEndian.Uint64(data1[tmp+24 : tmp+32]))
			// Decode dynamic element at offset

			// t.Users[i0] (dynamic)
			if offset >= len(data1) {
				return fmt.Errorf("insufficient data for dynamic data, t.Users[i0]")
			}
			if err := t.Users[i0].Decode(data1[offset:]); err != nil {
				return err
			}
		}
	}

	return nil
}

// EncodeWithSelector encodes batchProcess arguments to ABI bytes including function selector
func (t BatchProcessCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], BatchProcessSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const BatchProcessReturnStaticSize = 32

// BatchProcessReturn represents an ABI tuple
type BatchProcessReturn struct {
	Result1 bool
}

// EncodedSize returns the total encoded size of BatchProcessReturn
func (t BatchProcessReturn) EncodedSize() int {
	dynamicSize := 0

	return BatchProcessReturnStaticSize + dynamicSize
}

// EncodeTo encodes BatchProcessReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t BatchProcessReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := BatchProcessReturnStaticSize // Start dynamic data after static section

	// Result1 (static)

	if t.Result1 {
		buf[0+31] = 1
	}

	return dynamicOffset, nil
}

// Encode encodes BatchProcessReturn to ABI bytes
func (t BatchProcessReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes BatchProcessReturn from ABI bytes in the provided buffer
func (t *BatchProcessReturn) Decode(data0 []byte) error {
	if len(data0) < BatchProcessReturnStaticSize {
		return fmt.Errorf("insufficient data for BatchProcessReturn")
	}

	// t.Result1 (static)
	t.Result1 = data0[0+31] == 1

	return nil
}

const CommunityPoolReturnStaticSize = 32

// CommunityPoolReturn represents an ABI tuple
type CommunityPoolReturn struct {
	Coins []Tuple_45c89796
}

// EncodedSize returns the total encoded size of CommunityPoolReturn
func (t CommunityPoolReturn) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += 32 + 32*len(t.Coins) // length + offset pointers for dynamic elements
	for _, elem := range t.Coins {
		dynamicSize += elem.EncodedSize() // dynamic tuple
	}

	return CommunityPoolReturnStaticSize + dynamicSize
}

// EncodeTo encodes CommunityPoolReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t CommunityPoolReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := CommunityPoolReturnStaticSize // Start dynamic data after static section

	// Coins (offset)
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))

	// Coins (dynamic)
	{
		// length
		binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.Coins)))
		dynamicOffset += 32

		var written int

		// data with dynamic region
		{
			buf := buf[dynamicOffset:]
			dynamicOffset := len(t.Coins) * 32 // start after static region

			var offset int
			for _, item := range t.Coins {
				// write offsets
				binary.BigEndian.PutUint64(buf[offset+24:offset+32], uint64(dynamicOffset))
				offset += 32

				// write data (dynamic)

				{
					n, err := item.EncodeTo(buf[dynamicOffset:])
					if err != nil {
						return 0, err
					}
					dynamicOffset += n
				}

			}
			written = dynamicOffset
		}
		dynamicOffset += written

	}

	return dynamicOffset, nil
}

// Encode encodes CommunityPoolReturn to ABI bytes
func (t CommunityPoolReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes CommunityPoolReturn from ABI bytes in the provided buffer
func (t *CommunityPoolReturn) Decode(data0 []byte) error {
	if len(data0) < CommunityPoolReturnStaticSize {
		return fmt.Errorf("insufficient data for CommunityPoolReturn")
	}

	// Coins
	{
		offset := int(binary.BigEndian.Uint64(data0[0+24 : 0+32]))

		// t.Coins (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// slice data
		t.Coins = make([]Tuple_45c89796, length)
		data1 := data0[offset:]

		// Dynamic elements with offsets (dynamic array)
		for i0 := 0; i0 < length; i0++ {
			// Read element offset
			tmp := i0 * 32
			if tmp+32 > len(data1) {
				return fmt.Errorf("insufficient data for element offset")
			}
			offset := int(binary.BigEndian.Uint64(data1[tmp+24 : tmp+32]))
			// Decode dynamic element at offset

			// t.Coins[i0] (dynamic)
			if offset >= len(data1) {
				return fmt.Errorf("insufficient data for dynamic data, t.Coins[i0]")
			}
			if err := t.Coins[i0].Decode(data1[offset:]); err != nil {
				return err
			}
		}
	}

	return nil
}

const GetBalancesCallStaticSize = 320

// GetBalancesCall represents an ABI tuple
type GetBalancesCall struct {
	Accounts [10]common.Address
}

// EncodedSize returns the total encoded size of GetBalancesCall
func (t GetBalancesCall) EncodedSize() int {
	dynamicSize := 0

	return GetBalancesCallStaticSize + dynamicSize
}

// EncodeTo encodes GetBalancesCall to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t GetBalancesCall) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := GetBalancesCallStaticSize // Start dynamic data after static section

	// Accounts (static)

	// Encode fixed-size array t.Accounts
	{
		offset := 0
		for _, item := range t.Accounts {

			copy(buf[offset+12:offset+32], item[:])

			offset += 32
		}
	}

	return dynamicOffset, nil
}

// Encode encodes GetBalancesCall to ABI bytes
func (t GetBalancesCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes GetBalancesCall from ABI bytes in the provided buffer
func (t *GetBalancesCall) Decode(data0 []byte) error {
	if len(data0) < GetBalancesCallStaticSize {
		return fmt.Errorf("insufficient data for GetBalancesCall")
	}

	// t.Accounts (static)
	// Decode fixed-size array t.Accounts
	for i0 := 0; i0 < 10; i0++ {
		offset := 0 + i0*32
		data1 := data0

		// t.Accounts[i0] (static)
		copy(t.Accounts[i0][:], data1[offset+12:offset+32])
	}

	return nil
}

// EncodeWithSelector encodes getBalances arguments to ABI bytes including function selector
func (t GetBalancesCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], GetBalancesSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const GetBalancesReturnStaticSize = 320

// GetBalancesReturn represents an ABI tuple
type GetBalancesReturn struct {
	Result1 [10]*big.Int
}

// EncodedSize returns the total encoded size of GetBalancesReturn
func (t GetBalancesReturn) EncodedSize() int {
	dynamicSize := 0

	return GetBalancesReturnStaticSize + dynamicSize
}

// EncodeTo encodes GetBalancesReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t GetBalancesReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := GetBalancesReturnStaticSize // Start dynamic data after static section

	// Result1 (static)

	// Encode fixed-size array t.Result1
	{
		offset := 0
		for _, item := range t.Result1 {

			if err := abi.EncodeBigInt(item, buf[offset:offset+32], false); err != nil {
				return 0, err
			}

			offset += 32
		}
	}

	return dynamicOffset, nil
}

// Encode encodes GetBalancesReturn to ABI bytes
func (t GetBalancesReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes GetBalancesReturn from ABI bytes in the provided buffer
func (t *GetBalancesReturn) Decode(data0 []byte) error {
	if len(data0) < GetBalancesReturnStaticSize {
		return fmt.Errorf("insufficient data for GetBalancesReturn")
	}

	// t.Result1 (static)
	// Decode fixed-size array t.Result1
	for i0 := 0; i0 < 10; i0++ {
		offset := 0 + i0*32
		data1 := data0

		// t.Result1[i0] (static)
		t.Result1[i0] = new(big.Int).SetBytes(data1[offset : offset+32])
	}

	return nil
}

const ProcessUserDataCallStaticSize = 64

// ProcessUserDataCall represents an ABI tuple
type ProcessUserDataCall struct {
	User1 User
	User2 User
}

// EncodedSize returns the total encoded size of ProcessUserDataCall
func (t ProcessUserDataCall) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += t.User1.EncodedSize() // dynamic tuple
	dynamicSize += t.User2.EncodedSize() // dynamic tuple

	return ProcessUserDataCallStaticSize + dynamicSize
}

// EncodeTo encodes ProcessUserDataCall to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t ProcessUserDataCall) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := ProcessUserDataCallStaticSize // Start dynamic data after static section

	// User1 (offset)
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))

	// User1 (dynamic)
	{
		n, err := t.User1.EncodeTo(buf[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}

	// User2 (offset)
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))

	// User2 (dynamic)
	{
		n, err := t.User2.EncodeTo(buf[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}

	return dynamicOffset, nil
}

// Encode encodes ProcessUserDataCall to ABI bytes
func (t ProcessUserDataCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes ProcessUserDataCall from ABI bytes in the provided buffer
func (t *ProcessUserDataCall) Decode(data0 []byte) error {
	if len(data0) < ProcessUserDataCallStaticSize {
		return fmt.Errorf("insufficient data for ProcessUserDataCall")
	}

	// User1
	{
		offset := int(binary.BigEndian.Uint64(data0[0+24 : 0+32]))

		// t.User1 (dynamic)
		if offset >= len(data0) {
			return fmt.Errorf("insufficient data for dynamic data, t.User1")
		}
		if err := t.User1.Decode(data0[offset:]); err != nil {
			return err
		}
	}
	// User2
	{
		offset := int(binary.BigEndian.Uint64(data0[32+24 : 32+32]))

		// t.User2 (dynamic)
		if offset >= len(data0) {
			return fmt.Errorf("insufficient data for dynamic data, t.User2")
		}
		if err := t.User2.Decode(data0[offset:]); err != nil {
			return err
		}
	}

	return nil
}

// EncodeWithSelector encodes processUserData arguments to ABI bytes including function selector
func (t ProcessUserDataCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], ProcessUserDataSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const ProcessUserDataReturnStaticSize = 32

// ProcessUserDataReturn represents an ABI tuple
type ProcessUserDataReturn struct {
	Result1 bool
}

// EncodedSize returns the total encoded size of ProcessUserDataReturn
func (t ProcessUserDataReturn) EncodedSize() int {
	dynamicSize := 0

	return ProcessUserDataReturnStaticSize + dynamicSize
}

// EncodeTo encodes ProcessUserDataReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t ProcessUserDataReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := ProcessUserDataReturnStaticSize // Start dynamic data after static section

	// Result1 (static)

	if t.Result1 {
		buf[0+31] = 1
	}

	return dynamicOffset, nil
}

// Encode encodes ProcessUserDataReturn to ABI bytes
func (t ProcessUserDataReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes ProcessUserDataReturn from ABI bytes in the provided buffer
func (t *ProcessUserDataReturn) Decode(data0 []byte) error {
	if len(data0) < ProcessUserDataReturnStaticSize {
		return fmt.Errorf("insufficient data for ProcessUserDataReturn")
	}

	// t.Result1 (static)
	t.Result1 = data0[0+31] == 1

	return nil
}

const SetDataCallStaticSize = 64

// SetDataCall represents an ABI tuple
type SetDataCall struct {
	Key   [32]byte
	Value []byte
}

// EncodedSize returns the total encoded size of SetDataCall
func (t SetDataCall) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += 32 + abi.Pad32(len(t.Value)) // length + padded bytes data

	return SetDataCallStaticSize + dynamicSize
}

// EncodeTo encodes SetDataCall to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t SetDataCall) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := SetDataCallStaticSize // Start dynamic data after static section

	// Key (static)
	copy(buf[0:0+32], t.Key[:])

	// Value (offset)
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))

	// Value (dynamic)
	// length
	binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.Value)))
	dynamicOffset += 32

	// data
	copy(buf[dynamicOffset:], t.Value)
	dynamicOffset += abi.Pad32(len(t.Value))

	return dynamicOffset, nil
}

// Encode encodes SetDataCall to ABI bytes
func (t SetDataCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes SetDataCall from ABI bytes in the provided buffer
func (t *SetDataCall) Decode(data0 []byte) error {
	if len(data0) < SetDataCallStaticSize {
		return fmt.Errorf("insufficient data for SetDataCall")
	}

	// t.Key (static)
	copy(t.Key[:], data0[0:0+32])
	// Value
	{
		offset := int(binary.BigEndian.Uint64(data0[32+24 : 32+32]))

		// t.Value (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// bytes data
		t.Value = data0[offset : offset+length]
	}

	return nil
}

// EncodeWithSelector encodes setData arguments to ABI bytes including function selector
func (t SetDataCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], SetDataSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const SetMessageCallStaticSize = 32

// SetMessageCall represents an ABI tuple
type SetMessageCall struct {
	Message string
}

// EncodedSize returns the total encoded size of SetMessageCall
func (t SetMessageCall) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += 32 + abi.Pad32(len(t.Message)) // length + padded string data

	return SetMessageCallStaticSize + dynamicSize
}

// EncodeTo encodes SetMessageCall to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t SetMessageCall) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := SetMessageCallStaticSize // Start dynamic data after static section

	// Message (offset)
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))

	// Message (dynamic)
	// length
	binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.Message)))
	dynamicOffset += 32

	// data
	copy(buf[dynamicOffset:], []byte(t.Message))
	dynamicOffset += abi.Pad32(len(t.Message))

	return dynamicOffset, nil
}

// Encode encodes SetMessageCall to ABI bytes
func (t SetMessageCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes SetMessageCall from ABI bytes in the provided buffer
func (t *SetMessageCall) Decode(data0 []byte) error {
	if len(data0) < SetMessageCallStaticSize {
		return fmt.Errorf("insufficient data for SetMessageCall")
	}

	// Message
	{
		offset := int(binary.BigEndian.Uint64(data0[0+24 : 0+32]))

		// t.Message (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// string data
		t.Message = string(data0[offset : offset+length])
	}

	return nil
}

// EncodeWithSelector encodes setMessage arguments to ABI bytes including function selector
func (t SetMessageCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], SetMessageSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const SetMessageReturnStaticSize = 32

// SetMessageReturn represents an ABI tuple
type SetMessageReturn struct {
	Result1 bool
}

// EncodedSize returns the total encoded size of SetMessageReturn
func (t SetMessageReturn) EncodedSize() int {
	dynamicSize := 0

	return SetMessageReturnStaticSize + dynamicSize
}

// EncodeTo encodes SetMessageReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t SetMessageReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := SetMessageReturnStaticSize // Start dynamic data after static section

	// Result1 (static)

	if t.Result1 {
		buf[0+31] = 1
	}

	return dynamicOffset, nil
}

// Encode encodes SetMessageReturn to ABI bytes
func (t SetMessageReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes SetMessageReturn from ABI bytes in the provided buffer
func (t *SetMessageReturn) Decode(data0 []byte) error {
	if len(data0) < SetMessageReturnStaticSize {
		return fmt.Errorf("insufficient data for SetMessageReturn")
	}

	// t.Result1 (static)
	t.Result1 = data0[0+31] == 1

	return nil
}

const SmallIntegersCallStaticSize = 256

// SmallIntegersCall represents an ABI tuple
type SmallIntegersCall struct {
	U8  uint8
	U16 uint16
	U32 uint32
	U64 uint64
	I8  int8
	I16 int16
	I32 int32
	I64 int64
}

// EncodedSize returns the total encoded size of SmallIntegersCall
func (t SmallIntegersCall) EncodedSize() int {
	dynamicSize := 0

	return SmallIntegersCallStaticSize + dynamicSize
}

// EncodeTo encodes SmallIntegersCall to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t SmallIntegersCall) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := SmallIntegersCallStaticSize // Start dynamic data after static section

	// U8 (static)
	buf[0+31] = byte(t.U8)
	// U16 (static)
	binary.BigEndian.PutUint16(buf[32+30:32+32], uint16(t.U16))
	// U32 (static)
	binary.BigEndian.PutUint32(buf[64+28:64+32], uint32(t.U32))
	// U64 (static)
	binary.BigEndian.PutUint64(buf[96+24:96+32], uint64(t.U64))
	// I8 (static)

	if t.I8 < 0 {
		for i := 0; i < 31; i++ {
			buf[128+i] = 0xff
		}
	}
	buf[128+31] = byte(t.I8)

	// I16 (static)

	if t.I16 < 0 {
		for i := 0; i < 30; i++ {
			buf[160+i] = 0xff
		}
	}
	binary.BigEndian.PutUint16(buf[160+30:160+32], uint16(t.I16))

	// I32 (static)

	if t.I32 < 0 {
		for i := 0; i < 28; i++ {
			buf[192+i] = 0xff
		}
	}
	binary.BigEndian.PutUint32(buf[192+28:192+32], uint32(t.I32))

	// I64 (static)

	if t.I64 < 0 {
		for i := 0; i < 24; i++ {
			buf[224+i] = 0xff
		}
	}
	binary.BigEndian.PutUint64(buf[224+24:224+32], uint64(t.I64))

	return dynamicOffset, nil
}

// Encode encodes SmallIntegersCall to ABI bytes
func (t SmallIntegersCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes SmallIntegersCall from ABI bytes in the provided buffer
func (t *SmallIntegersCall) Decode(data0 []byte) error {
	if len(data0) < SmallIntegersCallStaticSize {
		return fmt.Errorf("insufficient data for SmallIntegersCall")
	}

	// t.U8 (static)
	t.U8 = uint8(data0[0+31])
	// t.U16 (static)
	t.U16 = uint16(binary.BigEndian.Uint16(data0[32+30 : 32+32]))
	// t.U32 (static)
	t.U32 = uint32(binary.BigEndian.Uint32(data0[64+28 : 64+32]))
	// t.U64 (static)
	t.U64 = uint64(binary.BigEndian.Uint64(data0[96+24 : 96+32]))
	// t.I8 (static)
	t.I8 = int8(data0[128+31])
	// t.I16 (static)
	t.I16 = int16(binary.BigEndian.Uint16(data0[160+30 : 160+32]))
	// t.I32 (static)
	t.I32 = int32(binary.BigEndian.Uint32(data0[192+28 : 192+32]))
	// t.I64 (static)
	t.I64 = int64(binary.BigEndian.Uint64(data0[224+24 : 224+32]))

	return nil
}

// EncodeWithSelector encodes smallIntegers arguments to ABI bytes including function selector
func (t SmallIntegersCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], SmallIntegersSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const SmallIntegersReturnStaticSize = 32

// SmallIntegersReturn represents an ABI tuple
type SmallIntegersReturn struct {
	Result1 bool
}

// EncodedSize returns the total encoded size of SmallIntegersReturn
func (t SmallIntegersReturn) EncodedSize() int {
	dynamicSize := 0

	return SmallIntegersReturnStaticSize + dynamicSize
}

// EncodeTo encodes SmallIntegersReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t SmallIntegersReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := SmallIntegersReturnStaticSize // Start dynamic data after static section

	// Result1 (static)

	if t.Result1 {
		buf[0+31] = 1
	}

	return dynamicOffset, nil
}

// Encode encodes SmallIntegersReturn to ABI bytes
func (t SmallIntegersReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes SmallIntegersReturn from ABI bytes in the provided buffer
func (t *SmallIntegersReturn) Decode(data0 []byte) error {
	if len(data0) < SmallIntegersReturnStaticSize {
		return fmt.Errorf("insufficient data for SmallIntegersReturn")
	}

	// t.Result1 (static)
	t.Result1 = data0[0+31] == 1

	return nil
}

const TransferCallStaticSize = 64

// TransferCall represents an ABI tuple
type TransferCall struct {
	To     common.Address
	Amount *big.Int
}

// EncodedSize returns the total encoded size of TransferCall
func (t TransferCall) EncodedSize() int {
	dynamicSize := 0

	return TransferCallStaticSize + dynamicSize
}

// EncodeTo encodes TransferCall to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t TransferCall) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := TransferCallStaticSize // Start dynamic data after static section

	// To (static)
	copy(buf[0+12:0+32], t.To[:])
	// Amount (static)

	if err := abi.EncodeBigInt(t.Amount, buf[32:64], false); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TransferCall to ABI bytes
func (t TransferCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TransferCall from ABI bytes in the provided buffer
func (t *TransferCall) Decode(data0 []byte) error {
	if len(data0) < TransferCallStaticSize {
		return fmt.Errorf("insufficient data for TransferCall")
	}

	// t.To (static)
	copy(t.To[:], data0[0+12:0+32])
	// t.Amount (static)
	t.Amount = new(big.Int).SetBytes(data0[32:64])

	return nil
}

// EncodeWithSelector encodes transfer arguments to ABI bytes including function selector
func (t TransferCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TransferSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const TransferReturnStaticSize = 32

// TransferReturn represents an ABI tuple
type TransferReturn struct {
	Result1 bool
}

// EncodedSize returns the total encoded size of TransferReturn
func (t TransferReturn) EncodedSize() int {
	dynamicSize := 0

	return TransferReturnStaticSize + dynamicSize
}

// EncodeTo encodes TransferReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t TransferReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := TransferReturnStaticSize // Start dynamic data after static section

	// Result1 (static)

	if t.Result1 {
		buf[0+31] = 1
	}

	return dynamicOffset, nil
}

// Encode encodes TransferReturn to ABI bytes
func (t TransferReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TransferReturn from ABI bytes in the provided buffer
func (t *TransferReturn) Decode(data0 []byte) error {
	if len(data0) < TransferReturnStaticSize {
		return fmt.Errorf("insufficient data for TransferReturn")
	}

	// t.Result1 (static)
	t.Result1 = data0[0+31] == 1

	return nil
}

const TransferBatchCallStaticSize = 64

// TransferBatchCall represents an ABI tuple
type TransferBatchCall struct {
	Recipients []common.Address
	Amounts    []*big.Int
}

// EncodedSize returns the total encoded size of TransferBatchCall
func (t TransferBatchCall) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += 32 + 32*len(t.Recipients) // length + static elements
	dynamicSize += 32 + 32*len(t.Amounts)    // length + static elements

	return TransferBatchCallStaticSize + dynamicSize
}

// EncodeTo encodes TransferBatchCall to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t TransferBatchCall) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := TransferBatchCallStaticSize // Start dynamic data after static section

	// Recipients (offset)
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))

	// Recipients (dynamic)
	{
		// length
		binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.Recipients)))
		dynamicOffset += 32

		// data without dynamic region
		buf := buf[dynamicOffset:]
		var offset int
		for _, item := range t.Recipients {

			copy(buf[offset+12:offset+32], item[:])

			offset += 32
		}
		dynamicOffset += offset

	}

	// Amounts (offset)
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))

	// Amounts (dynamic)
	{
		// length
		binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.Amounts)))
		dynamicOffset += 32

		// data without dynamic region
		buf := buf[dynamicOffset:]
		var offset int
		for _, item := range t.Amounts {

			if err := abi.EncodeBigInt(item, buf[offset:offset+32], false); err != nil {
				return 0, err
			}

			offset += 32
		}
		dynamicOffset += offset

	}

	return dynamicOffset, nil
}

// Encode encodes TransferBatchCall to ABI bytes
func (t TransferBatchCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TransferBatchCall from ABI bytes in the provided buffer
func (t *TransferBatchCall) Decode(data0 []byte) error {
	if len(data0) < TransferBatchCallStaticSize {
		return fmt.Errorf("insufficient data for TransferBatchCall")
	}

	// Recipients
	{
		offset := int(binary.BigEndian.Uint64(data0[0+24 : 0+32]))

		// t.Recipients (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// slice data
		t.Recipients = make([]common.Address, length)
		data1 := data0[offset:]

		offset = 0
		for i0 := 0; i0 < length; i0++ {
			// t.Recipients[i0] (static)
			copy(t.Recipients[i0][:], data1[offset+12:offset+32])
			offset += 32
		}
	}
	// Amounts
	{
		offset := int(binary.BigEndian.Uint64(data0[32+24 : 32+32]))

		// t.Amounts (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// slice data
		t.Amounts = make([]*big.Int, length)
		data1 := data0[offset:]

		offset = 0
		for i0 := 0; i0 < length; i0++ {
			// t.Amounts[i0] (static)
			t.Amounts[i0] = new(big.Int).SetBytes(data1[offset : offset+32])
			offset += 32
		}
	}

	return nil
}

// EncodeWithSelector encodes transferBatch arguments to ABI bytes including function selector
func (t TransferBatchCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TransferBatchSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const TransferBatchReturnStaticSize = 32

// TransferBatchReturn represents an ABI tuple
type TransferBatchReturn struct {
	Result1 bool
}

// EncodedSize returns the total encoded size of TransferBatchReturn
func (t TransferBatchReturn) EncodedSize() int {
	dynamicSize := 0

	return TransferBatchReturnStaticSize + dynamicSize
}

// EncodeTo encodes TransferBatchReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t TransferBatchReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := TransferBatchReturnStaticSize // Start dynamic data after static section

	// Result1 (static)

	if t.Result1 {
		buf[0+31] = 1
	}

	return dynamicOffset, nil
}

// Encode encodes TransferBatchReturn to ABI bytes
func (t TransferBatchReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TransferBatchReturn from ABI bytes in the provided buffer
func (t *TransferBatchReturn) Decode(data0 []byte) error {
	if len(data0) < TransferBatchReturnStaticSize {
		return fmt.Errorf("insufficient data for TransferBatchReturn")
	}

	// t.Result1 (static)
	t.Result1 = data0[0+31] == 1

	return nil
}

const UpdateProfileCallStaticSize = 96

// UpdateProfileCall represents an ABI tuple
type UpdateProfileCall struct {
	User common.Address
	Name string
	Age  *big.Int
}

// EncodedSize returns the total encoded size of UpdateProfileCall
func (t UpdateProfileCall) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += 32 + abi.Pad32(len(t.Name)) // length + padded string data

	return UpdateProfileCallStaticSize + dynamicSize
}

// EncodeTo encodes UpdateProfileCall to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t UpdateProfileCall) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := UpdateProfileCallStaticSize // Start dynamic data after static section

	// User (static)
	copy(buf[0+12:0+32], t.User[:])

	// Name (offset)
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))

	// Name (dynamic)
	// length
	binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.Name)))
	dynamicOffset += 32

	// data
	copy(buf[dynamicOffset:], []byte(t.Name))
	dynamicOffset += abi.Pad32(len(t.Name))

	// Age (static)

	if err := abi.EncodeBigInt(t.Age, buf[64:96], false); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes UpdateProfileCall to ABI bytes
func (t UpdateProfileCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes UpdateProfileCall from ABI bytes in the provided buffer
func (t *UpdateProfileCall) Decode(data0 []byte) error {
	if len(data0) < UpdateProfileCallStaticSize {
		return fmt.Errorf("insufficient data for UpdateProfileCall")
	}

	// t.User (static)
	copy(t.User[:], data0[0+12:0+32])
	// Name
	{
		offset := int(binary.BigEndian.Uint64(data0[32+24 : 32+32]))

		// t.Name (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// string data
		t.Name = string(data0[offset : offset+length])
	}
	// t.Age (static)
	t.Age = new(big.Int).SetBytes(data0[64:96])

	return nil
}

// EncodeWithSelector encodes updateProfile arguments to ABI bytes including function selector
func (t UpdateProfileCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], UpdateProfileSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const UpdateProfileReturnStaticSize = 32

// UpdateProfileReturn represents an ABI tuple
type UpdateProfileReturn struct {
	Result1 bool
}

// EncodedSize returns the total encoded size of UpdateProfileReturn
func (t UpdateProfileReturn) EncodedSize() int {
	dynamicSize := 0

	return UpdateProfileReturnStaticSize + dynamicSize
}

// EncodeTo encodes UpdateProfileReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t UpdateProfileReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := UpdateProfileReturnStaticSize // Start dynamic data after static section

	// Result1 (static)

	if t.Result1 {
		buf[0+31] = 1
	}

	return dynamicOffset, nil
}

// Encode encodes UpdateProfileReturn to ABI bytes
func (t UpdateProfileReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes UpdateProfileReturn from ABI bytes in the provided buffer
func (t *UpdateProfileReturn) Decode(data0 []byte) error {
	if len(data0) < UpdateProfileReturnStaticSize {
		return fmt.Errorf("insufficient data for UpdateProfileReturn")
	}

	// t.Result1 (static)
	t.Result1 = data0[0+31] == 1

	return nil
}
