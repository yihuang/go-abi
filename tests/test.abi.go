// Code generated by go-abi. DO NOT EDIT.

package tests

import (
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/yihuang/go-abi"
)

// Function selectors
var (
	// balanceOf(address)
	BalanceOfSelector = [4]byte{0x70, 0xa0, 0x82, 0x31}
	// batchProcess((uint256,(bytes32,string))[])
	BatchProcessSelector = [4]byte{0xb7, 0x78, 0x31, 0x64}
	// communityPool()
	CommunityPoolSelector = [4]byte{0x14, 0xd1, 0x40, 0xb0}
	// emptyArgs()
	EmptyArgsSelector = [4]byte{0xf9, 0xce, 0x95, 0xfe}
	// getBalances(address[10])
	GetBalancesSelector = [4]byte{0x51, 0x68, 0x3d, 0x7d}
	// processUserData((address,string,uint256),(address,string,uint256))
	ProcessUserDataSelector = [4]byte{0xe0, 0x33, 0x24, 0x04}
	// setData(bytes32,bytes)
	SetDataSelector = [4]byte{0x7f, 0x23, 0x69, 0x0c}
	// setMessage(string)
	SetMessageSelector = [4]byte{0x36, 0x8b, 0x87, 0x72}
	// smallIntegers(uint8,uint16,uint32,uint64,int8,int16,int32,int64)
	SmallIntegersSelector = [4]byte{0x98, 0x83, 0xfe, 0x4a}
	// transfer(address,uint256)
	TransferSelector = [4]byte{0xa9, 0x05, 0x9c, 0xbb}
	// transferBatch(address[],uint256[])
	TransferBatchSelector = [4]byte{0x3b, 0x3e, 0x67, 0x2f}
	// updateProfile(address,string,uint256)
	UpdateProfileSelector = [4]byte{0x6d, 0xe9, 0x52, 0x01}
)

// Big endian integer versions of function selectors
const (
	BalanceOfID       = 1889567281
	BatchProcessID    = 3078107492
	CommunityPoolID   = 349257904
	EmptyArgsID       = 4191065598
	GetBalancesID     = 1365785981
	ProcessUserDataID = 3761447940
	SetDataID         = 2133027084
	SetMessageID      = 915113842
	SmallIntegersID   = 2558787146
	TransferID        = 2835717307
	TransferBatchID   = 993945391
	UpdateProfileID   = 1844007425
)

const Tuple45c89796StaticSize = 64

// Tuple45c89796 represents an ABI tuple
type Tuple45c89796 struct {
	Denom  string
	Amount *big.Int
}

// EncodedSize returns the total encoded size of Tuple45c89796
func (t Tuple45c89796) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Denom)

	return Tuple45c89796StaticSize + dynamicSize
}

// EncodeTo encodes Tuple45c89796 to ABI bytes in the provided buffer
func (value Tuple45c89796) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := Tuple45c89796StaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Denom: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Denom, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Amount: uint256
	if _, err := abi.EncodeUint256(value.Amount, buf[32:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes Tuple45c89796 to ABI bytes
func (value Tuple45c89796) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Tuple45c89796 from ABI bytes in the provided buffer
func (t *Tuple45c89796) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 64
	// Decode dynamic field Denom
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Denom")
		}
		t.Denom, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode static field Amount: uint256
	t.Amount, _, err = abi.DecodeUint256(data[32:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

const UserStaticSize = 96

// User represents an ABI tuple
type User struct {
	Address common.Address
	Name    string
	Age     *big.Int
}

// EncodedSize returns the total encoded size of User
func (t User) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Name)

	return UserStaticSize + dynamicSize
}

// EncodeTo encodes User to ABI bytes in the provided buffer
func (value User) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := UserStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Address: address
	if _, err := abi.EncodeAddress(value.Address, buf[0:]); err != nil {
		return 0, err
	}

	// Field Name: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Name, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Age: uint256
	if _, err := abi.EncodeUint256(value.Age, buf[64:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes User to ABI bytes
func (value User) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes User from ABI bytes in the provided buffer
func (t *User) Decode(data []byte) (int, error) {
	if len(data) < 96 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 96
	// Decode static field Address: address
	t.Address, _, err = abi.DecodeAddress(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Name
	{
		offset := int(binary.BigEndian.Uint64(data[32+24 : 32+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Name")
		}
		t.Name, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode static field Age: uint256
	t.Age, _, err = abi.DecodeUint256(data[64:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

const UserDataStaticSize = 64

// UserData represents an ABI tuple
type UserData struct {
	Id   *big.Int
	Data UserMetadata
}

// EncodedSize returns the total encoded size of UserData
func (t UserData) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.Data.EncodedSize()

	return UserDataStaticSize + dynamicSize
}

// EncodeTo encodes UserData to ABI bytes in the provided buffer
func (value UserData) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := UserDataStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Id: uint256
	if _, err := abi.EncodeUint256(value.Id, buf[0:]); err != nil {
		return 0, err
	}

	// Field Data: (bytes32,string)
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.Data.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes UserData to ABI bytes
func (value UserData) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes UserData from ABI bytes in the provided buffer
func (t *UserData) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 64
	// Decode static field Id: uint256
	t.Id, _, err = abi.DecodeUint256(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Data
	{
		offset := int(binary.BigEndian.Uint64(data[32+24 : 32+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Data")
		}
		n, err = t.Data.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

const UserMetadataStaticSize = 64

// UserMetadata represents an ABI tuple
type UserMetadata struct {
	Key   [32]byte
	Value string
}

// EncodedSize returns the total encoded size of UserMetadata
func (t UserMetadata) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Value)

	return UserMetadataStaticSize + dynamicSize
}

// EncodeTo encodes UserMetadata to ABI bytes in the provided buffer
func (value UserMetadata) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := UserMetadataStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Key: bytes32
	if _, err := abi.EncodeBytes32(value.Key, buf[0:]); err != nil {
		return 0, err
	}

	// Field Value: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Value, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes UserMetadata to ABI bytes
func (value UserMetadata) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes UserMetadata from ABI bytes in the provided buffer
func (t *UserMetadata) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 64
	// Decode static field Key: bytes32
	t.Key, _, err = abi.DecodeBytes32(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Value
	{
		offset := int(binary.BigEndian.Uint64(data[32+24 : 32+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Value")
		}
		t.Value, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// TestEncodeAddressArray10 encodes address[10] to ABI bytes
func TestEncodeAddressArray10(value [10]common.Address, buf []byte) (int, error) {
	// Encode fixed-size array with static elements
	if _, err := abi.EncodeAddress(value[0], buf[0:]); err != nil {
		return 0, err
	}
	if _, err := abi.EncodeAddress(value[1], buf[32:]); err != nil {
		return 0, err
	}
	if _, err := abi.EncodeAddress(value[2], buf[64:]); err != nil {
		return 0, err
	}
	if _, err := abi.EncodeAddress(value[3], buf[96:]); err != nil {
		return 0, err
	}
	if _, err := abi.EncodeAddress(value[4], buf[128:]); err != nil {
		return 0, err
	}
	if _, err := abi.EncodeAddress(value[5], buf[160:]); err != nil {
		return 0, err
	}
	if _, err := abi.EncodeAddress(value[6], buf[192:]); err != nil {
		return 0, err
	}
	if _, err := abi.EncodeAddress(value[7], buf[224:]); err != nil {
		return 0, err
	}
	if _, err := abi.EncodeAddress(value[8], buf[256:]); err != nil {
		return 0, err
	}
	if _, err := abi.EncodeAddress(value[9], buf[288:]); err != nil {
		return 0, err
	}

	return 320, nil
}

// TestEncodeTuple45c89796Slice encodes (string,uint256)[] to ABI bytes
func TestEncodeTuple45c89796Slice(value []Tuple45c89796, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with dynamic types
	var offset int
	dynamicOffset := len(value) * 32
	for _, elem := range value {
		// Write offset for element
		offset += 32
		binary.BigEndian.PutUint64(buf[offset-8:offset], uint64(dynamicOffset))

		// Write element at dynamic region
		n, err := elem.EncodeTo(buf[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}

	return dynamicOffset + 32, nil
}

// TestEncodeUint256Array10 encodes uint256[10] to ABI bytes
func TestEncodeUint256Array10(value [10]*big.Int, buf []byte) (int, error) {
	// Encode fixed-size array with static elements
	if _, err := abi.EncodeUint256(value[0], buf[0:]); err != nil {
		return 0, err
	}
	if _, err := abi.EncodeUint256(value[1], buf[32:]); err != nil {
		return 0, err
	}
	if _, err := abi.EncodeUint256(value[2], buf[64:]); err != nil {
		return 0, err
	}
	if _, err := abi.EncodeUint256(value[3], buf[96:]); err != nil {
		return 0, err
	}
	if _, err := abi.EncodeUint256(value[4], buf[128:]); err != nil {
		return 0, err
	}
	if _, err := abi.EncodeUint256(value[5], buf[160:]); err != nil {
		return 0, err
	}
	if _, err := abi.EncodeUint256(value[6], buf[192:]); err != nil {
		return 0, err
	}
	if _, err := abi.EncodeUint256(value[7], buf[224:]); err != nil {
		return 0, err
	}
	if _, err := abi.EncodeUint256(value[8], buf[256:]); err != nil {
		return 0, err
	}
	if _, err := abi.EncodeUint256(value[9], buf[288:]); err != nil {
		return 0, err
	}

	return 320, nil
}

// TestEncodeUserDataSlice encodes (uint256,(bytes32,string))[] to ABI bytes
func TestEncodeUserDataSlice(value []UserData, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with dynamic types
	var offset int
	dynamicOffset := len(value) * 32
	for _, elem := range value {
		// Write offset for element
		offset += 32
		binary.BigEndian.PutUint64(buf[offset-8:offset], uint64(dynamicOffset))

		// Write element at dynamic region
		n, err := elem.EncodeTo(buf[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}

	return dynamicOffset + 32, nil
}

// TestSizeTuple45c89796Slice returns the encoded size of (string,uint256)[]
func TestSizeTuple45c89796Slice(value []Tuple45c89796) int {
	size := 32 + 32*len(value) // length + offset pointers for dynamic elements
	for _, elem := range value {
		size += elem.EncodedSize()
	}
	return size
}

// TestSizeUserDataSlice returns the encoded size of (uint256,(bytes32,string))[]
func TestSizeUserDataSlice(value []UserData) int {
	size := 32 + 32*len(value) // length + offset pointers for dynamic elements
	for _, elem := range value {
		size += elem.EncodedSize()
	}
	return size
}

// TestDecodeAddressArray10 decodes address[10] from ABI bytes
func TestDecodeAddressArray10(data []byte) ([10]common.Address, int, error) {
	// Decode fixed-size array with static elements
	var (
		result [10]common.Address
		err    error
	)
	if len(data) < 320 {
		return result, 0, io.ErrUnexpectedEOF
	}
	// Element 0
	result[0], _, err = abi.DecodeAddress(data[0:])
	if err != nil {
		return result, 0, err
	}
	// Element 1
	result[1], _, err = abi.DecodeAddress(data[32:])
	if err != nil {
		return result, 0, err
	}
	// Element 2
	result[2], _, err = abi.DecodeAddress(data[64:])
	if err != nil {
		return result, 0, err
	}
	// Element 3
	result[3], _, err = abi.DecodeAddress(data[96:])
	if err != nil {
		return result, 0, err
	}
	// Element 4
	result[4], _, err = abi.DecodeAddress(data[128:])
	if err != nil {
		return result, 0, err
	}
	// Element 5
	result[5], _, err = abi.DecodeAddress(data[160:])
	if err != nil {
		return result, 0, err
	}
	// Element 6
	result[6], _, err = abi.DecodeAddress(data[192:])
	if err != nil {
		return result, 0, err
	}
	// Element 7
	result[7], _, err = abi.DecodeAddress(data[224:])
	if err != nil {
		return result, 0, err
	}
	// Element 8
	result[8], _, err = abi.DecodeAddress(data[256:])
	if err != nil {
		return result, 0, err
	}
	// Element 9
	result[9], _, err = abi.DecodeAddress(data[288:])
	if err != nil {
		return result, 0, err
	}
	return result, 320, nil
}

// TestDecodeTuple45c89796Slice decodes (string,uint256)[] from ABI bytes
func TestDecodeTuple45c89796Slice(data []byte) ([]Tuple45c89796, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 32*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with dynamic types
	result := make([]Tuple45c89796, length)
	dynamicOffset := length * 32
	for i := 0; i < length; i++ {
		offset += 32
		tmp := int(binary.BigEndian.Uint64(data[offset-8 : offset]))
		if dynamicOffset != tmp {
			return nil, 0, fmt.Errorf("invalid offset for slice element %d: expected %d, got %d", i, dynamicOffset, tmp)
		}
		n, err = result[i].Decode(data[dynamicOffset:])
		if err != nil {
			return nil, 0, err
		}
		dynamicOffset += n
	}
	return result, dynamicOffset + 32, nil
}

// TestDecodeUint256Array10 decodes uint256[10] from ABI bytes
func TestDecodeUint256Array10(data []byte) ([10]*big.Int, int, error) {
	// Decode fixed-size array with static elements
	var (
		result [10]*big.Int
		err    error
	)
	if len(data) < 320 {
		return result, 0, io.ErrUnexpectedEOF
	}
	// Element 0
	result[0], _, err = abi.DecodeUint256(data[0:])
	if err != nil {
		return result, 0, err
	}
	// Element 1
	result[1], _, err = abi.DecodeUint256(data[32:])
	if err != nil {
		return result, 0, err
	}
	// Element 2
	result[2], _, err = abi.DecodeUint256(data[64:])
	if err != nil {
		return result, 0, err
	}
	// Element 3
	result[3], _, err = abi.DecodeUint256(data[96:])
	if err != nil {
		return result, 0, err
	}
	// Element 4
	result[4], _, err = abi.DecodeUint256(data[128:])
	if err != nil {
		return result, 0, err
	}
	// Element 5
	result[5], _, err = abi.DecodeUint256(data[160:])
	if err != nil {
		return result, 0, err
	}
	// Element 6
	result[6], _, err = abi.DecodeUint256(data[192:])
	if err != nil {
		return result, 0, err
	}
	// Element 7
	result[7], _, err = abi.DecodeUint256(data[224:])
	if err != nil {
		return result, 0, err
	}
	// Element 8
	result[8], _, err = abi.DecodeUint256(data[256:])
	if err != nil {
		return result, 0, err
	}
	// Element 9
	result[9], _, err = abi.DecodeUint256(data[288:])
	if err != nil {
		return result, 0, err
	}
	return result, 320, nil
}

// TestDecodeUserDataSlice decodes (uint256,(bytes32,string))[] from ABI bytes
func TestDecodeUserDataSlice(data []byte) ([]UserData, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 32*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with dynamic types
	result := make([]UserData, length)
	dynamicOffset := length * 32
	for i := 0; i < length; i++ {
		offset += 32
		tmp := int(binary.BigEndian.Uint64(data[offset-8 : offset]))
		if dynamicOffset != tmp {
			return nil, 0, fmt.Errorf("invalid offset for slice element %d: expected %d, got %d", i, dynamicOffset, tmp)
		}
		n, err = result[i].Decode(data[dynamicOffset:])
		if err != nil {
			return nil, 0, err
		}
		dynamicOffset += n
	}
	return result, dynamicOffset + 32, nil
}

const BalanceOfCallStaticSize = 32

// BalanceOfCall represents an ABI tuple
type BalanceOfCall struct {
	Account common.Address
}

// EncodedSize returns the total encoded size of BalanceOfCall
func (t BalanceOfCall) EncodedSize() int {
	dynamicSize := 0

	return BalanceOfCallStaticSize + dynamicSize
}

// EncodeTo encodes BalanceOfCall to ABI bytes in the provided buffer
func (value BalanceOfCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := BalanceOfCallStaticSize // Start dynamic data after static section
	// Field Account: address
	if _, err := abi.EncodeAddress(value.Account, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes BalanceOfCall to ABI bytes
func (value BalanceOfCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes BalanceOfCall from ABI bytes in the provided buffer
func (t *BalanceOfCall) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Account: address
	t.Account, _, err = abi.DecodeAddress(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t BalanceOfCall) GetMethodName() string {
	return "balanceOf"
}

// GetMethodID returns the function name
func (t BalanceOfCall) GetMethodID() [4]byte {
	return BalanceOfSelector
}

// EncodeWithSelector encodes balanceOf arguments to ABI bytes including function selector
func (t BalanceOfCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], BalanceOfSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const BalanceOfReturnStaticSize = 32

// BalanceOfReturn represents an ABI tuple
type BalanceOfReturn struct {
	Field1 *big.Int
}

// EncodedSize returns the total encoded size of BalanceOfReturn
func (t BalanceOfReturn) EncodedSize() int {
	dynamicSize := 0

	return BalanceOfReturnStaticSize + dynamicSize
}

// EncodeTo encodes BalanceOfReturn to ABI bytes in the provided buffer
func (value BalanceOfReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := BalanceOfReturnStaticSize // Start dynamic data after static section
	// Field Field1: uint256
	if _, err := abi.EncodeUint256(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes BalanceOfReturn to ABI bytes
func (value BalanceOfReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes BalanceOfReturn from ABI bytes in the provided buffer
func (t *BalanceOfReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: uint256
	t.Field1, _, err = abi.DecodeUint256(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

const BatchProcessCallStaticSize = 32

// BatchProcessCall represents an ABI tuple
type BatchProcessCall struct {
	Users []UserData
}

// EncodedSize returns the total encoded size of BatchProcessCall
func (t BatchProcessCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += TestSizeUserDataSlice(t.Users)

	return BatchProcessCallStaticSize + dynamicSize
}

// EncodeTo encodes BatchProcessCall to ABI bytes in the provided buffer
func (value BatchProcessCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := BatchProcessCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Users: (uint256,(bytes32,string))[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = TestEncodeUserDataSlice(value.Users, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes BatchProcessCall to ABI bytes
func (value BatchProcessCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes BatchProcessCall from ABI bytes in the provided buffer
func (t *BatchProcessCall) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field Users
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Users")
		}
		t.Users, n, err = TestDecodeUserDataSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t BatchProcessCall) GetMethodName() string {
	return "batchProcess"
}

// GetMethodID returns the function name
func (t BatchProcessCall) GetMethodID() [4]byte {
	return BatchProcessSelector
}

// EncodeWithSelector encodes batchProcess arguments to ABI bytes including function selector
func (t BatchProcessCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], BatchProcessSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const BatchProcessReturnStaticSize = 32

// BatchProcessReturn represents an ABI tuple
type BatchProcessReturn struct {
	Field1 bool
}

// EncodedSize returns the total encoded size of BatchProcessReturn
func (t BatchProcessReturn) EncodedSize() int {
	dynamicSize := 0

	return BatchProcessReturnStaticSize + dynamicSize
}

// EncodeTo encodes BatchProcessReturn to ABI bytes in the provided buffer
func (value BatchProcessReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := BatchProcessReturnStaticSize // Start dynamic data after static section
	// Field Field1: bool
	if _, err := abi.EncodeBool(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes BatchProcessReturn to ABI bytes
func (value BatchProcessReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes BatchProcessReturn from ABI bytes in the provided buffer
func (t *BatchProcessReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bool
	t.Field1, _, err = abi.DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// CommunityPoolCall represents the input arguments for communityPool function
type CommunityPoolCall struct {
	abi.EmptyTuple
}

// GetMethodName returns the function name
func (t CommunityPoolCall) GetMethodName() string {
	return "communityPool"
}

// GetMethodID returns the function name
func (t CommunityPoolCall) GetMethodID() [4]byte {
	return CommunityPoolSelector
}

// EncodeWithSelector encodes communityPool arguments to ABI bytes including function selector
func (t CommunityPoolCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], CommunityPoolSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const CommunityPoolReturnStaticSize = 32

// CommunityPoolReturn represents an ABI tuple
type CommunityPoolReturn struct {
	Coins []Tuple45c89796
}

// EncodedSize returns the total encoded size of CommunityPoolReturn
func (t CommunityPoolReturn) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += TestSizeTuple45c89796Slice(t.Coins)

	return CommunityPoolReturnStaticSize + dynamicSize
}

// EncodeTo encodes CommunityPoolReturn to ABI bytes in the provided buffer
func (value CommunityPoolReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := CommunityPoolReturnStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Coins: (string,uint256)[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = TestEncodeTuple45c89796Slice(value.Coins, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes CommunityPoolReturn to ABI bytes
func (value CommunityPoolReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes CommunityPoolReturn from ABI bytes in the provided buffer
func (t *CommunityPoolReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field Coins
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Coins")
		}
		t.Coins, n, err = TestDecodeTuple45c89796Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// EmptyArgsCall represents the input arguments for emptyArgs function
type EmptyArgsCall struct {
	abi.EmptyTuple
}

// GetMethodName returns the function name
func (t EmptyArgsCall) GetMethodName() string {
	return "emptyArgs"
}

// GetMethodID returns the function name
func (t EmptyArgsCall) GetMethodID() [4]byte {
	return EmptyArgsSelector
}

// EncodeWithSelector encodes emptyArgs arguments to ABI bytes including function selector
func (t EmptyArgsCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], EmptyArgsSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// EmptyArgsReturn represents the input arguments for emptyArgs function
type EmptyArgsReturn struct {
	abi.EmptyTuple
}

const GetBalancesCallStaticSize = 320

// GetBalancesCall represents an ABI tuple
type GetBalancesCall struct {
	Accounts [10]common.Address
}

// EncodedSize returns the total encoded size of GetBalancesCall
func (t GetBalancesCall) EncodedSize() int {
	dynamicSize := 0

	return GetBalancesCallStaticSize + dynamicSize
}

// EncodeTo encodes GetBalancesCall to ABI bytes in the provided buffer
func (value GetBalancesCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := GetBalancesCallStaticSize // Start dynamic data after static section
	// Field Accounts: address[10]
	if _, err := TestEncodeAddressArray10(value.Accounts, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes GetBalancesCall to ABI bytes
func (value GetBalancesCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes GetBalancesCall from ABI bytes in the provided buffer
func (t *GetBalancesCall) Decode(data []byte) (int, error) {
	if len(data) < 320 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 320
	// Decode static field Accounts: address[10]
	t.Accounts, _, err = TestDecodeAddressArray10(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t GetBalancesCall) GetMethodName() string {
	return "getBalances"
}

// GetMethodID returns the function name
func (t GetBalancesCall) GetMethodID() [4]byte {
	return GetBalancesSelector
}

// EncodeWithSelector encodes getBalances arguments to ABI bytes including function selector
func (t GetBalancesCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], GetBalancesSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const GetBalancesReturnStaticSize = 320

// GetBalancesReturn represents an ABI tuple
type GetBalancesReturn struct {
	Field1 [10]*big.Int
}

// EncodedSize returns the total encoded size of GetBalancesReturn
func (t GetBalancesReturn) EncodedSize() int {
	dynamicSize := 0

	return GetBalancesReturnStaticSize + dynamicSize
}

// EncodeTo encodes GetBalancesReturn to ABI bytes in the provided buffer
func (value GetBalancesReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := GetBalancesReturnStaticSize // Start dynamic data after static section
	// Field Field1: uint256[10]
	if _, err := TestEncodeUint256Array10(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes GetBalancesReturn to ABI bytes
func (value GetBalancesReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes GetBalancesReturn from ABI bytes in the provided buffer
func (t *GetBalancesReturn) Decode(data []byte) (int, error) {
	if len(data) < 320 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 320
	// Decode static field Field1: uint256[10]
	t.Field1, _, err = TestDecodeUint256Array10(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

const ProcessUserDataCallStaticSize = 64

// ProcessUserDataCall represents an ABI tuple
type ProcessUserDataCall struct {
	User1 User
	User2 User
}

// EncodedSize returns the total encoded size of ProcessUserDataCall
func (t ProcessUserDataCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.User1.EncodedSize()
	dynamicSize += t.User2.EncodedSize()

	return ProcessUserDataCallStaticSize + dynamicSize
}

// EncodeTo encodes ProcessUserDataCall to ABI bytes in the provided buffer
func (value ProcessUserDataCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := ProcessUserDataCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field User1: (address,string,uint256)
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.User1.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field User2: (address,string,uint256)
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.User2.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes ProcessUserDataCall to ABI bytes
func (value ProcessUserDataCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes ProcessUserDataCall from ABI bytes in the provided buffer
func (t *ProcessUserDataCall) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 64
	// Decode dynamic field User1
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field User1")
		}
		n, err = t.User1.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field User2
	{
		offset := int(binary.BigEndian.Uint64(data[32+24 : 32+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field User2")
		}
		n, err = t.User2.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t ProcessUserDataCall) GetMethodName() string {
	return "processUserData"
}

// GetMethodID returns the function name
func (t ProcessUserDataCall) GetMethodID() [4]byte {
	return ProcessUserDataSelector
}

// EncodeWithSelector encodes processUserData arguments to ABI bytes including function selector
func (t ProcessUserDataCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], ProcessUserDataSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const ProcessUserDataReturnStaticSize = 32

// ProcessUserDataReturn represents an ABI tuple
type ProcessUserDataReturn struct {
	Field1 bool
}

// EncodedSize returns the total encoded size of ProcessUserDataReturn
func (t ProcessUserDataReturn) EncodedSize() int {
	dynamicSize := 0

	return ProcessUserDataReturnStaticSize + dynamicSize
}

// EncodeTo encodes ProcessUserDataReturn to ABI bytes in the provided buffer
func (value ProcessUserDataReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := ProcessUserDataReturnStaticSize // Start dynamic data after static section
	// Field Field1: bool
	if _, err := abi.EncodeBool(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes ProcessUserDataReturn to ABI bytes
func (value ProcessUserDataReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes ProcessUserDataReturn from ABI bytes in the provided buffer
func (t *ProcessUserDataReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bool
	t.Field1, _, err = abi.DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

const SetDataCallStaticSize = 64

// SetDataCall represents an ABI tuple
type SetDataCall struct {
	Key   [32]byte
	Value []byte
}

// EncodedSize returns the total encoded size of SetDataCall
func (t SetDataCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeBytes(t.Value)

	return SetDataCallStaticSize + dynamicSize
}

// EncodeTo encodes SetDataCall to ABI bytes in the provided buffer
func (value SetDataCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := SetDataCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Key: bytes32
	if _, err := abi.EncodeBytes32(value.Key, buf[0:]); err != nil {
		return 0, err
	}

	// Field Value: bytes
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeBytes(value.Value, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes SetDataCall to ABI bytes
func (value SetDataCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes SetDataCall from ABI bytes in the provided buffer
func (t *SetDataCall) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 64
	// Decode static field Key: bytes32
	t.Key, _, err = abi.DecodeBytes32(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Value
	{
		offset := int(binary.BigEndian.Uint64(data[32+24 : 32+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Value")
		}
		t.Value, n, err = abi.DecodeBytes(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t SetDataCall) GetMethodName() string {
	return "setData"
}

// GetMethodID returns the function name
func (t SetDataCall) GetMethodID() [4]byte {
	return SetDataSelector
}

// EncodeWithSelector encodes setData arguments to ABI bytes including function selector
func (t SetDataCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], SetDataSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// SetDataReturn represents the input arguments for setData function
type SetDataReturn struct {
	abi.EmptyTuple
}

const SetMessageCallStaticSize = 32

// SetMessageCall represents an ABI tuple
type SetMessageCall struct {
	Message string
}

// EncodedSize returns the total encoded size of SetMessageCall
func (t SetMessageCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Message)

	return SetMessageCallStaticSize + dynamicSize
}

// EncodeTo encodes SetMessageCall to ABI bytes in the provided buffer
func (value SetMessageCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := SetMessageCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Message: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Message, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes SetMessageCall to ABI bytes
func (value SetMessageCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes SetMessageCall from ABI bytes in the provided buffer
func (t *SetMessageCall) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field Message
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Message")
		}
		t.Message, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t SetMessageCall) GetMethodName() string {
	return "setMessage"
}

// GetMethodID returns the function name
func (t SetMessageCall) GetMethodID() [4]byte {
	return SetMessageSelector
}

// EncodeWithSelector encodes setMessage arguments to ABI bytes including function selector
func (t SetMessageCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], SetMessageSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const SetMessageReturnStaticSize = 32

// SetMessageReturn represents an ABI tuple
type SetMessageReturn struct {
	Field1 bool
}

// EncodedSize returns the total encoded size of SetMessageReturn
func (t SetMessageReturn) EncodedSize() int {
	dynamicSize := 0

	return SetMessageReturnStaticSize + dynamicSize
}

// EncodeTo encodes SetMessageReturn to ABI bytes in the provided buffer
func (value SetMessageReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := SetMessageReturnStaticSize // Start dynamic data after static section
	// Field Field1: bool
	if _, err := abi.EncodeBool(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes SetMessageReturn to ABI bytes
func (value SetMessageReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes SetMessageReturn from ABI bytes in the provided buffer
func (t *SetMessageReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bool
	t.Field1, _, err = abi.DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

const SmallIntegersCallStaticSize = 256

// SmallIntegersCall represents an ABI tuple
type SmallIntegersCall struct {
	U8  uint8
	U16 uint16
	U32 uint32
	U64 uint64
	I8  int8
	I16 int16
	I32 int32
	I64 int64
}

// EncodedSize returns the total encoded size of SmallIntegersCall
func (t SmallIntegersCall) EncodedSize() int {
	dynamicSize := 0

	return SmallIntegersCallStaticSize + dynamicSize
}

// EncodeTo encodes SmallIntegersCall to ABI bytes in the provided buffer
func (value SmallIntegersCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := SmallIntegersCallStaticSize // Start dynamic data after static section
	// Field U8: uint8
	if _, err := abi.EncodeUint8(value.U8, buf[0:]); err != nil {
		return 0, err
	}

	// Field U16: uint16
	if _, err := abi.EncodeUint16(value.U16, buf[32:]); err != nil {
		return 0, err
	}

	// Field U32: uint32
	if _, err := abi.EncodeUint32(value.U32, buf[64:]); err != nil {
		return 0, err
	}

	// Field U64: uint64
	if _, err := abi.EncodeUint64(value.U64, buf[96:]); err != nil {
		return 0, err
	}

	// Field I8: int8
	if _, err := abi.EncodeInt8(value.I8, buf[128:]); err != nil {
		return 0, err
	}

	// Field I16: int16
	if _, err := abi.EncodeInt16(value.I16, buf[160:]); err != nil {
		return 0, err
	}

	// Field I32: int32
	if _, err := abi.EncodeInt32(value.I32, buf[192:]); err != nil {
		return 0, err
	}

	// Field I64: int64
	if _, err := abi.EncodeInt64(value.I64, buf[224:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes SmallIntegersCall to ABI bytes
func (value SmallIntegersCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes SmallIntegersCall from ABI bytes in the provided buffer
func (t *SmallIntegersCall) Decode(data []byte) (int, error) {
	if len(data) < 256 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 256
	// Decode static field U8: uint8
	t.U8, _, err = abi.DecodeUint8(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode static field U16: uint16
	t.U16, _, err = abi.DecodeUint16(data[32:])
	if err != nil {
		return 0, err
	}
	// Decode static field U32: uint32
	t.U32, _, err = abi.DecodeUint32(data[64:])
	if err != nil {
		return 0, err
	}
	// Decode static field U64: uint64
	t.U64, _, err = abi.DecodeUint64(data[96:])
	if err != nil {
		return 0, err
	}
	// Decode static field I8: int8
	t.I8, _, err = abi.DecodeInt8(data[128:])
	if err != nil {
		return 0, err
	}
	// Decode static field I16: int16
	t.I16, _, err = abi.DecodeInt16(data[160:])
	if err != nil {
		return 0, err
	}
	// Decode static field I32: int32
	t.I32, _, err = abi.DecodeInt32(data[192:])
	if err != nil {
		return 0, err
	}
	// Decode static field I64: int64
	t.I64, _, err = abi.DecodeInt64(data[224:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t SmallIntegersCall) GetMethodName() string {
	return "smallIntegers"
}

// GetMethodID returns the function name
func (t SmallIntegersCall) GetMethodID() [4]byte {
	return SmallIntegersSelector
}

// EncodeWithSelector encodes smallIntegers arguments to ABI bytes including function selector
func (t SmallIntegersCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], SmallIntegersSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const SmallIntegersReturnStaticSize = 32

// SmallIntegersReturn represents an ABI tuple
type SmallIntegersReturn struct {
	Field1 bool
}

// EncodedSize returns the total encoded size of SmallIntegersReturn
func (t SmallIntegersReturn) EncodedSize() int {
	dynamicSize := 0

	return SmallIntegersReturnStaticSize + dynamicSize
}

// EncodeTo encodes SmallIntegersReturn to ABI bytes in the provided buffer
func (value SmallIntegersReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := SmallIntegersReturnStaticSize // Start dynamic data after static section
	// Field Field1: bool
	if _, err := abi.EncodeBool(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes SmallIntegersReturn to ABI bytes
func (value SmallIntegersReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes SmallIntegersReturn from ABI bytes in the provided buffer
func (t *SmallIntegersReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bool
	t.Field1, _, err = abi.DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

const TransferCallStaticSize = 64

// TransferCall represents an ABI tuple
type TransferCall struct {
	To     common.Address
	Amount *big.Int
}

// EncodedSize returns the total encoded size of TransferCall
func (t TransferCall) EncodedSize() int {
	dynamicSize := 0

	return TransferCallStaticSize + dynamicSize
}

// EncodeTo encodes TransferCall to ABI bytes in the provided buffer
func (value TransferCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TransferCallStaticSize // Start dynamic data after static section
	// Field To: address
	if _, err := abi.EncodeAddress(value.To, buf[0:]); err != nil {
		return 0, err
	}

	// Field Amount: uint256
	if _, err := abi.EncodeUint256(value.Amount, buf[32:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TransferCall to ABI bytes
func (value TransferCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TransferCall from ABI bytes in the provided buffer
func (t *TransferCall) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 64
	// Decode static field To: address
	t.To, _, err = abi.DecodeAddress(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode static field Amount: uint256
	t.Amount, _, err = abi.DecodeUint256(data[32:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t TransferCall) GetMethodName() string {
	return "transfer"
}

// GetMethodID returns the function name
func (t TransferCall) GetMethodID() [4]byte {
	return TransferSelector
}

// EncodeWithSelector encodes transfer arguments to ABI bytes including function selector
func (t TransferCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TransferSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const TransferReturnStaticSize = 32

// TransferReturn represents an ABI tuple
type TransferReturn struct {
	Field1 bool
}

// EncodedSize returns the total encoded size of TransferReturn
func (t TransferReturn) EncodedSize() int {
	dynamicSize := 0

	return TransferReturnStaticSize + dynamicSize
}

// EncodeTo encodes TransferReturn to ABI bytes in the provided buffer
func (value TransferReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TransferReturnStaticSize // Start dynamic data after static section
	// Field Field1: bool
	if _, err := abi.EncodeBool(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TransferReturn to ABI bytes
func (value TransferReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TransferReturn from ABI bytes in the provided buffer
func (t *TransferReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bool
	t.Field1, _, err = abi.DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

const TransferBatchCallStaticSize = 64

// TransferBatchCall represents an ABI tuple
type TransferBatchCall struct {
	Recipients []common.Address
	Amounts    []*big.Int
}

// EncodedSize returns the total encoded size of TransferBatchCall
func (t TransferBatchCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeAddressSlice(t.Recipients)
	dynamicSize += abi.SizeUint256Slice(t.Amounts)

	return TransferBatchCallStaticSize + dynamicSize
}

// EncodeTo encodes TransferBatchCall to ABI bytes in the provided buffer
func (value TransferBatchCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TransferBatchCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Recipients: address[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeAddressSlice(value.Recipients, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Amounts: uint256[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeUint256Slice(value.Amounts, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes TransferBatchCall to ABI bytes
func (value TransferBatchCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TransferBatchCall from ABI bytes in the provided buffer
func (t *TransferBatchCall) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 64
	// Decode dynamic field Recipients
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Recipients")
		}
		t.Recipients, n, err = abi.DecodeAddressSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Amounts
	{
		offset := int(binary.BigEndian.Uint64(data[32+24 : 32+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Amounts")
		}
		t.Amounts, n, err = abi.DecodeUint256Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t TransferBatchCall) GetMethodName() string {
	return "transferBatch"
}

// GetMethodID returns the function name
func (t TransferBatchCall) GetMethodID() [4]byte {
	return TransferBatchSelector
}

// EncodeWithSelector encodes transferBatch arguments to ABI bytes including function selector
func (t TransferBatchCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TransferBatchSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const TransferBatchReturnStaticSize = 32

// TransferBatchReturn represents an ABI tuple
type TransferBatchReturn struct {
	Field1 bool
}

// EncodedSize returns the total encoded size of TransferBatchReturn
func (t TransferBatchReturn) EncodedSize() int {
	dynamicSize := 0

	return TransferBatchReturnStaticSize + dynamicSize
}

// EncodeTo encodes TransferBatchReturn to ABI bytes in the provided buffer
func (value TransferBatchReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TransferBatchReturnStaticSize // Start dynamic data after static section
	// Field Field1: bool
	if _, err := abi.EncodeBool(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TransferBatchReturn to ABI bytes
func (value TransferBatchReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TransferBatchReturn from ABI bytes in the provided buffer
func (t *TransferBatchReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bool
	t.Field1, _, err = abi.DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

const UpdateProfileCallStaticSize = 96

// UpdateProfileCall represents an ABI tuple
type UpdateProfileCall struct {
	User common.Address
	Name string
	Age  *big.Int
}

// EncodedSize returns the total encoded size of UpdateProfileCall
func (t UpdateProfileCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Name)

	return UpdateProfileCallStaticSize + dynamicSize
}

// EncodeTo encodes UpdateProfileCall to ABI bytes in the provided buffer
func (value UpdateProfileCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := UpdateProfileCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field User: address
	if _, err := abi.EncodeAddress(value.User, buf[0:]); err != nil {
		return 0, err
	}

	// Field Name: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Name, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Age: uint256
	if _, err := abi.EncodeUint256(value.Age, buf[64:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes UpdateProfileCall to ABI bytes
func (value UpdateProfileCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes UpdateProfileCall from ABI bytes in the provided buffer
func (t *UpdateProfileCall) Decode(data []byte) (int, error) {
	if len(data) < 96 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 96
	// Decode static field User: address
	t.User, _, err = abi.DecodeAddress(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Name
	{
		offset := int(binary.BigEndian.Uint64(data[32+24 : 32+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Name")
		}
		t.Name, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode static field Age: uint256
	t.Age, _, err = abi.DecodeUint256(data[64:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t UpdateProfileCall) GetMethodName() string {
	return "updateProfile"
}

// GetMethodID returns the function name
func (t UpdateProfileCall) GetMethodID() [4]byte {
	return UpdateProfileSelector
}

// EncodeWithSelector encodes updateProfile arguments to ABI bytes including function selector
func (t UpdateProfileCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], UpdateProfileSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const UpdateProfileReturnStaticSize = 32

// UpdateProfileReturn represents an ABI tuple
type UpdateProfileReturn struct {
	Field1 bool
}

// EncodedSize returns the total encoded size of UpdateProfileReturn
func (t UpdateProfileReturn) EncodedSize() int {
	dynamicSize := 0

	return UpdateProfileReturnStaticSize + dynamicSize
}

// EncodeTo encodes UpdateProfileReturn to ABI bytes in the provided buffer
func (value UpdateProfileReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := UpdateProfileReturnStaticSize // Start dynamic data after static section
	// Field Field1: bool
	if _, err := abi.EncodeBool(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes UpdateProfileReturn to ABI bytes
func (value UpdateProfileReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes UpdateProfileReturn from ABI bytes in the provided buffer
func (t *UpdateProfileReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bool
	t.Field1, _, err = abi.DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// Event signatures
var (
	// DynamicIndexed(string)
	DynamicIndexedEventTopic = common.Hash{0x3f, 0x9f, 0x17, 0xba, 0xc9, 0x56, 0x4d, 0x19, 0xb3, 0x0d, 0x61, 0xf0, 0xe5, 0x07, 0x81, 0x21, 0xfc, 0x40, 0xc7, 0x25, 0x4a, 0xa1, 0xba, 0xb6, 0x7e, 0xee, 0x77, 0x38, 0x8c, 0x00, 0x92, 0xbd}
)

// DynamicIndexedEvent represents the DynamicIndexed event
type DynamicIndexedEvent struct {
	DynamicIndexedEventIndexed
	DynamicIndexedEventData
}

// NewDynamicIndexedEvent constructs a new DynamicIndexed event
func NewDynamicIndexedEvent(
	denom string,
) DynamicIndexedEvent {
	return DynamicIndexedEvent{
		DynamicIndexedEventIndexed: DynamicIndexedEventIndexed{
			Denom: denom,
		},
		DynamicIndexedEventData: DynamicIndexedEventData{},
	}
}

// GetEventName returns the event name
func (e DynamicIndexedEvent) GetEventName() string {
	return "DynamicIndexed"
}

// GetEventID returns the event ID (topic)
func (e DynamicIndexedEvent) GetEventID() common.Hash {
	return DynamicIndexedEventTopic
}

// DynamicIndexed represents an ABI event
type DynamicIndexedEventIndexed struct {
	Denom string
}

// EncodeTopics encodes indexed fields of DynamicIndexed event to topics
func (e DynamicIndexedEventIndexed) EncodeTopics() ([]common.Hash, error) {
	topics := make([]common.Hash, 0, 2)
	topics = append(topics, DynamicIndexedEventTopic)
	{
		// Denom
		encodedSize := abi.SizeString(e.Denom)
		buf := make([]byte, encodedSize)
		if _, err := abi.EncodeString(e.Denom, buf); err != nil {
			return nil, err
		}
		hash := crypto.Keccak256Hash(buf)
		topics = append(topics, hash)
	}
	return topics, nil
}

// DecodeTopics decodes indexed fields of DynamicIndexed event from topics, ignore hash topics
func (e *DynamicIndexedEventIndexed) DecodeTopics(topics []common.Hash) error {
	if len(topics) != 2 {
		return fmt.Errorf("invalid number of topics for DynamicIndexed event: expected 2, got %d", len(topics))
	}
	if topics[0] != DynamicIndexedEventTopic {
		return fmt.Errorf("invalid event topic for DynamicIndexed event")
	}
	return nil
}

type DynamicIndexedEventData struct {
	abi.EmptyTuple
}
