// Code generated by go-abi. DO NOT EDIT.

package tests

import (
	"encoding/binary"
	"io"
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/yihuang/go-abi"
)

// Function selectors
var (
	// balanceOf(address)
	BalanceOfSelector = [4]byte{0x70, 0xa0, 0x82, 0x31}
	// batchProcess((uint256,(bytes32,string))[])
	BatchProcessSelector = [4]byte{0xb7, 0x78, 0x31, 0x64}
	// communityPool()
	CommunityPoolSelector = [4]byte{0x14, 0xd1, 0x40, 0xb0}
	// emptyArgs()
	EmptyArgsSelector = [4]byte{0xf9, 0xce, 0x95, 0xfe}
	// getBalances(address[10])
	GetBalancesSelector = [4]byte{0x51, 0x68, 0x3d, 0x7d}
	// processUserData((address,string,int256),(address,string,int256))
	ProcessUserDataSelector = [4]byte{0x95, 0xb2, 0x3f, 0x8a}
	// setData(bytes32,bytes)
	SetDataSelector = [4]byte{0x7f, 0x23, 0x69, 0x0c}
	// setMessage(string)
	SetMessageSelector = [4]byte{0x36, 0x8b, 0x87, 0x72}
	// smallIntegers(uint8,uint16,uint32,uint64,int8,int16,int32,int64)
	SmallIntegersSelector = [4]byte{0x98, 0x83, 0xfe, 0x4a}
	// transfer(address,uint256)
	TransferSelector = [4]byte{0xa9, 0x05, 0x9c, 0xbb}
	// transferBatch(address[],uint256[])
	TransferBatchSelector = [4]byte{0x3b, 0x3e, 0x67, 0x2f}
	// understore(string)
	UnderstoreSelector = [4]byte{0x58, 0x56, 0x2a, 0x35}
	// updateProfile(address,string,uint256)
	UpdateProfileSelector = [4]byte{0x6d, 0xe9, 0x52, 0x01}
)

// Big endian integer versions of function selectors
const (
	BalanceOfID       = 1889567281
	BatchProcessID    = 3078107492
	CommunityPoolID   = 349257904
	EmptyArgsID       = 4191065598
	GetBalancesID     = 1365785981
	ProcessUserDataID = 2511486858
	SetDataID         = 2133027084
	SetMessageID      = 915113842
	SmallIntegersID   = 2558787146
	TransferID        = 2835717307
	TransferBatchID   = 993945391
	UnderstoreID      = 1482041909
	UpdateProfileID   = 1844007425
)

const Tuple45c89796StaticSize = 64

var _ abi.Tuple = (*Tuple45c89796)(nil)

// Tuple45c89796 represents an ABI tuple
type Tuple45c89796 struct {
	Denom  string
	Amount *big.Int
}

// EncodedSize returns the total encoded size of Tuple45c89796
func (t Tuple45c89796) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Denom)

	return Tuple45c89796StaticSize + dynamicSize
}

// EncodeTo encodes Tuple45c89796 to ABI bytes in the provided buffer
func (value Tuple45c89796) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field Denom: string
	{
		n, err := abi.EncodePackedString(value.Denom, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	// Field Amount: uint256
	{
		n, err := abi.EncodePackedUint256(value.Amount, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// Encode encodes Tuple45c89796 to ABI bytes
func (value Tuple45c89796) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Tuple45c89796 from ABI bytes in the provided buffer
func (t *Tuple45c89796) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err    error
		n      int
		offset int
	)
	dynamicOffset := 64
	// Decode dynamic field Denom
	{
		offset, err = abi.DecodeSize(data[0:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		t.Denom, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode static field Amount: uint256
	t.Amount, _, err = abi.DecodeUint256(data[32:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

const UserStaticSize = 96

var _ abi.Tuple = (*User)(nil)

// User represents an ABI tuple
type User struct {
	Address common.Address
	Name    string
	Age     *big.Int
}

// EncodedSize returns the total encoded size of User
func (t User) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Name)

	return UserStaticSize + dynamicSize
}

// EncodeTo encodes User to ABI bytes in the provided buffer
func (value User) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field Address: address
	{
		n, err := abi.EncodePackedAddress(value.Address, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	// Field Name: string
	{
		n, err := abi.EncodePackedString(value.Name, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	// Field Age: int256
	{
		n, err := abi.EncodePackedInt256(value.Age, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// Encode encodes User to ABI bytes
func (value User) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes User from ABI bytes in the provided buffer
func (t *User) Decode(data []byte) (int, error) {
	if len(data) < 96 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err    error
		n      int
		offset int
	)
	dynamicOffset := 96
	// Decode static field Address: address
	t.Address, _, err = abi.DecodeAddress(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Name
	{
		offset, err = abi.DecodeSize(data[32:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		t.Name, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode static field Age: int256
	t.Age, _, err = abi.DecodeInt256(data[64:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

const UserDataStaticSize = 64

var _ abi.Tuple = (*UserData)(nil)

// UserData represents an ABI tuple
type UserData struct {
	Id   *big.Int
	Data UserMetadata
}

// EncodedSize returns the total encoded size of UserData
func (t UserData) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.Data.EncodedSize()

	return UserDataStaticSize + dynamicSize
}

// EncodeTo encodes UserData to ABI bytes in the provided buffer
func (value UserData) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field Id: uint256
	{
		n, err := abi.EncodePackedUint256(value.Id, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	// Field Data: (bytes32,string)
	{
		n, err := value.Data.EncodeTo(buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// Encode encodes UserData to ABI bytes
func (value UserData) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes UserData from ABI bytes in the provided buffer
func (t *UserData) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err    error
		n      int
		offset int
	)
	dynamicOffset := 64
	// Decode static field Id: uint256
	t.Id, _, err = abi.DecodeUint256(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Data
	{
		offset, err = abi.DecodeSize(data[32:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		n, err = t.Data.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

const UserMetadataStaticSize = 64

var _ abi.Tuple = (*UserMetadata)(nil)

// UserMetadata represents an ABI tuple
type UserMetadata struct {
	Key   [32]byte
	Value string
}

// EncodedSize returns the total encoded size of UserMetadata
func (t UserMetadata) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Value)

	return UserMetadataStaticSize + dynamicSize
}

// EncodeTo encodes UserMetadata to ABI bytes in the provided buffer
func (value UserMetadata) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field Key: bytes32
	{
		n, err := abi.EncodePackedBytes32(value.Key, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	// Field Value: string
	{
		n, err := abi.EncodePackedString(value.Value, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// Encode encodes UserMetadata to ABI bytes
func (value UserMetadata) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes UserMetadata from ABI bytes in the provided buffer
func (t *UserMetadata) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err    error
		n      int
		offset int
	)
	dynamicOffset := 64
	// Decode static field Key: bytes32
	t.Key, _, err = abi.DecodeBytes32(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Value
	{
		offset, err = abi.DecodeSize(data[32:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		t.Value, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// TestEncodeAddressArray10 encodes address[10] to ABI bytes
func TestEncodeAddressArray10(value [10]common.Address, buf []byte) (int, error) {
	// Encode fixed-size array in packed format
	var offset int
	var err error
	{
		n, err := abi.EncodePackedAddress(value[0], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedAddress(value[1], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedAddress(value[2], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedAddress(value[3], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedAddress(value[4], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedAddress(value[5], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedAddress(value[6], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedAddress(value[7], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedAddress(value[8], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedAddress(value[9], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// TestEncodePackedAddressArray10 encodes address[10] to packed ABI bytes (no padding)
func TestEncodePackedAddressArray10(value [10]common.Address, buf []byte) (int, error) {
	// Encode fixed-size array in packed format
	var offset int
	var err error
	{
		n, err := abi.EncodePackedAddress(value[0], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedAddress(value[1], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedAddress(value[2], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedAddress(value[3], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedAddress(value[4], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedAddress(value[5], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedAddress(value[6], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedAddress(value[7], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedAddress(value[8], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedAddress(value[9], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// TestEncodeTuple45c89796Slice encodes (string,uint256)[] to ABI bytes
func TestEncodeTuple45c89796Slice(value []Tuple45c89796, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with dynamic types
	var offset int
	dynamicOffset := len(value) * 32
	for _, elem := range value {
		// Write offset for element
		offset += 32
		binary.BigEndian.PutUint64(buf[offset-8:offset], uint64(dynamicOffset))

		// Write element at dynamic region
		n, err := elem.EncodeTo(buf[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}

	return dynamicOffset + 32, nil
}

// TestEncodeUint256Array10 encodes uint256[10] to ABI bytes
func TestEncodeUint256Array10(value [10]*big.Int, buf []byte) (int, error) {
	// Encode fixed-size array in packed format
	var offset int
	var err error
	{
		n, err := abi.EncodePackedUint256(value[0], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedUint256(value[1], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedUint256(value[2], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedUint256(value[3], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedUint256(value[4], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedUint256(value[5], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedUint256(value[6], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedUint256(value[7], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedUint256(value[8], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedUint256(value[9], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// TestEncodePackedUint256Array10 encodes uint256[10] to packed ABI bytes (no padding)
func TestEncodePackedUint256Array10(value [10]*big.Int, buf []byte) (int, error) {
	// Encode fixed-size array in packed format
	var offset int
	var err error
	{
		n, err := abi.EncodePackedUint256(value[0], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedUint256(value[1], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedUint256(value[2], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedUint256(value[3], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedUint256(value[4], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedUint256(value[5], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedUint256(value[6], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedUint256(value[7], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedUint256(value[8], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	{
		n, err := abi.EncodePackedUint256(value[9], buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// TestEncodeUserDataSlice encodes (uint256,(bytes32,string))[] to ABI bytes
func TestEncodeUserDataSlice(value []UserData, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with dynamic types
	var offset int
	dynamicOffset := len(value) * 32
	for _, elem := range value {
		// Write offset for element
		offset += 32
		binary.BigEndian.PutUint64(buf[offset-8:offset], uint64(dynamicOffset))

		// Write element at dynamic region
		n, err := elem.EncodeTo(buf[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}

	return dynamicOffset + 32, nil
}

// TestSizeTuple45c89796Slice returns the encoded size of (string,uint256)[]
func TestSizeTuple45c89796Slice(value []Tuple45c89796) int {
	size := 32 + 32*len(value) // length + offset pointers for dynamic elements
	for _, elem := range value {
		size += elem.EncodedSize()
	}
	return size
}

// TestSizeUserDataSlice returns the encoded size of (uint256,(bytes32,string))[]
func TestSizeUserDataSlice(value []UserData) int {
	size := 32 + 32*len(value) // length + offset pointers for dynamic elements
	for _, elem := range value {
		size += elem.EncodedSize()
	}
	return size
}

// TestDecodeAddressArray10 decodes address[10] from ABI bytes
func TestDecodeAddressArray10(data []byte) ([10]common.Address, int, error) {
	// Decode fixed-size array in packed format
	var result [10]common.Address
	var (
		n   int
		err error
	)
	var offset int
	// Element 0
	result[0], n, err = abi.DecodePackedAddress(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 1
	result[1], n, err = abi.DecodePackedAddress(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 2
	result[2], n, err = abi.DecodePackedAddress(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 3
	result[3], n, err = abi.DecodePackedAddress(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 4
	result[4], n, err = abi.DecodePackedAddress(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 5
	result[5], n, err = abi.DecodePackedAddress(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 6
	result[6], n, err = abi.DecodePackedAddress(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 7
	result[7], n, err = abi.DecodePackedAddress(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 8
	result[8], n, err = abi.DecodePackedAddress(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 9
	result[9], n, err = abi.DecodePackedAddress(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	return result, offset, nil
}

// TestDecodePackedAddressArray10 decodes address[10] from packed ABI bytes (no padding)
func TestDecodePackedAddressArray10(data []byte) ([10]common.Address, int, error) {
	// Decode fixed-size array in packed format
	var result [10]common.Address
	var (
		n   int
		err error
	)
	var offset int
	// Element 0
	result[0], n, err = abi.DecodePackedAddress(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 1
	result[1], n, err = abi.DecodePackedAddress(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 2
	result[2], n, err = abi.DecodePackedAddress(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 3
	result[3], n, err = abi.DecodePackedAddress(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 4
	result[4], n, err = abi.DecodePackedAddress(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 5
	result[5], n, err = abi.DecodePackedAddress(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 6
	result[6], n, err = abi.DecodePackedAddress(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 7
	result[7], n, err = abi.DecodePackedAddress(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 8
	result[8], n, err = abi.DecodePackedAddress(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 9
	result[9], n, err = abi.DecodePackedAddress(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	return result, offset, nil
}

// TestDecodeTuple45c89796Slice decodes (string,uint256)[] from ABI bytes
func TestDecodeTuple45c89796Slice(data []byte) ([]Tuple45c89796, int, error) {
	// Decode length
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	length, err := abi.DecodeSize(data)
	if err != nil {
		return nil, 0, err
	}
	data = data[32:]
	if length > len(data) || length*32 > len(data) {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		offset int
	)
	// Decode elements with dynamic types
	result := make([]Tuple45c89796, length)
	dynamicOffset := length * 32
	for i := 0; i < length; i++ {
		tmp, err := abi.DecodeSize(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += 32

		if dynamicOffset != tmp {
			return nil, 0, abi.ErrInvalidOffsetForSliceElement
		}
		n, err = result[i].Decode(data[dynamicOffset:])
		if err != nil {
			return nil, 0, err
		}
		dynamicOffset += n
	}
	return result, dynamicOffset + 32, nil
}

// TestDecodeUint256Array10 decodes uint256[10] from ABI bytes
func TestDecodeUint256Array10(data []byte) ([10]*big.Int, int, error) {
	// Decode fixed-size array in packed format
	var result [10]*big.Int
	var (
		n   int
		err error
	)
	var offset int
	// Element 0
	result[0], n, err = abi.DecodePackedUint256(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 1
	result[1], n, err = abi.DecodePackedUint256(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 2
	result[2], n, err = abi.DecodePackedUint256(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 3
	result[3], n, err = abi.DecodePackedUint256(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 4
	result[4], n, err = abi.DecodePackedUint256(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 5
	result[5], n, err = abi.DecodePackedUint256(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 6
	result[6], n, err = abi.DecodePackedUint256(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 7
	result[7], n, err = abi.DecodePackedUint256(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 8
	result[8], n, err = abi.DecodePackedUint256(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 9
	result[9], n, err = abi.DecodePackedUint256(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	return result, offset, nil
}

// TestDecodePackedUint256Array10 decodes uint256[10] from packed ABI bytes (no padding)
func TestDecodePackedUint256Array10(data []byte) ([10]*big.Int, int, error) {
	// Decode fixed-size array in packed format
	var result [10]*big.Int
	var (
		n   int
		err error
	)
	var offset int
	// Element 0
	result[0], n, err = abi.DecodePackedUint256(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 1
	result[1], n, err = abi.DecodePackedUint256(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 2
	result[2], n, err = abi.DecodePackedUint256(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 3
	result[3], n, err = abi.DecodePackedUint256(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 4
	result[4], n, err = abi.DecodePackedUint256(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 5
	result[5], n, err = abi.DecodePackedUint256(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 6
	result[6], n, err = abi.DecodePackedUint256(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 7
	result[7], n, err = abi.DecodePackedUint256(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 8
	result[8], n, err = abi.DecodePackedUint256(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	// Element 9
	result[9], n, err = abi.DecodePackedUint256(data[offset:])
	if err != nil {
		return result, 0, err
	}
	offset += n
	return result, offset, nil
}

// TestDecodeUserDataSlice decodes (uint256,(bytes32,string))[] from ABI bytes
func TestDecodeUserDataSlice(data []byte) ([]UserData, int, error) {
	// Decode length
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	length, err := abi.DecodeSize(data)
	if err != nil {
		return nil, 0, err
	}
	data = data[32:]
	if length > len(data) || length*32 > len(data) {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		offset int
	)
	// Decode elements with dynamic types
	result := make([]UserData, length)
	dynamicOffset := length * 32
	for i := 0; i < length; i++ {
		tmp, err := abi.DecodeSize(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += 32

		if dynamicOffset != tmp {
			return nil, 0, abi.ErrInvalidOffsetForSliceElement
		}
		n, err = result[i].Decode(data[dynamicOffset:])
		if err != nil {
			return nil, 0, err
		}
		dynamicOffset += n
	}
	return result, dynamicOffset + 32, nil
}

var _ abi.Method = (*BalanceOfCall)(nil)

const BalanceOfCallStaticSize = 32

var _ abi.Tuple = (*BalanceOfCall)(nil)

// BalanceOfCall represents an ABI tuple
type BalanceOfCall struct {
	Account common.Address
}

// EncodedSize returns the total encoded size of BalanceOfCall
func (t BalanceOfCall) EncodedSize() int {
	dynamicSize := 0

	return BalanceOfCallStaticSize + dynamicSize
}

// EncodedSizePacked returns the packed encoded size of BalanceOfCall (no padding)
func (t BalanceOfCall) EncodedSizePacked() int {
	size := 0
	size += 20
	return size
}

// EncodeTo encodes BalanceOfCall to ABI bytes in the provided buffer
func (value BalanceOfCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field Account: address
	{
		n, err := abi.EncodePackedAddress(value.Account, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// EncodeToPacked encodes BalanceOfCall to packed ABI bytes in the provided buffer (no padding)
func (value BalanceOfCall) EncodeToPacked(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field Account: address
	{
		n, err := abi.EncodePackedAddress(value.Account, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// Encode encodes BalanceOfCall to ABI bytes
func (value BalanceOfCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// EncodePacked encodes BalanceOfCall to packed ABI bytes (no padding)
func (value BalanceOfCall) EncodePacked() ([]byte, error) {
	buf := make([]byte, value.EncodedSizePacked())
	if _, err := value.EncodeToPacked(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes BalanceOfCall from ABI bytes in the provided buffer
func (t *BalanceOfCall) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Account: address
	t.Account, _, err = abi.DecodeAddress(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t BalanceOfCall) GetMethodName() string {
	return "balanceOf"
}

// GetMethodID returns the function id
func (t BalanceOfCall) GetMethodID() uint32 {
	return BalanceOfID
}

// GetMethodSelector returns the function selector
func (t BalanceOfCall) GetMethodSelector() [4]byte {
	return BalanceOfSelector
}

// EncodeWithSelector encodes balanceOf arguments to ABI bytes including function selector
func (t BalanceOfCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], BalanceOfSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewBalanceOfCall constructs a new BalanceOfCall
func NewBalanceOfCall(
	account common.Address,
) *BalanceOfCall {
	return &BalanceOfCall{
		Account: account,
	}
}

const BalanceOfReturnStaticSize = 32

var _ abi.Tuple = (*BalanceOfReturn)(nil)

// BalanceOfReturn represents an ABI tuple
type BalanceOfReturn struct {
	Field1 *big.Int
}

// EncodedSize returns the total encoded size of BalanceOfReturn
func (t BalanceOfReturn) EncodedSize() int {
	dynamicSize := 0

	return BalanceOfReturnStaticSize + dynamicSize
}

// EncodedSizePacked returns the packed encoded size of BalanceOfReturn (no padding)
func (t BalanceOfReturn) EncodedSizePacked() int {
	size := 0
	size += 32
	return size
}

// EncodeTo encodes BalanceOfReturn to ABI bytes in the provided buffer
func (value BalanceOfReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field Field1: uint256
	{
		n, err := abi.EncodePackedUint256(value.Field1, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// EncodeToPacked encodes BalanceOfReturn to packed ABI bytes in the provided buffer (no padding)
func (value BalanceOfReturn) EncodeToPacked(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field Field1: uint256
	{
		n, err := abi.EncodePackedUint256(value.Field1, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// Encode encodes BalanceOfReturn to ABI bytes
func (value BalanceOfReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// EncodePacked encodes BalanceOfReturn to packed ABI bytes (no padding)
func (value BalanceOfReturn) EncodePacked() ([]byte, error) {
	buf := make([]byte, value.EncodedSizePacked())
	if _, err := value.EncodeToPacked(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes BalanceOfReturn from ABI bytes in the provided buffer
func (t *BalanceOfReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: uint256
	t.Field1, _, err = abi.DecodeUint256(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

var _ abi.Method = (*BatchProcessCall)(nil)

const BatchProcessCallStaticSize = 32

var _ abi.Tuple = (*BatchProcessCall)(nil)

// BatchProcessCall represents an ABI tuple
type BatchProcessCall struct {
	Users []UserData
}

// EncodedSize returns the total encoded size of BatchProcessCall
func (t BatchProcessCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += TestSizeUserDataSlice(t.Users)

	return BatchProcessCallStaticSize + dynamicSize
}

// EncodeTo encodes BatchProcessCall to ABI bytes in the provided buffer
func (value BatchProcessCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field Users: (uint256,(bytes32,string))[]
	{
		n, err := TestEncodePackedUserDataSlice(value.Users, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// Encode encodes BatchProcessCall to ABI bytes
func (value BatchProcessCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes BatchProcessCall from ABI bytes in the provided buffer
func (t *BatchProcessCall) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err    error
		n      int
		offset int
	)
	dynamicOffset := 32
	// Decode dynamic field Users
	{
		offset, err = abi.DecodeSize(data[0:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		t.Users, n, err = TestDecodeUserDataSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t BatchProcessCall) GetMethodName() string {
	return "batchProcess"
}

// GetMethodID returns the function id
func (t BatchProcessCall) GetMethodID() uint32 {
	return BatchProcessID
}

// GetMethodSelector returns the function selector
func (t BatchProcessCall) GetMethodSelector() [4]byte {
	return BatchProcessSelector
}

// EncodeWithSelector encodes batchProcess arguments to ABI bytes including function selector
func (t BatchProcessCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], BatchProcessSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewBatchProcessCall constructs a new BatchProcessCall
func NewBatchProcessCall(
	users []UserData,
) *BatchProcessCall {
	return &BatchProcessCall{
		Users: users,
	}
}

const BatchProcessReturnStaticSize = 32

var _ abi.Tuple = (*BatchProcessReturn)(nil)

// BatchProcessReturn represents an ABI tuple
type BatchProcessReturn struct {
	Field1 bool
}

// EncodedSize returns the total encoded size of BatchProcessReturn
func (t BatchProcessReturn) EncodedSize() int {
	dynamicSize := 0

	return BatchProcessReturnStaticSize + dynamicSize
}

// EncodedSizePacked returns the packed encoded size of BatchProcessReturn (no padding)
func (t BatchProcessReturn) EncodedSizePacked() int {
	size := 0
	size += 1
	return size
}

// EncodeTo encodes BatchProcessReturn to ABI bytes in the provided buffer
func (value BatchProcessReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field Field1: bool
	{
		n, err := abi.EncodePackedBool(value.Field1, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// EncodeToPacked encodes BatchProcessReturn to packed ABI bytes in the provided buffer (no padding)
func (value BatchProcessReturn) EncodeToPacked(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field Field1: bool
	{
		n, err := abi.EncodePackedBool(value.Field1, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// Encode encodes BatchProcessReturn to ABI bytes
func (value BatchProcessReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// EncodePacked encodes BatchProcessReturn to packed ABI bytes (no padding)
func (value BatchProcessReturn) EncodePacked() ([]byte, error) {
	buf := make([]byte, value.EncodedSizePacked())
	if _, err := value.EncodeToPacked(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes BatchProcessReturn from ABI bytes in the provided buffer
func (t *BatchProcessReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bool
	t.Field1, _, err = abi.DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

var _ abi.Method = (*CommunityPoolCall)(nil)

// CommunityPoolCall represents the input arguments for communityPool function
type CommunityPoolCall struct {
	abi.EmptyTuple
}

// GetMethodName returns the function name
func (t CommunityPoolCall) GetMethodName() string {
	return "communityPool"
}

// GetMethodID returns the function id
func (t CommunityPoolCall) GetMethodID() uint32 {
	return CommunityPoolID
}

// GetMethodSelector returns the function selector
func (t CommunityPoolCall) GetMethodSelector() [4]byte {
	return CommunityPoolSelector
}

// EncodeWithSelector encodes communityPool arguments to ABI bytes including function selector
func (t CommunityPoolCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], CommunityPoolSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewCommunityPoolCall constructs a new CommunityPoolCall
func NewCommunityPoolCall() *CommunityPoolCall {
	return &CommunityPoolCall{}
}

const CommunityPoolReturnStaticSize = 32

var _ abi.Tuple = (*CommunityPoolReturn)(nil)

// CommunityPoolReturn represents an ABI tuple
type CommunityPoolReturn struct {
	Coins []Tuple45c89796
}

// EncodedSize returns the total encoded size of CommunityPoolReturn
func (t CommunityPoolReturn) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += TestSizeTuple45c89796Slice(t.Coins)

	return CommunityPoolReturnStaticSize + dynamicSize
}

// EncodeTo encodes CommunityPoolReturn to ABI bytes in the provided buffer
func (value CommunityPoolReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field Coins: (string,uint256)[]
	{
		n, err := TestEncodePackedTuple45c89796Slice(value.Coins, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// Encode encodes CommunityPoolReturn to ABI bytes
func (value CommunityPoolReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes CommunityPoolReturn from ABI bytes in the provided buffer
func (t *CommunityPoolReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err    error
		n      int
		offset int
	)
	dynamicOffset := 32
	// Decode dynamic field Coins
	{
		offset, err = abi.DecodeSize(data[0:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		t.Coins, n, err = TestDecodeTuple45c89796Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

var _ abi.Method = (*EmptyArgsCall)(nil)

// EmptyArgsCall represents the input arguments for emptyArgs function
type EmptyArgsCall struct {
	abi.EmptyTuple
}

// GetMethodName returns the function name
func (t EmptyArgsCall) GetMethodName() string {
	return "emptyArgs"
}

// GetMethodID returns the function id
func (t EmptyArgsCall) GetMethodID() uint32 {
	return EmptyArgsID
}

// GetMethodSelector returns the function selector
func (t EmptyArgsCall) GetMethodSelector() [4]byte {
	return EmptyArgsSelector
}

// EncodeWithSelector encodes emptyArgs arguments to ABI bytes including function selector
func (t EmptyArgsCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], EmptyArgsSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewEmptyArgsCall constructs a new EmptyArgsCall
func NewEmptyArgsCall() *EmptyArgsCall {
	return &EmptyArgsCall{}
}

// EmptyArgsReturn represents the output arguments for emptyArgs function
type EmptyArgsReturn struct {
	abi.EmptyTuple
}

var _ abi.Method = (*GetBalancesCall)(nil)

const GetBalancesCallStaticSize = 320

var _ abi.Tuple = (*GetBalancesCall)(nil)

// GetBalancesCall represents an ABI tuple
type GetBalancesCall struct {
	Accounts [10]common.Address
}

// EncodedSize returns the total encoded size of GetBalancesCall
func (t GetBalancesCall) EncodedSize() int {
	dynamicSize := 0

	return GetBalancesCallStaticSize + dynamicSize
}

// EncodedSizePacked returns the packed encoded size of GetBalancesCall (no padding)
func (t GetBalancesCall) EncodedSizePacked() int {
	size := 0
	size += 200
	return size
}

// EncodeTo encodes GetBalancesCall to ABI bytes in the provided buffer
func (value GetBalancesCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field Accounts: address[10]
	{
		n, err := TestEncodePackedAddressArray10(value.Accounts, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// EncodeToPacked encodes GetBalancesCall to packed ABI bytes in the provided buffer (no padding)
func (value GetBalancesCall) EncodeToPacked(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field Accounts: address[10]
	{
		n, err := TestEncodePackedAddressArray10(value.Accounts, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// Encode encodes GetBalancesCall to ABI bytes
func (value GetBalancesCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// EncodePacked encodes GetBalancesCall to packed ABI bytes (no padding)
func (value GetBalancesCall) EncodePacked() ([]byte, error) {
	buf := make([]byte, value.EncodedSizePacked())
	if _, err := value.EncodeToPacked(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes GetBalancesCall from ABI bytes in the provided buffer
func (t *GetBalancesCall) Decode(data []byte) (int, error) {
	if len(data) < 320 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 320
	// Decode static field Accounts: address[10]
	t.Accounts, _, err = TestDecodeAddressArray10(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t GetBalancesCall) GetMethodName() string {
	return "getBalances"
}

// GetMethodID returns the function id
func (t GetBalancesCall) GetMethodID() uint32 {
	return GetBalancesID
}

// GetMethodSelector returns the function selector
func (t GetBalancesCall) GetMethodSelector() [4]byte {
	return GetBalancesSelector
}

// EncodeWithSelector encodes getBalances arguments to ABI bytes including function selector
func (t GetBalancesCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], GetBalancesSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewGetBalancesCall constructs a new GetBalancesCall
func NewGetBalancesCall(
	accounts [10]common.Address,
) *GetBalancesCall {
	return &GetBalancesCall{
		Accounts: accounts,
	}
}

const GetBalancesReturnStaticSize = 320

var _ abi.Tuple = (*GetBalancesReturn)(nil)

// GetBalancesReturn represents an ABI tuple
type GetBalancesReturn struct {
	Field1 [10]*big.Int
}

// EncodedSize returns the total encoded size of GetBalancesReturn
func (t GetBalancesReturn) EncodedSize() int {
	dynamicSize := 0

	return GetBalancesReturnStaticSize + dynamicSize
}

// EncodedSizePacked returns the packed encoded size of GetBalancesReturn (no padding)
func (t GetBalancesReturn) EncodedSizePacked() int {
	size := 0
	size += 320
	return size
}

// EncodeTo encodes GetBalancesReturn to ABI bytes in the provided buffer
func (value GetBalancesReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field Field1: uint256[10]
	{
		n, err := TestEncodePackedUint256Array10(value.Field1, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// EncodeToPacked encodes GetBalancesReturn to packed ABI bytes in the provided buffer (no padding)
func (value GetBalancesReturn) EncodeToPacked(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field Field1: uint256[10]
	{
		n, err := TestEncodePackedUint256Array10(value.Field1, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// Encode encodes GetBalancesReturn to ABI bytes
func (value GetBalancesReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// EncodePacked encodes GetBalancesReturn to packed ABI bytes (no padding)
func (value GetBalancesReturn) EncodePacked() ([]byte, error) {
	buf := make([]byte, value.EncodedSizePacked())
	if _, err := value.EncodeToPacked(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes GetBalancesReturn from ABI bytes in the provided buffer
func (t *GetBalancesReturn) Decode(data []byte) (int, error) {
	if len(data) < 320 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 320
	// Decode static field Field1: uint256[10]
	t.Field1, _, err = TestDecodeUint256Array10(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

var _ abi.Method = (*ProcessUserDataCall)(nil)

const ProcessUserDataCallStaticSize = 64

var _ abi.Tuple = (*ProcessUserDataCall)(nil)

// ProcessUserDataCall represents an ABI tuple
type ProcessUserDataCall struct {
	User1 User
	User2 User
}

// EncodedSize returns the total encoded size of ProcessUserDataCall
func (t ProcessUserDataCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.User1.EncodedSize()
	dynamicSize += t.User2.EncodedSize()

	return ProcessUserDataCallStaticSize + dynamicSize
}

// EncodeTo encodes ProcessUserDataCall to ABI bytes in the provided buffer
func (value ProcessUserDataCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field User1: (address,string,int256)
	{
		n, err := value.User1.EncodeTo(buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	// Field User2: (address,string,int256)
	{
		n, err := value.User2.EncodeTo(buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// Encode encodes ProcessUserDataCall to ABI bytes
func (value ProcessUserDataCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes ProcessUserDataCall from ABI bytes in the provided buffer
func (t *ProcessUserDataCall) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err    error
		n      int
		offset int
	)
	dynamicOffset := 64
	// Decode dynamic field User1
	{
		offset, err = abi.DecodeSize(data[0:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		n, err = t.User1.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field User2
	{
		offset, err = abi.DecodeSize(data[32:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		n, err = t.User2.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t ProcessUserDataCall) GetMethodName() string {
	return "processUserData"
}

// GetMethodID returns the function id
func (t ProcessUserDataCall) GetMethodID() uint32 {
	return ProcessUserDataID
}

// GetMethodSelector returns the function selector
func (t ProcessUserDataCall) GetMethodSelector() [4]byte {
	return ProcessUserDataSelector
}

// EncodeWithSelector encodes processUserData arguments to ABI bytes including function selector
func (t ProcessUserDataCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], ProcessUserDataSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewProcessUserDataCall constructs a new ProcessUserDataCall
func NewProcessUserDataCall(
	user1 User,
	user2 User,
) *ProcessUserDataCall {
	return &ProcessUserDataCall{
		User1: user1,
		User2: user2,
	}
}

const ProcessUserDataReturnStaticSize = 32

var _ abi.Tuple = (*ProcessUserDataReturn)(nil)

// ProcessUserDataReturn represents an ABI tuple
type ProcessUserDataReturn struct {
	Field1 bool
}

// EncodedSize returns the total encoded size of ProcessUserDataReturn
func (t ProcessUserDataReturn) EncodedSize() int {
	dynamicSize := 0

	return ProcessUserDataReturnStaticSize + dynamicSize
}

// EncodedSizePacked returns the packed encoded size of ProcessUserDataReturn (no padding)
func (t ProcessUserDataReturn) EncodedSizePacked() int {
	size := 0
	size += 1
	return size
}

// EncodeTo encodes ProcessUserDataReturn to ABI bytes in the provided buffer
func (value ProcessUserDataReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field Field1: bool
	{
		n, err := abi.EncodePackedBool(value.Field1, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// EncodeToPacked encodes ProcessUserDataReturn to packed ABI bytes in the provided buffer (no padding)
func (value ProcessUserDataReturn) EncodeToPacked(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field Field1: bool
	{
		n, err := abi.EncodePackedBool(value.Field1, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// Encode encodes ProcessUserDataReturn to ABI bytes
func (value ProcessUserDataReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// EncodePacked encodes ProcessUserDataReturn to packed ABI bytes (no padding)
func (value ProcessUserDataReturn) EncodePacked() ([]byte, error) {
	buf := make([]byte, value.EncodedSizePacked())
	if _, err := value.EncodeToPacked(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes ProcessUserDataReturn from ABI bytes in the provided buffer
func (t *ProcessUserDataReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bool
	t.Field1, _, err = abi.DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

var _ abi.Method = (*SetDataCall)(nil)

const SetDataCallStaticSize = 64

var _ abi.Tuple = (*SetDataCall)(nil)

// SetDataCall represents an ABI tuple
type SetDataCall struct {
	Key   [32]byte
	Value []byte
}

// EncodedSize returns the total encoded size of SetDataCall
func (t SetDataCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeBytes(t.Value)

	return SetDataCallStaticSize + dynamicSize
}

// EncodeTo encodes SetDataCall to ABI bytes in the provided buffer
func (value SetDataCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field Key: bytes32
	{
		n, err := abi.EncodePackedBytes32(value.Key, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	// Field Value: bytes
	{
		n, err := abi.EncodePackedBytes(value.Value, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// Encode encodes SetDataCall to ABI bytes
func (value SetDataCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes SetDataCall from ABI bytes in the provided buffer
func (t *SetDataCall) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err    error
		n      int
		offset int
	)
	dynamicOffset := 64
	// Decode static field Key: bytes32
	t.Key, _, err = abi.DecodeBytes32(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Value
	{
		offset, err = abi.DecodeSize(data[32:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		t.Value, n, err = abi.DecodeBytes(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t SetDataCall) GetMethodName() string {
	return "setData"
}

// GetMethodID returns the function id
func (t SetDataCall) GetMethodID() uint32 {
	return SetDataID
}

// GetMethodSelector returns the function selector
func (t SetDataCall) GetMethodSelector() [4]byte {
	return SetDataSelector
}

// EncodeWithSelector encodes setData arguments to ABI bytes including function selector
func (t SetDataCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], SetDataSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewSetDataCall constructs a new SetDataCall
func NewSetDataCall(
	key [32]byte,
	value []byte,
) *SetDataCall {
	return &SetDataCall{
		Key:   key,
		Value: value,
	}
}

// SetDataReturn represents the output arguments for setData function
type SetDataReturn struct {
	abi.EmptyTuple
}

var _ abi.Method = (*SetMessageCall)(nil)

const SetMessageCallStaticSize = 32

var _ abi.Tuple = (*SetMessageCall)(nil)

// SetMessageCall represents an ABI tuple
type SetMessageCall struct {
	Message string
}

// EncodedSize returns the total encoded size of SetMessageCall
func (t SetMessageCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Message)

	return SetMessageCallStaticSize + dynamicSize
}

// EncodeTo encodes SetMessageCall to ABI bytes in the provided buffer
func (value SetMessageCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field Message: string
	{
		n, err := abi.EncodePackedString(value.Message, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// Encode encodes SetMessageCall to ABI bytes
func (value SetMessageCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes SetMessageCall from ABI bytes in the provided buffer
func (t *SetMessageCall) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err    error
		n      int
		offset int
	)
	dynamicOffset := 32
	// Decode dynamic field Message
	{
		offset, err = abi.DecodeSize(data[0:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		t.Message, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t SetMessageCall) GetMethodName() string {
	return "setMessage"
}

// GetMethodID returns the function id
func (t SetMessageCall) GetMethodID() uint32 {
	return SetMessageID
}

// GetMethodSelector returns the function selector
func (t SetMessageCall) GetMethodSelector() [4]byte {
	return SetMessageSelector
}

// EncodeWithSelector encodes setMessage arguments to ABI bytes including function selector
func (t SetMessageCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], SetMessageSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewSetMessageCall constructs a new SetMessageCall
func NewSetMessageCall(
	message string,
) *SetMessageCall {
	return &SetMessageCall{
		Message: message,
	}
}

const SetMessageReturnStaticSize = 32

var _ abi.Tuple = (*SetMessageReturn)(nil)

// SetMessageReturn represents an ABI tuple
type SetMessageReturn struct {
	Field1 bool
}

// EncodedSize returns the total encoded size of SetMessageReturn
func (t SetMessageReturn) EncodedSize() int {
	dynamicSize := 0

	return SetMessageReturnStaticSize + dynamicSize
}

// EncodedSizePacked returns the packed encoded size of SetMessageReturn (no padding)
func (t SetMessageReturn) EncodedSizePacked() int {
	size := 0
	size += 1
	return size
}

// EncodeTo encodes SetMessageReturn to ABI bytes in the provided buffer
func (value SetMessageReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field Field1: bool
	{
		n, err := abi.EncodePackedBool(value.Field1, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// EncodeToPacked encodes SetMessageReturn to packed ABI bytes in the provided buffer (no padding)
func (value SetMessageReturn) EncodeToPacked(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field Field1: bool
	{
		n, err := abi.EncodePackedBool(value.Field1, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// Encode encodes SetMessageReturn to ABI bytes
func (value SetMessageReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// EncodePacked encodes SetMessageReturn to packed ABI bytes (no padding)
func (value SetMessageReturn) EncodePacked() ([]byte, error) {
	buf := make([]byte, value.EncodedSizePacked())
	if _, err := value.EncodeToPacked(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes SetMessageReturn from ABI bytes in the provided buffer
func (t *SetMessageReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bool
	t.Field1, _, err = abi.DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

var _ abi.Method = (*SmallIntegersCall)(nil)

const SmallIntegersCallStaticSize = 256

var _ abi.Tuple = (*SmallIntegersCall)(nil)

// SmallIntegersCall represents an ABI tuple
type SmallIntegersCall struct {
	U8  uint8
	U16 uint16
	U32 uint32
	U64 uint64
	I8  int8
	I16 int16
	I32 int32
	I64 int64
}

// EncodedSize returns the total encoded size of SmallIntegersCall
func (t SmallIntegersCall) EncodedSize() int {
	dynamicSize := 0

	return SmallIntegersCallStaticSize + dynamicSize
}

// EncodedSizePacked returns the packed encoded size of SmallIntegersCall (no padding)
func (t SmallIntegersCall) EncodedSizePacked() int {
	size := 0
	size += 1
	size += 2
	size += 4
	size += 8
	size += 1
	size += 2
	size += 4
	size += 8
	return size
}

// EncodeTo encodes SmallIntegersCall to ABI bytes in the provided buffer
func (value SmallIntegersCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field U8: uint8
	{
		n, err := abi.EncodePackedUint8(value.U8, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	// Field U16: uint16
	{
		n, err := abi.EncodePackedUint16(value.U16, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	// Field U32: uint32
	{
		n, err := abi.EncodePackedUint32(value.U32, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	// Field U64: uint64
	{
		n, err := abi.EncodePackedUint64(value.U64, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	// Field I8: int8
	{
		n, err := abi.EncodePackedInt8(value.I8, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	// Field I16: int16
	{
		n, err := abi.EncodePackedInt16(value.I16, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	// Field I32: int32
	{
		n, err := abi.EncodePackedInt32(value.I32, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	// Field I64: int64
	{
		n, err := abi.EncodePackedInt64(value.I64, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// EncodeToPacked encodes SmallIntegersCall to packed ABI bytes in the provided buffer (no padding)
func (value SmallIntegersCall) EncodeToPacked(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field U8: uint8
	{
		n, err := abi.EncodePackedUint8(value.U8, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	// Field U16: uint16
	{
		n, err := abi.EncodePackedUint16(value.U16, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	// Field U32: uint32
	{
		n, err := abi.EncodePackedUint32(value.U32, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	// Field U64: uint64
	{
		n, err := abi.EncodePackedUint64(value.U64, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	// Field I8: int8
	{
		n, err := abi.EncodePackedInt8(value.I8, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	// Field I16: int16
	{
		n, err := abi.EncodePackedInt16(value.I16, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	// Field I32: int32
	{
		n, err := abi.EncodePackedInt32(value.I32, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	// Field I64: int64
	{
		n, err := abi.EncodePackedInt64(value.I64, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// Encode encodes SmallIntegersCall to ABI bytes
func (value SmallIntegersCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// EncodePacked encodes SmallIntegersCall to packed ABI bytes (no padding)
func (value SmallIntegersCall) EncodePacked() ([]byte, error) {
	buf := make([]byte, value.EncodedSizePacked())
	if _, err := value.EncodeToPacked(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes SmallIntegersCall from ABI bytes in the provided buffer
func (t *SmallIntegersCall) Decode(data []byte) (int, error) {
	if len(data) < 256 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 256
	// Decode static field U8: uint8
	t.U8, _, err = abi.DecodeUint8(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode static field U16: uint16
	t.U16, _, err = abi.DecodeUint16(data[32:])
	if err != nil {
		return 0, err
	}
	// Decode static field U32: uint32
	t.U32, _, err = abi.DecodeUint32(data[64:])
	if err != nil {
		return 0, err
	}
	// Decode static field U64: uint64
	t.U64, _, err = abi.DecodeUint64(data[96:])
	if err != nil {
		return 0, err
	}
	// Decode static field I8: int8
	t.I8, _, err = abi.DecodeInt8(data[128:])
	if err != nil {
		return 0, err
	}
	// Decode static field I16: int16
	t.I16, _, err = abi.DecodeInt16(data[160:])
	if err != nil {
		return 0, err
	}
	// Decode static field I32: int32
	t.I32, _, err = abi.DecodeInt32(data[192:])
	if err != nil {
		return 0, err
	}
	// Decode static field I64: int64
	t.I64, _, err = abi.DecodeInt64(data[224:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t SmallIntegersCall) GetMethodName() string {
	return "smallIntegers"
}

// GetMethodID returns the function id
func (t SmallIntegersCall) GetMethodID() uint32 {
	return SmallIntegersID
}

// GetMethodSelector returns the function selector
func (t SmallIntegersCall) GetMethodSelector() [4]byte {
	return SmallIntegersSelector
}

// EncodeWithSelector encodes smallIntegers arguments to ABI bytes including function selector
func (t SmallIntegersCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], SmallIntegersSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewSmallIntegersCall constructs a new SmallIntegersCall
func NewSmallIntegersCall(
	u8 uint8,
	u16 uint16,
	u32 uint32,
	u64 uint64,
	i8 int8,
	i16 int16,
	i32 int32,
	i64 int64,
) *SmallIntegersCall {
	return &SmallIntegersCall{
		U8:  u8,
		U16: u16,
		U32: u32,
		U64: u64,
		I8:  i8,
		I16: i16,
		I32: i32,
		I64: i64,
	}
}

const SmallIntegersReturnStaticSize = 32

var _ abi.Tuple = (*SmallIntegersReturn)(nil)

// SmallIntegersReturn represents an ABI tuple
type SmallIntegersReturn struct {
	Field1 bool
}

// EncodedSize returns the total encoded size of SmallIntegersReturn
func (t SmallIntegersReturn) EncodedSize() int {
	dynamicSize := 0

	return SmallIntegersReturnStaticSize + dynamicSize
}

// EncodedSizePacked returns the packed encoded size of SmallIntegersReturn (no padding)
func (t SmallIntegersReturn) EncodedSizePacked() int {
	size := 0
	size += 1
	return size
}

// EncodeTo encodes SmallIntegersReturn to ABI bytes in the provided buffer
func (value SmallIntegersReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field Field1: bool
	{
		n, err := abi.EncodePackedBool(value.Field1, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// EncodeToPacked encodes SmallIntegersReturn to packed ABI bytes in the provided buffer (no padding)
func (value SmallIntegersReturn) EncodeToPacked(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field Field1: bool
	{
		n, err := abi.EncodePackedBool(value.Field1, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// Encode encodes SmallIntegersReturn to ABI bytes
func (value SmallIntegersReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// EncodePacked encodes SmallIntegersReturn to packed ABI bytes (no padding)
func (value SmallIntegersReturn) EncodePacked() ([]byte, error) {
	buf := make([]byte, value.EncodedSizePacked())
	if _, err := value.EncodeToPacked(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes SmallIntegersReturn from ABI bytes in the provided buffer
func (t *SmallIntegersReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bool
	t.Field1, _, err = abi.DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

var _ abi.Method = (*TransferCall)(nil)

const TransferCallStaticSize = 64

var _ abi.Tuple = (*TransferCall)(nil)

// TransferCall represents an ABI tuple
type TransferCall struct {
	To     common.Address
	Amount *big.Int
}

// EncodedSize returns the total encoded size of TransferCall
func (t TransferCall) EncodedSize() int {
	dynamicSize := 0

	return TransferCallStaticSize + dynamicSize
}

// EncodedSizePacked returns the packed encoded size of TransferCall (no padding)
func (t TransferCall) EncodedSizePacked() int {
	size := 0
	size += 20
	size += 32
	return size
}

// EncodeTo encodes TransferCall to ABI bytes in the provided buffer
func (value TransferCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field To: address
	{
		n, err := abi.EncodePackedAddress(value.To, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	// Field Amount: uint256
	{
		n, err := abi.EncodePackedUint256(value.Amount, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// EncodeToPacked encodes TransferCall to packed ABI bytes in the provided buffer (no padding)
func (value TransferCall) EncodeToPacked(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field To: address
	{
		n, err := abi.EncodePackedAddress(value.To, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	// Field Amount: uint256
	{
		n, err := abi.EncodePackedUint256(value.Amount, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// Encode encodes TransferCall to ABI bytes
func (value TransferCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// EncodePacked encodes TransferCall to packed ABI bytes (no padding)
func (value TransferCall) EncodePacked() ([]byte, error) {
	buf := make([]byte, value.EncodedSizePacked())
	if _, err := value.EncodeToPacked(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TransferCall from ABI bytes in the provided buffer
func (t *TransferCall) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 64
	// Decode static field To: address
	t.To, _, err = abi.DecodeAddress(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode static field Amount: uint256
	t.Amount, _, err = abi.DecodeUint256(data[32:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t TransferCall) GetMethodName() string {
	return "transfer"
}

// GetMethodID returns the function id
func (t TransferCall) GetMethodID() uint32 {
	return TransferID
}

// GetMethodSelector returns the function selector
func (t TransferCall) GetMethodSelector() [4]byte {
	return TransferSelector
}

// EncodeWithSelector encodes transfer arguments to ABI bytes including function selector
func (t TransferCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TransferSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewTransferCall constructs a new TransferCall
func NewTransferCall(
	to common.Address,
	amount *big.Int,
) *TransferCall {
	return &TransferCall{
		To:     to,
		Amount: amount,
	}
}

const TransferReturnStaticSize = 32

var _ abi.Tuple = (*TransferReturn)(nil)

// TransferReturn represents an ABI tuple
type TransferReturn struct {
	Field1 bool
}

// EncodedSize returns the total encoded size of TransferReturn
func (t TransferReturn) EncodedSize() int {
	dynamicSize := 0

	return TransferReturnStaticSize + dynamicSize
}

// EncodedSizePacked returns the packed encoded size of TransferReturn (no padding)
func (t TransferReturn) EncodedSizePacked() int {
	size := 0
	size += 1
	return size
}

// EncodeTo encodes TransferReturn to ABI bytes in the provided buffer
func (value TransferReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field Field1: bool
	{
		n, err := abi.EncodePackedBool(value.Field1, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// EncodeToPacked encodes TransferReturn to packed ABI bytes in the provided buffer (no padding)
func (value TransferReturn) EncodeToPacked(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field Field1: bool
	{
		n, err := abi.EncodePackedBool(value.Field1, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// Encode encodes TransferReturn to ABI bytes
func (value TransferReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// EncodePacked encodes TransferReturn to packed ABI bytes (no padding)
func (value TransferReturn) EncodePacked() ([]byte, error) {
	buf := make([]byte, value.EncodedSizePacked())
	if _, err := value.EncodeToPacked(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TransferReturn from ABI bytes in the provided buffer
func (t *TransferReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bool
	t.Field1, _, err = abi.DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

var _ abi.Method = (*TransferBatchCall)(nil)

const TransferBatchCallStaticSize = 64

var _ abi.Tuple = (*TransferBatchCall)(nil)

// TransferBatchCall represents an ABI tuple
type TransferBatchCall struct {
	Recipients []common.Address
	Amounts    []*big.Int
}

// EncodedSize returns the total encoded size of TransferBatchCall
func (t TransferBatchCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeAddressSlice(t.Recipients)
	dynamicSize += abi.SizeUint256Slice(t.Amounts)

	return TransferBatchCallStaticSize + dynamicSize
}

// EncodeTo encodes TransferBatchCall to ABI bytes in the provided buffer
func (value TransferBatchCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field Recipients: address[]
	{
		n, err := abi.EncodePackedAddressSlice(value.Recipients, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	// Field Amounts: uint256[]
	{
		n, err := abi.EncodePackedUint256Slice(value.Amounts, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// Encode encodes TransferBatchCall to ABI bytes
func (value TransferBatchCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TransferBatchCall from ABI bytes in the provided buffer
func (t *TransferBatchCall) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err    error
		n      int
		offset int
	)
	dynamicOffset := 64
	// Decode dynamic field Recipients
	{
		offset, err = abi.DecodeSize(data[0:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		t.Recipients, n, err = abi.DecodeAddressSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Amounts
	{
		offset, err = abi.DecodeSize(data[32:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		t.Amounts, n, err = abi.DecodeUint256Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t TransferBatchCall) GetMethodName() string {
	return "transferBatch"
}

// GetMethodID returns the function id
func (t TransferBatchCall) GetMethodID() uint32 {
	return TransferBatchID
}

// GetMethodSelector returns the function selector
func (t TransferBatchCall) GetMethodSelector() [4]byte {
	return TransferBatchSelector
}

// EncodeWithSelector encodes transferBatch arguments to ABI bytes including function selector
func (t TransferBatchCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TransferBatchSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewTransferBatchCall constructs a new TransferBatchCall
func NewTransferBatchCall(
	recipients []common.Address,
	amounts []*big.Int,
) *TransferBatchCall {
	return &TransferBatchCall{
		Recipients: recipients,
		Amounts:    amounts,
	}
}

const TransferBatchReturnStaticSize = 32

var _ abi.Tuple = (*TransferBatchReturn)(nil)

// TransferBatchReturn represents an ABI tuple
type TransferBatchReturn struct {
	Field1 bool
}

// EncodedSize returns the total encoded size of TransferBatchReturn
func (t TransferBatchReturn) EncodedSize() int {
	dynamicSize := 0

	return TransferBatchReturnStaticSize + dynamicSize
}

// EncodedSizePacked returns the packed encoded size of TransferBatchReturn (no padding)
func (t TransferBatchReturn) EncodedSizePacked() int {
	size := 0
	size += 1
	return size
}

// EncodeTo encodes TransferBatchReturn to ABI bytes in the provided buffer
func (value TransferBatchReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field Field1: bool
	{
		n, err := abi.EncodePackedBool(value.Field1, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// EncodeToPacked encodes TransferBatchReturn to packed ABI bytes in the provided buffer (no padding)
func (value TransferBatchReturn) EncodeToPacked(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field Field1: bool
	{
		n, err := abi.EncodePackedBool(value.Field1, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// Encode encodes TransferBatchReturn to ABI bytes
func (value TransferBatchReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// EncodePacked encodes TransferBatchReturn to packed ABI bytes (no padding)
func (value TransferBatchReturn) EncodePacked() ([]byte, error) {
	buf := make([]byte, value.EncodedSizePacked())
	if _, err := value.EncodeToPacked(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TransferBatchReturn from ABI bytes in the provided buffer
func (t *TransferBatchReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bool
	t.Field1, _, err = abi.DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

var _ abi.Method = (*UnderstoreCall)(nil)

const UnderstoreCallStaticSize = 32

var _ abi.Tuple = (*UnderstoreCall)(nil)

// UnderstoreCall represents an ABI tuple
type UnderstoreCall struct {
	Name string
}

// EncodedSize returns the total encoded size of UnderstoreCall
func (t UnderstoreCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Name)

	return UnderstoreCallStaticSize + dynamicSize
}

// EncodeTo encodes UnderstoreCall to ABI bytes in the provided buffer
func (value UnderstoreCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field Name: string
	{
		n, err := abi.EncodePackedString(value.Name, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// Encode encodes UnderstoreCall to ABI bytes
func (value UnderstoreCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes UnderstoreCall from ABI bytes in the provided buffer
func (t *UnderstoreCall) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err    error
		n      int
		offset int
	)
	dynamicOffset := 32
	// Decode dynamic field Name
	{
		offset, err = abi.DecodeSize(data[0:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		t.Name, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t UnderstoreCall) GetMethodName() string {
	return "understore"
}

// GetMethodID returns the function id
func (t UnderstoreCall) GetMethodID() uint32 {
	return UnderstoreID
}

// GetMethodSelector returns the function selector
func (t UnderstoreCall) GetMethodSelector() [4]byte {
	return UnderstoreSelector
}

// EncodeWithSelector encodes understore arguments to ABI bytes including function selector
func (t UnderstoreCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], UnderstoreSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewUnderstoreCall constructs a new UnderstoreCall
func NewUnderstoreCall(
	name string,
) *UnderstoreCall {
	return &UnderstoreCall{
		Name: name,
	}
}

// UnderstoreReturn represents the output arguments for understore function
type UnderstoreReturn struct {
	abi.EmptyTuple
}

var _ abi.Method = (*UpdateProfileCall)(nil)

const UpdateProfileCallStaticSize = 96

var _ abi.Tuple = (*UpdateProfileCall)(nil)

// UpdateProfileCall represents an ABI tuple
type UpdateProfileCall struct {
	User common.Address
	Name string
	Age  *big.Int
}

// EncodedSize returns the total encoded size of UpdateProfileCall
func (t UpdateProfileCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Name)

	return UpdateProfileCallStaticSize + dynamicSize
}

// EncodeTo encodes UpdateProfileCall to ABI bytes in the provided buffer
func (value UpdateProfileCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field User: address
	{
		n, err := abi.EncodePackedAddress(value.User, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	// Field Name: string
	{
		n, err := abi.EncodePackedString(value.Name, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	// Field Age: uint256
	{
		n, err := abi.EncodePackedUint256(value.Age, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// Encode encodes UpdateProfileCall to ABI bytes
func (value UpdateProfileCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes UpdateProfileCall from ABI bytes in the provided buffer
func (t *UpdateProfileCall) Decode(data []byte) (int, error) {
	if len(data) < 96 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err    error
		n      int
		offset int
	)
	dynamicOffset := 96
	// Decode static field User: address
	t.User, _, err = abi.DecodeAddress(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Name
	{
		offset, err = abi.DecodeSize(data[32:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		t.Name, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode static field Age: uint256
	t.Age, _, err = abi.DecodeUint256(data[64:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t UpdateProfileCall) GetMethodName() string {
	return "updateProfile"
}

// GetMethodID returns the function id
func (t UpdateProfileCall) GetMethodID() uint32 {
	return UpdateProfileID
}

// GetMethodSelector returns the function selector
func (t UpdateProfileCall) GetMethodSelector() [4]byte {
	return UpdateProfileSelector
}

// EncodeWithSelector encodes updateProfile arguments to ABI bytes including function selector
func (t UpdateProfileCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], UpdateProfileSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewUpdateProfileCall constructs a new UpdateProfileCall
func NewUpdateProfileCall(
	user common.Address,
	name string,
	age *big.Int,
) *UpdateProfileCall {
	return &UpdateProfileCall{
		User: user,
		Name: name,
		Age:  age,
	}
}

const UpdateProfileReturnStaticSize = 32

var _ abi.Tuple = (*UpdateProfileReturn)(nil)

// UpdateProfileReturn represents an ABI tuple
type UpdateProfileReturn struct {
	Field1 bool
}

// EncodedSize returns the total encoded size of UpdateProfileReturn
func (t UpdateProfileReturn) EncodedSize() int {
	dynamicSize := 0

	return UpdateProfileReturnStaticSize + dynamicSize
}

// EncodedSizePacked returns the packed encoded size of UpdateProfileReturn (no padding)
func (t UpdateProfileReturn) EncodedSizePacked() int {
	size := 0
	size += 1
	return size
}

// EncodeTo encodes UpdateProfileReturn to ABI bytes in the provided buffer
func (value UpdateProfileReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field Field1: bool
	{
		n, err := abi.EncodePackedBool(value.Field1, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// EncodeToPacked encodes UpdateProfileReturn to packed ABI bytes in the provided buffer (no padding)
func (value UpdateProfileReturn) EncodeToPacked(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field Field1: bool
	{
		n, err := abi.EncodePackedBool(value.Field1, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// Encode encodes UpdateProfileReturn to ABI bytes
func (value UpdateProfileReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// EncodePacked encodes UpdateProfileReturn to packed ABI bytes (no padding)
func (value UpdateProfileReturn) EncodePacked() ([]byte, error) {
	buf := make([]byte, value.EncodedSizePacked())
	if _, err := value.EncodeToPacked(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes UpdateProfileReturn from ABI bytes in the provided buffer
func (t *UpdateProfileReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bool
	t.Field1, _, err = abi.DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// Event signatures
var (
	// DynamicIndexed(string)
	DynamicIndexedEventTopic = common.Hash{0x3f, 0x9f, 0x17, 0xba, 0xc9, 0x56, 0x4d, 0x19, 0xb3, 0x0d, 0x61, 0xf0, 0xe5, 0x07, 0x81, 0x21, 0xfc, 0x40, 0xc7, 0x25, 0x4a, 0xa1, 0xba, 0xb6, 0x7e, 0xee, 0x77, 0x38, 0x8c, 0x00, 0x92, 0xbd}
	// EmptyIndexed(string)
	EmptyIndexedEventTopic = common.Hash{0xe5, 0x2f, 0xef, 0xc3, 0xd9, 0xf6, 0x59, 0xfe, 0x1f, 0x72, 0x8a, 0x74, 0xef, 0x9d, 0x2e, 0x7e, 0x23, 0xfe, 0x1f, 0x4c, 0xfc, 0x2b, 0x16, 0x7e, 0x1d, 0x71, 0xaf, 0xa9, 0xf7, 0x0b, 0x29, 0x13}
)

// DynamicIndexedEvent represents the DynamicIndexed event
var _ abi.Event = (*DynamicIndexedEvent)(nil)

type DynamicIndexedEvent struct {
	DynamicIndexedEventIndexed
	DynamicIndexedEventData
}

// NewDynamicIndexedEvent constructs a new DynamicIndexed event
func NewDynamicIndexedEvent(
	denom string,
) *DynamicIndexedEvent {
	return &DynamicIndexedEvent{
		DynamicIndexedEventIndexed: DynamicIndexedEventIndexed{
			Denom: denom,
		},
		DynamicIndexedEventData: DynamicIndexedEventData{},
	}
}

// GetEventName returns the event name
func (e DynamicIndexedEvent) GetEventName() string {
	return "DynamicIndexed"
}

// GetEventID returns the event ID (topic)
func (e DynamicIndexedEvent) GetEventID() common.Hash {
	return DynamicIndexedEventTopic
}

// DynamicIndexed represents an ABI event
type DynamicIndexedEventIndexed struct {
	Denom string
}

// EncodeTopics encodes indexed fields of DynamicIndexed event to topics
func (e DynamicIndexedEventIndexed) EncodeTopics() ([]common.Hash, error) {
	topics := make([]common.Hash, 0, 2)
	topics = append(topics, DynamicIndexedEventTopic)
	{
		// Denom
		encodedSize := abi.SizeString(e.Denom)
		buf := make([]byte, encodedSize)
		if _, err := abi.EncodeString(e.Denom, buf); err != nil {
			return nil, err
		}
		hash := crypto.Keccak256Hash(buf)
		topics = append(topics, hash)
	}
	return topics, nil
}

// DecodeTopics decodes indexed fields of DynamicIndexed event from topics, ignore hash topics
func (e *DynamicIndexedEventIndexed) DecodeTopics(topics []common.Hash) error {
	if len(topics) != 2 {
		return abi.ErrInvalidNumberOfTopics
	}
	if topics[0] != DynamicIndexedEventTopic {
		return abi.ErrInvalidEventTopic
	}
	return nil
}

type DynamicIndexedEventData struct {
	abi.EmptyTuple
}

// EmptyIndexedEvent represents the EmptyIndexed event
var _ abi.Event = (*EmptyIndexedEvent)(nil)

type EmptyIndexedEvent struct {
	EmptyIndexedEventIndexed
	EmptyIndexedEventData
}

// NewEmptyIndexedEvent constructs a new EmptyIndexed event
func NewEmptyIndexedEvent(
	denom string,
) *EmptyIndexedEvent {
	return &EmptyIndexedEvent{
		EmptyIndexedEventIndexed: EmptyIndexedEventIndexed{},
		EmptyIndexedEventData: EmptyIndexedEventData{
			Denom: denom,
		},
	}
}

// GetEventName returns the event name
func (e EmptyIndexedEvent) GetEventName() string {
	return "EmptyIndexed"
}

// GetEventID returns the event ID (topic)
func (e EmptyIndexedEvent) GetEventID() common.Hash {
	return EmptyIndexedEventTopic
}

type EmptyIndexedEventIndexed struct {
	abi.EmptyIndexed
}

const EmptyIndexedEventDataStaticSize = 32

var _ abi.Tuple = (*EmptyIndexedEventData)(nil)

// EmptyIndexedEventData represents an ABI tuple
type EmptyIndexedEventData struct {
	Denom string
}

// EncodedSize returns the total encoded size of EmptyIndexedEventData
func (t EmptyIndexedEventData) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Denom)

	return EmptyIndexedEventDataStaticSize + dynamicSize
}

// EncodeTo encodes EmptyIndexedEventData to ABI bytes in the provided buffer
func (value EmptyIndexedEventData) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields in packed format
	var offset int
	var err error
	// Field Denom: string
	{
		n, err := abi.EncodePackedString(value.Denom, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}
	return offset, nil
}

// Encode encodes EmptyIndexedEventData to ABI bytes
func (value EmptyIndexedEventData) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes EmptyIndexedEventData from ABI bytes in the provided buffer
func (t *EmptyIndexedEventData) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err    error
		n      int
		offset int
	)
	dynamicOffset := 32
	// Decode dynamic field Denom
	{
		offset, err = abi.DecodeSize(data[0:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		t.Denom, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}
