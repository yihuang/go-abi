// Code generated by go-abi generator2. DO NOT EDIT.

package tests

import (
	"encoding/binary"
	"fmt"
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/yihuang/go-abi"
)

// Function selectors
var (
	// balanceOf(address)
	BalanceOfSelector = [4]byte{0x70, 0xa0, 0x82, 0x31}
	// batchProcess((uint256,(bytes32,string))[])
	BatchProcessSelector = [4]byte{0xb7, 0x78, 0x31, 0x64}
	// communityPool()
	CommunityPoolSelector = [4]byte{0x14, 0xd1, 0x40, 0xb0}
	// getBalances(address[10])
	GetBalancesSelector = [4]byte{0x51, 0x68, 0x3d, 0x7d}
	// processUserData((address,string,uint256),(address,string,uint256))
	ProcessUserDataSelector = [4]byte{0xe0, 0x33, 0x24, 0x04}
	// setData(bytes32,bytes)
	SetDataSelector = [4]byte{0x7f, 0x23, 0x69, 0x0c}
	// setMessage(string)
	SetMessageSelector = [4]byte{0x36, 0x8b, 0x87, 0x72}
	// smallIntegers(uint8,uint16,uint32,uint64,int8,int16,int32,int64)
	SmallIntegersSelector = [4]byte{0x98, 0x83, 0xfe, 0x4a}
	// transfer(address,uint256)
	TransferSelector = [4]byte{0xa9, 0x05, 0x9c, 0xbb}
	// transferBatch(address[],uint256[])
	TransferBatchSelector = [4]byte{0x3b, 0x3e, 0x67, 0x2f}
	// updateProfile(address,string,uint256)
	UpdateProfileSelector = [4]byte{0x6d, 0xe9, 0x52, 0x01}
)

// Big endian integer versions of function selectors
const (
	BalanceOfID       = 1889567281
	BatchProcessID    = 3078107492
	CommunityPoolID   = 349257904
	GetBalancesID     = 1365785981
	ProcessUserDataID = 3761447940
	SetDataID         = 2133027084
	SetMessageID      = 915113842
	SmallIntegersID   = 2558787146
	TransferID        = 2835717307
	TransferBatchID   = 993945391
	UpdateProfileID   = 1844007425
)

const Tuple_45c89796StaticSize = 64

// Tuple_45c89796 represents an ABI tuple
type Tuple_45c89796 struct {
	Denom  string
	Amount *big.Int
}

// EncodedSize returns the total encoded size of Tuple_45c89796
func (t Tuple_45c89796) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += 32 + abi.Pad32(len(t.Denom)) // length + padded string data

	return Tuple_45c89796StaticSize + dynamicSize
}

// EncodeTo encodes Tuple_45c89796 to ABI bytes in the provided buffer
func (value Tuple_45c89796) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	offset := 0
	var (
		err error
		n   int
	)
	// Field 0: string
	n, err = encode_string(value.Denom, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 1: uint256
	n, err = encode_uint256(value.Amount, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// Encode encodes Tuple_45c89796 to ABI bytes
func (t Tuple_45c89796) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Tuple_45c89796 from ABI bytes in the provided buffer
func (t *Tuple_45c89796) Decode(data0 []byte) error {
	// TODO: Implement decode
	return fmt.Errorf("decode not yet implemented")
}

const UserStaticSize = 96

// User represents an ABI tuple
type User struct {
	Address common.Address
	Name    string
	Age     *big.Int
}

// EncodedSize returns the total encoded size of User
func (t User) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += 32 + abi.Pad32(len(t.Name)) // length + padded string data

	return UserStaticSize + dynamicSize
}

// EncodeTo encodes User to ABI bytes in the provided buffer
func (value User) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	offset := 0
	var (
		err error
		n   int
	)
	// Field 0: address
	n, err = encode_address(value.Address, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 1: string
	n, err = encode_string(value.Name, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 2: uint256
	n, err = encode_uint256(value.Age, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// Encode encodes User to ABI bytes
func (t User) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes User from ABI bytes in the provided buffer
func (t *User) Decode(data0 []byte) error {
	// TODO: Implement decode
	return fmt.Errorf("decode not yet implemented")
}

const UserDataStaticSize = 64

// UserData represents an ABI tuple
type UserData struct {
	Id   *big.Int
	Data UserMetadata
}

// EncodedSize returns the total encoded size of UserData
func (t UserData) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.Data.EncodedSize() // dynamic tuple

	return UserDataStaticSize + dynamicSize
}

// EncodeTo encodes UserData to ABI bytes in the provided buffer
func (value UserData) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	offset := 0
	var (
		err error
		n   int
	)
	// Field 0: uint256
	n, err = encode_uint256(value.Id, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 1: (bytes32,string)
	n, err = value.Data.EncodeTo(buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// Encode encodes UserData to ABI bytes
func (t UserData) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes UserData from ABI bytes in the provided buffer
func (t *UserData) Decode(data0 []byte) error {
	// TODO: Implement decode
	return fmt.Errorf("decode not yet implemented")
}

const UserMetadataStaticSize = 64

// UserMetadata represents an ABI tuple
type UserMetadata struct {
	Key   [32]byte
	Value string
}

// EncodedSize returns the total encoded size of UserMetadata
func (t UserMetadata) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += 32 + abi.Pad32(len(t.Value)) // length + padded string data

	return UserMetadataStaticSize + dynamicSize
}

// EncodeTo encodes UserMetadata to ABI bytes in the provided buffer
func (value UserMetadata) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	offset := 0
	var (
		err error
		n   int
	)
	// Field 0: bytes32
	n, err = encode_bytes32(value.Key, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 1: string
	n, err = encode_string(value.Value, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// Encode encodes UserMetadata to ABI bytes
func (t UserMetadata) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes UserMetadata from ABI bytes in the provided buffer
func (t *UserMetadata) Decode(data0 []byte) error {
	// TODO: Implement decode
	return fmt.Errorf("decode not yet implemented")
}

// encode_Tuple_45c89796_array encodes (string,uint256)[] to ABI bytes
func encode_Tuple_45c89796_array(value []Tuple_45c89796, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))

	// Encode elements
	offset := 32
	for _, elem := range value {
		n, err := elem.EncodeTo(buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset, nil
}

// encode_UserData_array encodes (uint256,(bytes32,string))[] to ABI bytes
func encode_UserData_array(value []UserData, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))

	// Encode elements
	offset := 32
	for _, elem := range value {
		n, err := elem.EncodeTo(buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset, nil
}

// encode_address encodes address to ABI bytes
func encode_address(value common.Address, buf []byte) (int, error) {
	copy(buf[12:32], value[:])
	return 32, nil
}

// encode_address_array encodes address[] to ABI bytes
func encode_address_array(value []common.Address, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))

	// Encode elements
	offset := 32
	for _, elem := range value {
		n, err := encode_address(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset, nil
}

// encode_address_array_10 encodes address[10] to ABI bytes
func encode_address_array_10(value [10]common.Address, buf []byte) (int, error) {
	// Encode fixed-size array
	offset := 0
	if len(value) != 10 {
		return 0, fmt.Errorf("invalid array length: expected 10, got %d", len(value))
	}
	for _, elem := range value {
		n, err := encode_address(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset, nil
}

// encode_bool encodes bool to ABI bytes
func encode_bool(value bool, buf []byte) (int, error) {
	if value {
		buf[31] = 1
	}
	return 32, nil
}

// encode_bytes encodes bytes to ABI bytes
func encode_bytes(value []byte, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))

	// Encode data
	copy(buf[32:], value)

	return 32 + abi.Pad32(len(value)), nil
}

// encode_bytes32 encodes bytes32 to ABI bytes
func encode_bytes32(value [32]byte, buf []byte) (int, error) {
	copy(buf[:32], value[:])
	return 32, nil
}

// encode_int16 encodes int16 to ABI bytes
func encode_int16(value int16, buf []byte) (int, error) {
	if value < 0 {
		for i := 0; i < 30; i++ {
			buf[i] = 0xff
		}
	}
	binary.BigEndian.PutUint16(buf[30:32], uint16(value))
	return 32, nil
}

// encode_int32 encodes int32 to ABI bytes
func encode_int32(value int32, buf []byte) (int, error) {
	if value < 0 {
		for i := 0; i < 28; i++ {
			buf[i] = 0xff
		}
	}
	binary.BigEndian.PutUint32(buf[28:32], uint32(value))
	return 32, nil
}

// encode_int64 encodes int64 to ABI bytes
func encode_int64(value int64, buf []byte) (int, error) {
	if value < 0 {
		for i := 0; i < 24; i++ {
			buf[i] = 0xff
		}
	}
	binary.BigEndian.PutUint64(buf[24:32], uint64(value))
	return 32, nil
}

// encode_int8 encodes int8 to ABI bytes
func encode_int8(value int8, buf []byte) (int, error) {
	if value < 0 {
		for i := 0; i < 31; i++ {
			buf[i] = 0xff
		}
	}
	buf[31] = byte(value)
	return 32, nil
}

// encode_string encodes string to ABI bytes
func encode_string(value string, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))

	// Encode data
	copy(buf[32:], []byte(value))

	return 32 + abi.Pad32(len(value)), nil
}

// encode_uint16 encodes uint16 to ABI bytes
func encode_uint16(value uint16, buf []byte) (int, error) {
	binary.BigEndian.PutUint16(buf[30:32], uint16(value))
	return 32, nil
}

// encode_uint256 encodes uint256 to ABI bytes
func encode_uint256(value *big.Int, buf []byte) (int, error) {
	if err := abi.EncodeBigInt(value, buf[:32], false); err != nil {
		return 0, err
	}
	return 32, nil
}

// encode_uint256_array encodes uint256[] to ABI bytes
func encode_uint256_array(value []*big.Int, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))

	// Encode elements
	offset := 32
	for _, elem := range value {
		n, err := encode_uint256(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset, nil
}

// encode_uint256_array_10 encodes uint256[10] to ABI bytes
func encode_uint256_array_10(value [10]*big.Int, buf []byte) (int, error) {
	// Encode fixed-size array
	offset := 0
	if len(value) != 10 {
		return 0, fmt.Errorf("invalid array length: expected 10, got %d", len(value))
	}
	for _, elem := range value {
		n, err := encode_uint256(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset, nil
}

// encode_uint32 encodes uint32 to ABI bytes
func encode_uint32(value uint32, buf []byte) (int, error) {
	binary.BigEndian.PutUint32(buf[28:32], uint32(value))
	return 32, nil
}

// encode_uint64 encodes uint64 to ABI bytes
func encode_uint64(value uint64, buf []byte) (int, error) {
	binary.BigEndian.PutUint64(buf[24:32], uint64(value))
	return 32, nil
}

// encode_uint8 encodes uint8 to ABI bytes
func encode_uint8(value uint8, buf []byte) (int, error) {
	buf[31] = byte(value)
	return 32, nil
}

const BalanceOfCallStaticSize = 32

// BalanceOfCall represents an ABI tuple
type BalanceOfCall struct {
	Account common.Address
}

// EncodedSize returns the total encoded size of BalanceOfCall
func (t BalanceOfCall) EncodedSize() int {
	dynamicSize := 0

	return BalanceOfCallStaticSize + dynamicSize
}

// EncodeTo encodes BalanceOfCall to ABI bytes in the provided buffer
func (value BalanceOfCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	offset := 0
	var (
		err error
		n   int
	)
	// Field 0: address
	n, err = encode_address(value.Account, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// Encode encodes BalanceOfCall to ABI bytes
func (t BalanceOfCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes BalanceOfCall from ABI bytes in the provided buffer
func (t *BalanceOfCall) Decode(data0 []byte) error {
	// TODO: Implement decode
	return fmt.Errorf("decode not yet implemented")
}

// EncodeWithSelector encodes balanceOf arguments to ABI bytes including function selector
func (t BalanceOfCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], BalanceOfSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const BatchProcessCallStaticSize = 32

// BatchProcessCall represents an ABI tuple
type BatchProcessCall struct {
	Users []UserData
}

// EncodedSize returns the total encoded size of BatchProcessCall
func (t BatchProcessCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += 32 + 32*len(t.Users) // length + offset pointers for dynamic elements
	for _, elem := range t.Users {
		dynamicSize += elem.EncodedSize() // dynamic tuple
	}

	return BatchProcessCallStaticSize + dynamicSize
}

// EncodeTo encodes BatchProcessCall to ABI bytes in the provided buffer
func (value BatchProcessCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	offset := 0
	var (
		err error
		n   int
	)
	// Field 0: (uint256,(bytes32,string))[]
	n, err = encode_UserData_array(value.Users, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// Encode encodes BatchProcessCall to ABI bytes
func (t BatchProcessCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes BatchProcessCall from ABI bytes in the provided buffer
func (t *BatchProcessCall) Decode(data0 []byte) error {
	// TODO: Implement decode
	return fmt.Errorf("decode not yet implemented")
}

// EncodeWithSelector encodes batchProcess arguments to ABI bytes including function selector
func (t BatchProcessCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], BatchProcessSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const GetBalancesCallStaticSize = 320

// GetBalancesCall represents an ABI tuple
type GetBalancesCall struct {
	Accounts [10]common.Address
}

// EncodedSize returns the total encoded size of GetBalancesCall
func (t GetBalancesCall) EncodedSize() int {
	dynamicSize := 0

	return GetBalancesCallStaticSize + dynamicSize
}

// EncodeTo encodes GetBalancesCall to ABI bytes in the provided buffer
func (value GetBalancesCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	offset := 0
	var (
		err error
		n   int
	)
	// Field 0: address[10]
	n, err = encode_address_array_10(value.Accounts, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// Encode encodes GetBalancesCall to ABI bytes
func (t GetBalancesCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes GetBalancesCall from ABI bytes in the provided buffer
func (t *GetBalancesCall) Decode(data0 []byte) error {
	// TODO: Implement decode
	return fmt.Errorf("decode not yet implemented")
}

// EncodeWithSelector encodes getBalances arguments to ABI bytes including function selector
func (t GetBalancesCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], GetBalancesSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const ProcessUserDataCallStaticSize = 64

// ProcessUserDataCall represents an ABI tuple
type ProcessUserDataCall struct {
	User1 User
	User2 User
}

// EncodedSize returns the total encoded size of ProcessUserDataCall
func (t ProcessUserDataCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.User1.EncodedSize() // dynamic tuple
	dynamicSize += t.User2.EncodedSize() // dynamic tuple

	return ProcessUserDataCallStaticSize + dynamicSize
}

// EncodeTo encodes ProcessUserDataCall to ABI bytes in the provided buffer
func (value ProcessUserDataCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	offset := 0
	var (
		err error
		n   int
	)
	// Field 0: (address,string,uint256)
	n, err = value.User1.EncodeTo(buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 1: (address,string,uint256)
	n, err = value.User2.EncodeTo(buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// Encode encodes ProcessUserDataCall to ABI bytes
func (t ProcessUserDataCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes ProcessUserDataCall from ABI bytes in the provided buffer
func (t *ProcessUserDataCall) Decode(data0 []byte) error {
	// TODO: Implement decode
	return fmt.Errorf("decode not yet implemented")
}

// EncodeWithSelector encodes processUserData arguments to ABI bytes including function selector
func (t ProcessUserDataCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], ProcessUserDataSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const SetDataCallStaticSize = 64

// SetDataCall represents an ABI tuple
type SetDataCall struct {
	Key   [32]byte
	Value []byte
}

// EncodedSize returns the total encoded size of SetDataCall
func (t SetDataCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += 32 + abi.Pad32(len(t.Value)) // length + padded bytes data

	return SetDataCallStaticSize + dynamicSize
}

// EncodeTo encodes SetDataCall to ABI bytes in the provided buffer
func (value SetDataCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	offset := 0
	var (
		err error
		n   int
	)
	// Field 0: bytes32
	n, err = encode_bytes32(value.Key, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 1: bytes
	n, err = encode_bytes(value.Value, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// Encode encodes SetDataCall to ABI bytes
func (t SetDataCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes SetDataCall from ABI bytes in the provided buffer
func (t *SetDataCall) Decode(data0 []byte) error {
	// TODO: Implement decode
	return fmt.Errorf("decode not yet implemented")
}

// EncodeWithSelector encodes setData arguments to ABI bytes including function selector
func (t SetDataCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], SetDataSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const SetMessageCallStaticSize = 32

// SetMessageCall represents an ABI tuple
type SetMessageCall struct {
	Message string
}

// EncodedSize returns the total encoded size of SetMessageCall
func (t SetMessageCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += 32 + abi.Pad32(len(t.Message)) // length + padded string data

	return SetMessageCallStaticSize + dynamicSize
}

// EncodeTo encodes SetMessageCall to ABI bytes in the provided buffer
func (value SetMessageCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	offset := 0
	var (
		err error
		n   int
	)
	// Field 0: string
	n, err = encode_string(value.Message, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// Encode encodes SetMessageCall to ABI bytes
func (t SetMessageCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes SetMessageCall from ABI bytes in the provided buffer
func (t *SetMessageCall) Decode(data0 []byte) error {
	// TODO: Implement decode
	return fmt.Errorf("decode not yet implemented")
}

// EncodeWithSelector encodes setMessage arguments to ABI bytes including function selector
func (t SetMessageCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], SetMessageSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const SmallIntegersCallStaticSize = 256

// SmallIntegersCall represents an ABI tuple
type SmallIntegersCall struct {
	U8  uint8
	U16 uint16
	U32 uint32
	U64 uint64
	I8  int8
	I16 int16
	I32 int32
	I64 int64
}

// EncodedSize returns the total encoded size of SmallIntegersCall
func (t SmallIntegersCall) EncodedSize() int {
	dynamicSize := 0

	return SmallIntegersCallStaticSize + dynamicSize
}

// EncodeTo encodes SmallIntegersCall to ABI bytes in the provided buffer
func (value SmallIntegersCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	offset := 0
	var (
		err error
		n   int
	)
	// Field 0: uint8
	n, err = encode_uint8(value.U8, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 1: uint16
	n, err = encode_uint16(value.U16, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 2: uint32
	n, err = encode_uint32(value.U32, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 3: uint64
	n, err = encode_uint64(value.U64, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 4: int8
	n, err = encode_int8(value.I8, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 5: int16
	n, err = encode_int16(value.I16, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 6: int32
	n, err = encode_int32(value.I32, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 7: int64
	n, err = encode_int64(value.I64, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// Encode encodes SmallIntegersCall to ABI bytes
func (t SmallIntegersCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes SmallIntegersCall from ABI bytes in the provided buffer
func (t *SmallIntegersCall) Decode(data0 []byte) error {
	// TODO: Implement decode
	return fmt.Errorf("decode not yet implemented")
}

// EncodeWithSelector encodes smallIntegers arguments to ABI bytes including function selector
func (t SmallIntegersCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], SmallIntegersSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const TransferCallStaticSize = 64

// TransferCall represents an ABI tuple
type TransferCall struct {
	To     common.Address
	Amount *big.Int
}

// EncodedSize returns the total encoded size of TransferCall
func (t TransferCall) EncodedSize() int {
	dynamicSize := 0

	return TransferCallStaticSize + dynamicSize
}

// EncodeTo encodes TransferCall to ABI bytes in the provided buffer
func (value TransferCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	offset := 0
	var (
		err error
		n   int
	)
	// Field 0: address
	n, err = encode_address(value.To, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 1: uint256
	n, err = encode_uint256(value.Amount, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// Encode encodes TransferCall to ABI bytes
func (t TransferCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TransferCall from ABI bytes in the provided buffer
func (t *TransferCall) Decode(data0 []byte) error {
	// TODO: Implement decode
	return fmt.Errorf("decode not yet implemented")
}

// EncodeWithSelector encodes transfer arguments to ABI bytes including function selector
func (t TransferCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TransferSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const TransferBatchCallStaticSize = 64

// TransferBatchCall represents an ABI tuple
type TransferBatchCall struct {
	Recipients []common.Address
	Amounts    []*big.Int
}

// EncodedSize returns the total encoded size of TransferBatchCall
func (t TransferBatchCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += 32 + 32*len(t.Recipients) // length + static elements
	dynamicSize += 32 + 32*len(t.Amounts)    // length + static elements

	return TransferBatchCallStaticSize + dynamicSize
}

// EncodeTo encodes TransferBatchCall to ABI bytes in the provided buffer
func (value TransferBatchCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	offset := 0
	var (
		err error
		n   int
	)
	// Field 0: address[]
	n, err = encode_address_array(value.Recipients, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 1: uint256[]
	n, err = encode_uint256_array(value.Amounts, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// Encode encodes TransferBatchCall to ABI bytes
func (t TransferBatchCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TransferBatchCall from ABI bytes in the provided buffer
func (t *TransferBatchCall) Decode(data0 []byte) error {
	// TODO: Implement decode
	return fmt.Errorf("decode not yet implemented")
}

// EncodeWithSelector encodes transferBatch arguments to ABI bytes including function selector
func (t TransferBatchCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TransferBatchSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const UpdateProfileCallStaticSize = 96

// UpdateProfileCall represents an ABI tuple
type UpdateProfileCall struct {
	User common.Address
	Name string
	Age  *big.Int
}

// EncodedSize returns the total encoded size of UpdateProfileCall
func (t UpdateProfileCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += 32 + abi.Pad32(len(t.Name)) // length + padded string data

	return UpdateProfileCallStaticSize + dynamicSize
}

// EncodeTo encodes UpdateProfileCall to ABI bytes in the provided buffer
func (value UpdateProfileCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	offset := 0
	var (
		err error
		n   int
	)
	// Field 0: address
	n, err = encode_address(value.User, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 1: string
	n, err = encode_string(value.Name, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field 2: uint256
	n, err = encode_uint256(value.Age, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// Encode encodes UpdateProfileCall to ABI bytes
func (t UpdateProfileCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes UpdateProfileCall from ABI bytes in the provided buffer
func (t *UpdateProfileCall) Decode(data0 []byte) error {
	// TODO: Implement decode
	return fmt.Errorf("decode not yet implemented")
}

// EncodeWithSelector encodes updateProfile arguments to ABI bytes including function selector
func (t UpdateProfileCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], UpdateProfileSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}
