//go:build uint256

// Code generated by go-abi. DO NOT EDIT.

package tests

import (
	"encoding/binary"
	"io"

	"github.com/ethereum/go-ethereum/common"
	"github.com/holiman/uint256"
	"github.com/yihuang/go-abi"
)

// Function selectors
var (
	// balanceOf(address)
	BalanceOfSelector = [4]byte{0x70, 0xa0, 0x82, 0x31}
	// multiTransfer(address[],uint256[])
	MultiTransferSelector = [4]byte{0x1e, 0x89, 0xd5, 0x45}
	// transfer(address,uint256)
	TransferSelector = [4]byte{0xa9, 0x05, 0x9c, 0xbb}
)

// Big endian integer versions of function selectors
const (
	BalanceOfID     = 1889567281
	MultiTransferID = 512349509
	TransferID      = 2835717307
)

var _ abi.Method = (*BalanceOfCall)(nil)

const BalanceOfCallStaticSize = 32

var _ abi.Tuple = (*BalanceOfCall)(nil)
var _ abi.PackedTuple = (*BalanceOfCall)(nil)

// BalanceOfCall represents an ABI tuple
type BalanceOfCall struct {
	Account common.Address
}

// EncodedSize returns the total encoded size of BalanceOfCall
func (t BalanceOfCall) EncodedSize() int {
	dynamicSize := 0

	return BalanceOfCallStaticSize + dynamicSize
}

// EncodeTo encodes BalanceOfCall to ABI bytes in the provided buffer
func (value BalanceOfCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := BalanceOfCallStaticSize // Start dynamic data after static section
	// Field Account: address
	if _, err := abi.EncodeAddress(value.Account, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes BalanceOfCall to ABI bytes
func (value BalanceOfCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes BalanceOfCall from ABI bytes in the provided buffer
func (t *BalanceOfCall) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Account: address
	t.Account, _, err = abi.DecodeAddress(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// PackedEncodedSize returns the packed encoded size of BalanceOfCall
func (t BalanceOfCall) PackedEncodedSize() int {
	return 20
}

// PackedEncodeTo encodes BalanceOfCall to packed ABI bytes in the provided buffer
func (value BalanceOfCall) PackedEncodeTo(buf []byte) (int, error) {
	// Encode tuple fields sequentially (packed, no dynamic section)
	var (
		offset int
		n      int
		err    error
	)
	// Field Account: address
	n, err = abi.PackedEncodeAddress(value.Account, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// PackedEncode encodes BalanceOfCall to packed ABI bytes
func (value BalanceOfCall) PackedEncode() ([]byte, error) {
	buf := make([]byte, value.PackedEncodedSize())
	if _, err := value.PackedEncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// PackedDecode decodes BalanceOfCall from packed ABI bytes
func (t *BalanceOfCall) PackedDecode(data []byte) (int, error) {
	if len(data) < 20 {
		return 0, io.ErrUnexpectedEOF
	}
	var err error
	// Decode field Account: address
	t.Account, _, err = abi.PackedDecodeAddress(data[0:])
	if err != nil {
		return 0, err
	}
	return 20, nil
}

// GetMethodName returns the function name
func (t BalanceOfCall) GetMethodName() string {
	return "balanceOf"
}

// GetMethodID returns the function id
func (t BalanceOfCall) GetMethodID() uint32 {
	return BalanceOfID
}

// GetMethodSelector returns the function selector
func (t BalanceOfCall) GetMethodSelector() [4]byte {
	return BalanceOfSelector
}

// EncodeWithSelector encodes balanceOf arguments to ABI bytes including function selector
func (t BalanceOfCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], BalanceOfSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewBalanceOfCall constructs a new BalanceOfCall
func NewBalanceOfCall(
	account common.Address,
) *BalanceOfCall {
	return &BalanceOfCall{
		Account: account,
	}
}

const BalanceOfReturnStaticSize = 32

var _ abi.Tuple = (*BalanceOfReturn)(nil)
var _ abi.PackedTuple = (*BalanceOfReturn)(nil)

// BalanceOfReturn represents an ABI tuple
type BalanceOfReturn struct {
	Field1 *uint256.Int
}

// EncodedSize returns the total encoded size of BalanceOfReturn
func (t BalanceOfReturn) EncodedSize() int {
	dynamicSize := 0

	return BalanceOfReturnStaticSize + dynamicSize
}

// EncodeTo encodes BalanceOfReturn to ABI bytes in the provided buffer
func (value BalanceOfReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := BalanceOfReturnStaticSize // Start dynamic data after static section
	// Field Field1: uint256
	if _, err := abi.EncodeUint256(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes BalanceOfReturn to ABI bytes
func (value BalanceOfReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes BalanceOfReturn from ABI bytes in the provided buffer
func (t *BalanceOfReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: uint256
	t.Field1, _, err = abi.DecodeUint256(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// PackedEncodedSize returns the packed encoded size of BalanceOfReturn
func (t BalanceOfReturn) PackedEncodedSize() int {
	return 32
}

// PackedEncodeTo encodes BalanceOfReturn to packed ABI bytes in the provided buffer
func (value BalanceOfReturn) PackedEncodeTo(buf []byte) (int, error) {
	// Encode tuple fields sequentially (packed, no dynamic section)
	var (
		offset int
		n      int
		err    error
	)
	// Field Field1: uint256
	n, err = abi.PackedEncodeUint256(value.Field1, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// PackedEncode encodes BalanceOfReturn to packed ABI bytes
func (value BalanceOfReturn) PackedEncode() ([]byte, error) {
	buf := make([]byte, value.PackedEncodedSize())
	if _, err := value.PackedEncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// PackedDecode decodes BalanceOfReturn from packed ABI bytes
func (t *BalanceOfReturn) PackedDecode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var err error
	// Decode field Field1: uint256
	t.Field1, _, err = abi.PackedDecodeUint256(data[0:])
	if err != nil {
		return 0, err
	}
	return 32, nil
}

var _ abi.Method = (*MultiTransferCall)(nil)

const MultiTransferCallStaticSize = 64

var _ abi.Tuple = (*MultiTransferCall)(nil)

// MultiTransferCall represents an ABI tuple
type MultiTransferCall struct {
	Recipients []common.Address
	Amounts    []*uint256.Int
}

// EncodedSize returns the total encoded size of MultiTransferCall
func (t MultiTransferCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeAddressSlice(t.Recipients)
	dynamicSize += abi.SizeUint256Slice(t.Amounts)

	return MultiTransferCallStaticSize + dynamicSize
}

// EncodeTo encodes MultiTransferCall to ABI bytes in the provided buffer
func (value MultiTransferCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := MultiTransferCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Recipients: address[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeAddressSlice(value.Recipients, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Amounts: uint256[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeUint256Slice(value.Amounts, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes MultiTransferCall to ABI bytes
func (value MultiTransferCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes MultiTransferCall from ABI bytes in the provided buffer
func (t *MultiTransferCall) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err    error
		n      int
		offset int
	)
	dynamicOffset := 64
	// Decode dynamic field Recipients
	{
		offset, err = abi.DecodeSize(data[0:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		t.Recipients, n, err = abi.DecodeAddressSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Amounts
	{
		offset, err = abi.DecodeSize(data[32:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, abi.ErrInvalidOffsetForDynamicField
		}
		t.Amounts, n, err = abi.DecodeUint256Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t MultiTransferCall) GetMethodName() string {
	return "multiTransfer"
}

// GetMethodID returns the function id
func (t MultiTransferCall) GetMethodID() uint32 {
	return MultiTransferID
}

// GetMethodSelector returns the function selector
func (t MultiTransferCall) GetMethodSelector() [4]byte {
	return MultiTransferSelector
}

// EncodeWithSelector encodes multiTransfer arguments to ABI bytes including function selector
func (t MultiTransferCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], MultiTransferSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewMultiTransferCall constructs a new MultiTransferCall
func NewMultiTransferCall(
	recipients []common.Address,
	amounts []*uint256.Int,
) *MultiTransferCall {
	return &MultiTransferCall{
		Recipients: recipients,
		Amounts:    amounts,
	}
}

// MultiTransferReturn represents the output arguments for multiTransfer function
type MultiTransferReturn struct {
	abi.EmptyTuple
}

var _ abi.Method = (*TransferCall)(nil)

const TransferCallStaticSize = 64

var _ abi.Tuple = (*TransferCall)(nil)
var _ abi.PackedTuple = (*TransferCall)(nil)

// TransferCall represents an ABI tuple
type TransferCall struct {
	To     common.Address
	Amount *uint256.Int
}

// EncodedSize returns the total encoded size of TransferCall
func (t TransferCall) EncodedSize() int {
	dynamicSize := 0

	return TransferCallStaticSize + dynamicSize
}

// EncodeTo encodes TransferCall to ABI bytes in the provided buffer
func (value TransferCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TransferCallStaticSize // Start dynamic data after static section
	// Field To: address
	if _, err := abi.EncodeAddress(value.To, buf[0:]); err != nil {
		return 0, err
	}

	// Field Amount: uint256
	if _, err := abi.EncodeUint256(value.Amount, buf[32:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TransferCall to ABI bytes
func (value TransferCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TransferCall from ABI bytes in the provided buffer
func (t *TransferCall) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 64
	// Decode static field To: address
	t.To, _, err = abi.DecodeAddress(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode static field Amount: uint256
	t.Amount, _, err = abi.DecodeUint256(data[32:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// PackedEncodedSize returns the packed encoded size of TransferCall
func (t TransferCall) PackedEncodedSize() int {
	return 52
}

// PackedEncodeTo encodes TransferCall to packed ABI bytes in the provided buffer
func (value TransferCall) PackedEncodeTo(buf []byte) (int, error) {
	// Encode tuple fields sequentially (packed, no dynamic section)
	var (
		offset int
		n      int
		err    error
	)
	// Field To: address
	n, err = abi.PackedEncodeAddress(value.To, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	// Field Amount: uint256
	n, err = abi.PackedEncodeUint256(value.Amount, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// PackedEncode encodes TransferCall to packed ABI bytes
func (value TransferCall) PackedEncode() ([]byte, error) {
	buf := make([]byte, value.PackedEncodedSize())
	if _, err := value.PackedEncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// PackedDecode decodes TransferCall from packed ABI bytes
func (t *TransferCall) PackedDecode(data []byte) (int, error) {
	if len(data) < 52 {
		return 0, io.ErrUnexpectedEOF
	}
	var err error
	// Decode field To: address
	t.To, _, err = abi.PackedDecodeAddress(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode field Amount: uint256
	t.Amount, _, err = abi.PackedDecodeUint256(data[20:])
	if err != nil {
		return 0, err
	}
	return 52, nil
}

// GetMethodName returns the function name
func (t TransferCall) GetMethodName() string {
	return "transfer"
}

// GetMethodID returns the function id
func (t TransferCall) GetMethodID() uint32 {
	return TransferID
}

// GetMethodSelector returns the function selector
func (t TransferCall) GetMethodSelector() [4]byte {
	return TransferSelector
}

// EncodeWithSelector encodes transfer arguments to ABI bytes including function selector
func (t TransferCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TransferSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewTransferCall constructs a new TransferCall
func NewTransferCall(
	to common.Address,
	amount *uint256.Int,
) *TransferCall {
	return &TransferCall{
		To:     to,
		Amount: amount,
	}
}

const TransferReturnStaticSize = 32

var _ abi.Tuple = (*TransferReturn)(nil)
var _ abi.PackedTuple = (*TransferReturn)(nil)

// TransferReturn represents an ABI tuple
type TransferReturn struct {
	Field1 bool
}

// EncodedSize returns the total encoded size of TransferReturn
func (t TransferReturn) EncodedSize() int {
	dynamicSize := 0

	return TransferReturnStaticSize + dynamicSize
}

// EncodeTo encodes TransferReturn to ABI bytes in the provided buffer
func (value TransferReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TransferReturnStaticSize // Start dynamic data after static section
	// Field Field1: bool
	if _, err := abi.EncodeBool(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TransferReturn to ABI bytes
func (value TransferReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TransferReturn from ABI bytes in the provided buffer
func (t *TransferReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bool
	t.Field1, _, err = abi.DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// PackedEncodedSize returns the packed encoded size of TransferReturn
func (t TransferReturn) PackedEncodedSize() int {
	return 1
}

// PackedEncodeTo encodes TransferReturn to packed ABI bytes in the provided buffer
func (value TransferReturn) PackedEncodeTo(buf []byte) (int, error) {
	// Encode tuple fields sequentially (packed, no dynamic section)
	var (
		offset int
		n      int
		err    error
	)
	// Field Field1: bool
	n, err = abi.PackedEncodeBool(value.Field1, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// PackedEncode encodes TransferReturn to packed ABI bytes
func (value TransferReturn) PackedEncode() ([]byte, error) {
	buf := make([]byte, value.PackedEncodedSize())
	if _, err := value.PackedEncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// PackedDecode decodes TransferReturn from packed ABI bytes
func (t *TransferReturn) PackedDecode(data []byte) (int, error) {
	if len(data) < 1 {
		return 0, io.ErrUnexpectedEOF
	}
	var err error
	// Decode field Field1: bool
	t.Field1, _, err = abi.PackedDecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return 1, nil
}

// Event signatures
var (
	// Transfer(address,address,uint256)
	TransferEventTopic = common.Hash{0xdd, 0xf2, 0x52, 0xad, 0x1b, 0xe2, 0xc8, 0x9b, 0x69, 0xc2, 0xb0, 0x68, 0xfc, 0x37, 0x8d, 0xaa, 0x95, 0x2b, 0xa7, 0xf1, 0x63, 0xc4, 0xa1, 0x16, 0x28, 0xf5, 0x5a, 0x4d, 0xf5, 0x23, 0xb3, 0xef}
)

// TransferEvent represents the Transfer event
var _ abi.Event = (*TransferEvent)(nil)

type TransferEvent struct {
	TransferEventIndexed
	TransferEventData
}

// NewTransferEvent constructs a new Transfer event
func NewTransferEvent(
	from common.Address,
	to common.Address,
	value *uint256.Int,
) *TransferEvent {
	return &TransferEvent{
		TransferEventIndexed: TransferEventIndexed{
			From: from,
			To:   to,
		},
		TransferEventData: TransferEventData{
			Value: value,
		},
	}
}

// GetEventName returns the event name
func (e TransferEvent) GetEventName() string {
	return "Transfer"
}

// GetEventID returns the event ID (topic)
func (e TransferEvent) GetEventID() common.Hash {
	return TransferEventTopic
}

// Transfer represents an ABI event
type TransferEventIndexed struct {
	From common.Address
	To   common.Address
}

// EncodeTopics encodes indexed fields of Transfer event to topics
func (e TransferEventIndexed) EncodeTopics() ([]common.Hash, error) {
	topics := make([]common.Hash, 0, 3)
	topics = append(topics, TransferEventTopic)
	{
		// From
		var hash common.Hash
		if _, err := abi.EncodeAddress(e.From, hash[:]); err != nil {
			return nil, err
		}
		topics = append(topics, hash)
	}
	{
		// To
		var hash common.Hash
		if _, err := abi.EncodeAddress(e.To, hash[:]); err != nil {
			return nil, err
		}
		topics = append(topics, hash)
	}
	return topics, nil
}

// DecodeTopics decodes indexed fields of Transfer event from topics, ignore hash topics
func (e *TransferEventIndexed) DecodeTopics(topics []common.Hash) error {
	if len(topics) != 3 {
		return abi.ErrInvalidNumberOfTopics
	}
	if topics[0] != TransferEventTopic {
		return abi.ErrInvalidEventTopic
	}
	var err error
	e.From, _, err = abi.DecodeAddress(topics[1][:])
	if err != nil {
		return err
	}
	e.To, _, err = abi.DecodeAddress(topics[2][:])
	if err != nil {
		return err
	}
	return nil
}

const TransferEventDataStaticSize = 32

var _ abi.Tuple = (*TransferEventData)(nil)
var _ abi.PackedTuple = (*TransferEventData)(nil)

// TransferEventData represents an ABI tuple
type TransferEventData struct {
	Value *uint256.Int
}

// EncodedSize returns the total encoded size of TransferEventData
func (t TransferEventData) EncodedSize() int {
	dynamicSize := 0

	return TransferEventDataStaticSize + dynamicSize
}

// EncodeTo encodes TransferEventData to ABI bytes in the provided buffer
func (value TransferEventData) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TransferEventDataStaticSize // Start dynamic data after static section
	// Field Value: uint256
	if _, err := abi.EncodeUint256(value.Value, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TransferEventData to ABI bytes
func (value TransferEventData) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TransferEventData from ABI bytes in the provided buffer
func (t *TransferEventData) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Value: uint256
	t.Value, _, err = abi.DecodeUint256(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// PackedEncodedSize returns the packed encoded size of TransferEventData
func (t TransferEventData) PackedEncodedSize() int {
	return 32
}

// PackedEncodeTo encodes TransferEventData to packed ABI bytes in the provided buffer
func (value TransferEventData) PackedEncodeTo(buf []byte) (int, error) {
	// Encode tuple fields sequentially (packed, no dynamic section)
	var (
		offset int
		n      int
		err    error
	)
	// Field Value: uint256
	n, err = abi.PackedEncodeUint256(value.Value, buf[offset:])
	if err != nil {
		return 0, err
	}
	offset += n

	return offset, nil
}

// PackedEncode encodes TransferEventData to packed ABI bytes
func (value TransferEventData) PackedEncode() ([]byte, error) {
	buf := make([]byte, value.PackedEncodedSize())
	if _, err := value.PackedEncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// PackedDecode decodes TransferEventData from packed ABI bytes
func (t *TransferEventData) PackedDecode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var err error
	// Decode field Value: uint256
	t.Value, _, err = abi.PackedDecodeUint256(data[0:])
	if err != nil {
		return 0, err
	}
	return 32, nil
}
