// Code generated by go-abi. DO NOT EDIT.

package tests

import (
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/yihuang/go-abi"
)

// Function selectors
var (
	// getAddressStringPair()
	GetAddressStringPairSelector = [4]byte{0xd0, 0xbf, 0x74, 0xea}
	// getComplexNested()
	GetComplexNestedSelector = [4]byte{0xc3, 0xb9, 0xc6, 0x6e}
	// getDeeplyNested()
	GetDeeplyNestedSelector = [4]byte{0xe4, 0xba, 0x61, 0xba}
	// getMultipleReturns()
	GetMultipleReturnsSelector = [4]byte{0x3c, 0xa4, 0x69, 0x27}
	// getNestedTupleArray()
	GetNestedTupleArraySelector = [4]byte{0x94, 0x1b, 0x78, 0xaf}
	// getSimplePair()
	GetSimplePairSelector = [4]byte{0xca, 0x72, 0x93, 0xba}
	// getTupleArray()
	GetTupleArraySelector = [4]byte{0x5b, 0x0a, 0xb4, 0x41}
	// getUserWithMetadata()
	GetUserWithMetadataSelector = [4]byte{0xf4, 0x61, 0x08, 0x78}
	// getUsersArray()
	GetUsersArraySelector = [4]byte{0x99, 0xfe, 0x71, 0xef}
)

// Big endian integer versions of function selectors
const (
	GetAddressStringPairID = 3502208234
	GetComplexNestedID     = 3283732078
	GetDeeplyNestedID      = 3837419962
	GetMultipleReturnsID   = 1017407783
	GetNestedTupleArrayID  = 2484828335
	GetSimplePairID        = 3396506554
	GetTupleArrayID        = 1527428161
	GetUserWithMetadataID  = 4099999864
	GetUsersArrayID        = 2583589359
)

const AddressStringPairStaticSize = 64

// AddressStringPair represents an ABI tuple
type AddressStringPair struct {
	Addr common.Address
	Str  string
}

// EncodedSize returns the total encoded size of AddressStringPair
func (t AddressStringPair) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Str)

	return AddressStringPairStaticSize + dynamicSize
}

// EncodeTo encodes AddressStringPair to ABI bytes in the provided buffer
func (value AddressStringPair) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := AddressStringPairStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Addr: address
	if _, err := abi.EncodeAddress(value.Addr, buf[0:]); err != nil {
		return 0, err
	}

	// Field Str: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Str, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes AddressStringPair to ABI bytes
func (value AddressStringPair) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes AddressStringPair from ABI bytes in the provided buffer
func (t *AddressStringPair) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 64
	// Decode static field Addr: address
	t.Addr, _, err = abi.DecodeAddress(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Str
	{
		offset := int(binary.BigEndian.Uint64(data[32+24 : 32+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Str")
		}
		t.Str, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

const ComplexNestedStaticSize = 128

// ComplexNested represents an ABI tuple
type ComplexNested struct {
	Num  *big.Int
	Addr common.Address
	Str  string
	Data []byte
}

// EncodedSize returns the total encoded size of ComplexNested
func (t ComplexNested) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Str)
	dynamicSize += abi.SizeBytes(t.Data)

	return ComplexNestedStaticSize + dynamicSize
}

// EncodeTo encodes ComplexNested to ABI bytes in the provided buffer
func (value ComplexNested) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := ComplexNestedStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Num: uint256
	if _, err := abi.EncodeUint256(value.Num, buf[0:]); err != nil {
		return 0, err
	}

	// Field Addr: address
	if _, err := abi.EncodeAddress(value.Addr, buf[32:]); err != nil {
		return 0, err
	}

	// Field Str: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[64+24:64+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Str, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Data: bytes
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[96+24:96+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeBytes(value.Data, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes ComplexNested to ABI bytes
func (value ComplexNested) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes ComplexNested from ABI bytes in the provided buffer
func (t *ComplexNested) Decode(data []byte) (int, error) {
	if len(data) < 128 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 128
	// Decode static field Num: uint256
	t.Num, _, err = abi.DecodeUint256(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode static field Addr: address
	t.Addr, _, err = abi.DecodeAddress(data[32:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Str
	{
		offset := int(binary.BigEndian.Uint64(data[64+24 : 64+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Str")
		}
		t.Str, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Data
	{
		offset := int(binary.BigEndian.Uint64(data[96+24 : 96+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Data")
		}
		t.Data, n, err = abi.DecodeBytes(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

const DeeplyNestedStaticSize = 160

// DeeplyNested represents an ABI tuple
type DeeplyNested struct {
	Num  *big.Int
	Str  string
	Flag bool
	Addr common.Address
	Hash [32]byte
}

// EncodedSize returns the total encoded size of DeeplyNested
func (t DeeplyNested) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Str)

	return DeeplyNestedStaticSize + dynamicSize
}

// EncodeTo encodes DeeplyNested to ABI bytes in the provided buffer
func (value DeeplyNested) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := DeeplyNestedStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Num: uint256
	if _, err := abi.EncodeUint256(value.Num, buf[0:]); err != nil {
		return 0, err
	}

	// Field Str: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Str, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Flag: bool
	if _, err := abi.EncodeBool(value.Flag, buf[64:]); err != nil {
		return 0, err
	}

	// Field Addr: address
	if _, err := abi.EncodeAddress(value.Addr, buf[96:]); err != nil {
		return 0, err
	}

	// Field Hash: bytes32
	if _, err := abi.EncodeBytes32(value.Hash, buf[128:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes DeeplyNested to ABI bytes
func (value DeeplyNested) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes DeeplyNested from ABI bytes in the provided buffer
func (t *DeeplyNested) Decode(data []byte) (int, error) {
	if len(data) < 160 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 160
	// Decode static field Num: uint256
	t.Num, _, err = abi.DecodeUint256(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Str
	{
		offset := int(binary.BigEndian.Uint64(data[32+24 : 32+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Str")
		}
		t.Str, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode static field Flag: bool
	t.Flag, _, err = abi.DecodeBool(data[64:])
	if err != nil {
		return 0, err
	}
	// Decode static field Addr: address
	t.Addr, _, err = abi.DecodeAddress(data[96:])
	if err != nil {
		return 0, err
	}
	// Decode static field Hash: bytes32
	t.Hash, _, err = abi.DecodeBytes32(data[128:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

const SimplePairStaticSize = 64

// SimplePair represents an ABI tuple
type SimplePair struct {
	First  *big.Int
	Second *big.Int
}

// EncodedSize returns the total encoded size of SimplePair
func (t SimplePair) EncodedSize() int {
	dynamicSize := 0

	return SimplePairStaticSize + dynamicSize
}

// EncodeTo encodes SimplePair to ABI bytes in the provided buffer
func (value SimplePair) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := SimplePairStaticSize // Start dynamic data after static section
	// Field First: uint256
	if _, err := abi.EncodeUint256(value.First, buf[0:]); err != nil {
		return 0, err
	}

	// Field Second: uint256
	if _, err := abi.EncodeUint256(value.Second, buf[32:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes SimplePair to ABI bytes
func (value SimplePair) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes SimplePair from ABI bytes in the provided buffer
func (t *SimplePair) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 64
	// Decode static field First: uint256
	t.First, _, err = abi.DecodeUint256(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode static field Second: uint256
	t.Second, _, err = abi.DecodeUint256(data[32:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

const UserWithMetadataStaticSize = 128

// UserWithMetadata represents an ABI tuple
type UserWithMetadata struct {
	Name     string
	Id       *big.Int
	Age      *big.Int
	Metadata string
}

// EncodedSize returns the total encoded size of UserWithMetadata
func (t UserWithMetadata) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Name)
	dynamicSize += abi.SizeString(t.Metadata)

	return UserWithMetadataStaticSize + dynamicSize
}

// EncodeTo encodes UserWithMetadata to ABI bytes in the provided buffer
func (value UserWithMetadata) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := UserWithMetadataStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Name: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Name, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Id: uint256
	if _, err := abi.EncodeUint256(value.Id, buf[32:]); err != nil {
		return 0, err
	}

	// Field Age: uint256
	if _, err := abi.EncodeUint256(value.Age, buf[64:]); err != nil {
		return 0, err
	}

	// Field Metadata: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[96+24:96+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Metadata, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes UserWithMetadata to ABI bytes
func (value UserWithMetadata) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes UserWithMetadata from ABI bytes in the provided buffer
func (t *UserWithMetadata) Decode(data []byte) (int, error) {
	if len(data) < 128 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 128
	// Decode dynamic field Name
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Name")
		}
		t.Name, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode static field Id: uint256
	t.Id, _, err = abi.DecodeUint256(data[32:])
	if err != nil {
		return 0, err
	}
	// Decode static field Age: uint256
	t.Age, _, err = abi.DecodeUint256(data[64:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Metadata
	{
		offset := int(binary.BigEndian.Uint64(data[96+24 : 96+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Metadata")
		}
		t.Metadata, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// NestedEncodeAddressStringPairSlice encodes (address,string)[] to ABI bytes
func NestedEncodeAddressStringPairSlice(value []AddressStringPair, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with dynamic types
	var offset int
	dynamicOffset := len(value) * 32
	for _, elem := range value {
		// Write offset for element
		offset += 32
		binary.BigEndian.PutUint64(buf[offset-8:offset], uint64(dynamicOffset))

		// Write element at dynamic region
		n, err := elem.EncodeTo(buf[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}

	return dynamicOffset + 32, nil
}

// NestedEncodeComplexNestedSlice encodes (uint256,address,string,bytes)[] to ABI bytes
func NestedEncodeComplexNestedSlice(value []ComplexNested, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with dynamic types
	var offset int
	dynamicOffset := len(value) * 32
	for _, elem := range value {
		// Write offset for element
		offset += 32
		binary.BigEndian.PutUint64(buf[offset-8:offset], uint64(dynamicOffset))

		// Write element at dynamic region
		n, err := elem.EncodeTo(buf[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}

	return dynamicOffset + 32, nil
}

// NestedEncodeSimplePairSlice encodes (uint256,uint256)[] to ABI bytes
func NestedEncodeSimplePairSlice(value []SimplePair, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := elem.EncodeTo(buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// NestedSizeAddressStringPairSlice returns the encoded size of (address,string)[]
func NestedSizeAddressStringPairSlice(value []AddressStringPair) int {
	size := 32 + 32*len(value) // length + offset pointers for dynamic elements
	for _, elem := range value {
		size += elem.EncodedSize()
	}
	return size
}

// NestedSizeComplexNestedSlice returns the encoded size of (uint256,address,string,bytes)[]
func NestedSizeComplexNestedSlice(value []ComplexNested) int {
	size := 32 + 32*len(value) // length + offset pointers for dynamic elements
	for _, elem := range value {
		size += elem.EncodedSize()
	}
	return size
}

// NestedSizeSimplePairSlice returns the encoded size of (uint256,uint256)[]
func NestedSizeSimplePairSlice(value []SimplePair) int {
	size := 32 + 64*len(value) // length + static elements
	return size
}

// NestedDecodeAddressStringPairSlice decodes (address,string)[] from ABI bytes
func NestedDecodeAddressStringPairSlice(data []byte) ([]AddressStringPair, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 32*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with dynamic types
	result := make([]AddressStringPair, length)
	dynamicOffset := length * 32
	for i := 0; i < length; i++ {
		offset += 32
		tmp := int(binary.BigEndian.Uint64(data[offset-8 : offset]))
		if dynamicOffset != tmp {
			return nil, 0, fmt.Errorf("invalid offset for slice element %d: expected %d, got %d", i, dynamicOffset, tmp)
		}
		n, err = result[i].Decode(data[dynamicOffset:])
		if err != nil {
			return nil, 0, err
		}
		dynamicOffset += n
	}
	return result, dynamicOffset + 32, nil
}

// NestedDecodeComplexNestedSlice decodes (uint256,address,string,bytes)[] from ABI bytes
func NestedDecodeComplexNestedSlice(data []byte) ([]ComplexNested, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 32*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with dynamic types
	result := make([]ComplexNested, length)
	dynamicOffset := length * 32
	for i := 0; i < length; i++ {
		offset += 32
		tmp := int(binary.BigEndian.Uint64(data[offset-8 : offset]))
		if dynamicOffset != tmp {
			return nil, 0, fmt.Errorf("invalid offset for slice element %d: expected %d, got %d", i, dynamicOffset, tmp)
		}
		n, err = result[i].Decode(data[dynamicOffset:])
		if err != nil {
			return nil, 0, err
		}
		dynamicOffset += n
	}
	return result, dynamicOffset + 32, nil
}

// NestedDecodeSimplePairSlice decodes (uint256,uint256)[] from ABI bytes
func NestedDecodeSimplePairSlice(data []byte) ([]SimplePair, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 64*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with static types
	result := make([]SimplePair, length)
	for i := 0; i < length; i++ {
		n, err = result[i].Decode(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// GetAddressStringPairCall represents the input arguments for getAddressStringPair function
type GetAddressStringPairCall struct {
	abi.EmptyTuple
}

// GetMethodName returns the function name
func (t GetAddressStringPairCall) GetMethodName() string {
	return "getAddressStringPair"
}

// EncodeWithSelector encodes getAddressStringPair arguments to ABI bytes including function selector
func (t GetAddressStringPairCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], GetAddressStringPairSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const GetAddressStringPairReturnStaticSize = 32

// GetAddressStringPairReturn represents an ABI tuple
type GetAddressStringPairReturn struct {
	Field1 AddressStringPair
}

// EncodedSize returns the total encoded size of GetAddressStringPairReturn
func (t GetAddressStringPairReturn) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.Field1.EncodedSize()

	return GetAddressStringPairReturnStaticSize + dynamicSize
}

// EncodeTo encodes GetAddressStringPairReturn to ABI bytes in the provided buffer
func (value GetAddressStringPairReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := GetAddressStringPairReturnStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Field1: (address,string)
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.Field1.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes GetAddressStringPairReturn to ABI bytes
func (value GetAddressStringPairReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes GetAddressStringPairReturn from ABI bytes in the provided buffer
func (t *GetAddressStringPairReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field Field1
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Field1")
		}
		n, err = t.Field1.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetComplexNestedCall represents the input arguments for getComplexNested function
type GetComplexNestedCall struct {
	abi.EmptyTuple
}

// GetMethodName returns the function name
func (t GetComplexNestedCall) GetMethodName() string {
	return "getComplexNested"
}

// EncodeWithSelector encodes getComplexNested arguments to ABI bytes including function selector
func (t GetComplexNestedCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], GetComplexNestedSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const GetComplexNestedReturnStaticSize = 32

// GetComplexNestedReturn represents an ABI tuple
type GetComplexNestedReturn struct {
	Field1 ComplexNested
}

// EncodedSize returns the total encoded size of GetComplexNestedReturn
func (t GetComplexNestedReturn) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.Field1.EncodedSize()

	return GetComplexNestedReturnStaticSize + dynamicSize
}

// EncodeTo encodes GetComplexNestedReturn to ABI bytes in the provided buffer
func (value GetComplexNestedReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := GetComplexNestedReturnStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Field1: (uint256,address,string,bytes)
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.Field1.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes GetComplexNestedReturn to ABI bytes
func (value GetComplexNestedReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes GetComplexNestedReturn from ABI bytes in the provided buffer
func (t *GetComplexNestedReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field Field1
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Field1")
		}
		n, err = t.Field1.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetDeeplyNestedCall represents the input arguments for getDeeplyNested function
type GetDeeplyNestedCall struct {
	abi.EmptyTuple
}

// GetMethodName returns the function name
func (t GetDeeplyNestedCall) GetMethodName() string {
	return "getDeeplyNested"
}

// EncodeWithSelector encodes getDeeplyNested arguments to ABI bytes including function selector
func (t GetDeeplyNestedCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], GetDeeplyNestedSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const GetDeeplyNestedReturnStaticSize = 32

// GetDeeplyNestedReturn represents an ABI tuple
type GetDeeplyNestedReturn struct {
	Field1 DeeplyNested
}

// EncodedSize returns the total encoded size of GetDeeplyNestedReturn
func (t GetDeeplyNestedReturn) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.Field1.EncodedSize()

	return GetDeeplyNestedReturnStaticSize + dynamicSize
}

// EncodeTo encodes GetDeeplyNestedReturn to ABI bytes in the provided buffer
func (value GetDeeplyNestedReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := GetDeeplyNestedReturnStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Field1: (uint256,string,bool,address,bytes32)
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.Field1.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes GetDeeplyNestedReturn to ABI bytes
func (value GetDeeplyNestedReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes GetDeeplyNestedReturn from ABI bytes in the provided buffer
func (t *GetDeeplyNestedReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field Field1
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Field1")
		}
		n, err = t.Field1.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMultipleReturnsCall represents the input arguments for getMultipleReturns function
type GetMultipleReturnsCall struct {
	abi.EmptyTuple
}

// GetMethodName returns the function name
func (t GetMultipleReturnsCall) GetMethodName() string {
	return "getMultipleReturns"
}

// EncodeWithSelector encodes getMultipleReturns arguments to ABI bytes including function selector
func (t GetMultipleReturnsCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], GetMultipleReturnsSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const GetMultipleReturnsReturnStaticSize = 96

// GetMultipleReturnsReturn represents an ABI tuple
type GetMultipleReturnsReturn struct {
	Field1 *big.Int
	Field2 AddressStringPair
	Field3 bool
}

// EncodedSize returns the total encoded size of GetMultipleReturnsReturn
func (t GetMultipleReturnsReturn) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.Field2.EncodedSize()

	return GetMultipleReturnsReturnStaticSize + dynamicSize
}

// EncodeTo encodes GetMultipleReturnsReturn to ABI bytes in the provided buffer
func (value GetMultipleReturnsReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := GetMultipleReturnsReturnStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Field1: uint256
	if _, err := abi.EncodeUint256(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	// Field Field2: (address,string)
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.Field2.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field3: bool
	if _, err := abi.EncodeBool(value.Field3, buf[64:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes GetMultipleReturnsReturn to ABI bytes
func (value GetMultipleReturnsReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes GetMultipleReturnsReturn from ABI bytes in the provided buffer
func (t *GetMultipleReturnsReturn) Decode(data []byte) (int, error) {
	if len(data) < 96 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 96
	// Decode static field Field1: uint256
	t.Field1, _, err = abi.DecodeUint256(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Field2
	{
		offset := int(binary.BigEndian.Uint64(data[32+24 : 32+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Field2")
		}
		n, err = t.Field2.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode static field Field3: bool
	t.Field3, _, err = abi.DecodeBool(data[64:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// GetNestedTupleArrayCall represents the input arguments for getNestedTupleArray function
type GetNestedTupleArrayCall struct {
	abi.EmptyTuple
}

// GetMethodName returns the function name
func (t GetNestedTupleArrayCall) GetMethodName() string {
	return "getNestedTupleArray"
}

// EncodeWithSelector encodes getNestedTupleArray arguments to ABI bytes including function selector
func (t GetNestedTupleArrayCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], GetNestedTupleArraySelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const GetNestedTupleArrayReturnStaticSize = 32

// GetNestedTupleArrayReturn represents an ABI tuple
type GetNestedTupleArrayReturn struct {
	Field1 []ComplexNested
}

// EncodedSize returns the total encoded size of GetNestedTupleArrayReturn
func (t GetNestedTupleArrayReturn) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += NestedSizeComplexNestedSlice(t.Field1)

	return GetNestedTupleArrayReturnStaticSize + dynamicSize
}

// EncodeTo encodes GetNestedTupleArrayReturn to ABI bytes in the provided buffer
func (value GetNestedTupleArrayReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := GetNestedTupleArrayReturnStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Field1: (uint256,address,string,bytes)[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = NestedEncodeComplexNestedSlice(value.Field1, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes GetNestedTupleArrayReturn to ABI bytes
func (value GetNestedTupleArrayReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes GetNestedTupleArrayReturn from ABI bytes in the provided buffer
func (t *GetNestedTupleArrayReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field Field1
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Field1")
		}
		t.Field1, n, err = NestedDecodeComplexNestedSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetSimplePairCall represents the input arguments for getSimplePair function
type GetSimplePairCall struct {
	abi.EmptyTuple
}

// GetMethodName returns the function name
func (t GetSimplePairCall) GetMethodName() string {
	return "getSimplePair"
}

// EncodeWithSelector encodes getSimplePair arguments to ABI bytes including function selector
func (t GetSimplePairCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], GetSimplePairSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const GetSimplePairReturnStaticSize = 64

// GetSimplePairReturn represents an ABI tuple
type GetSimplePairReturn struct {
	Field1 SimplePair
}

// EncodedSize returns the total encoded size of GetSimplePairReturn
func (t GetSimplePairReturn) EncodedSize() int {
	dynamicSize := 0

	return GetSimplePairReturnStaticSize + dynamicSize
}

// EncodeTo encodes GetSimplePairReturn to ABI bytes in the provided buffer
func (value GetSimplePairReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := GetSimplePairReturnStaticSize // Start dynamic data after static section
	// Field Field1: (uint256,uint256)
	if _, err := value.Field1.EncodeTo(buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes GetSimplePairReturn to ABI bytes
func (value GetSimplePairReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes GetSimplePairReturn from ABI bytes in the provided buffer
func (t *GetSimplePairReturn) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 64
	// Decode static field Field1: (uint256,uint256)
	_, err = t.Field1.Decode(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// GetTupleArrayCall represents the input arguments for getTupleArray function
type GetTupleArrayCall struct {
	abi.EmptyTuple
}

// GetMethodName returns the function name
func (t GetTupleArrayCall) GetMethodName() string {
	return "getTupleArray"
}

// EncodeWithSelector encodes getTupleArray arguments to ABI bytes including function selector
func (t GetTupleArrayCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], GetTupleArraySelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const GetTupleArrayReturnStaticSize = 32

// GetTupleArrayReturn represents an ABI tuple
type GetTupleArrayReturn struct {
	Field1 []SimplePair
}

// EncodedSize returns the total encoded size of GetTupleArrayReturn
func (t GetTupleArrayReturn) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += NestedSizeSimplePairSlice(t.Field1)

	return GetTupleArrayReturnStaticSize + dynamicSize
}

// EncodeTo encodes GetTupleArrayReturn to ABI bytes in the provided buffer
func (value GetTupleArrayReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := GetTupleArrayReturnStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Field1: (uint256,uint256)[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = NestedEncodeSimplePairSlice(value.Field1, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes GetTupleArrayReturn to ABI bytes
func (value GetTupleArrayReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes GetTupleArrayReturn from ABI bytes in the provided buffer
func (t *GetTupleArrayReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field Field1
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Field1")
		}
		t.Field1, n, err = NestedDecodeSimplePairSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetUserWithMetadataCall represents the input arguments for getUserWithMetadata function
type GetUserWithMetadataCall struct {
	abi.EmptyTuple
}

// GetMethodName returns the function name
func (t GetUserWithMetadataCall) GetMethodName() string {
	return "getUserWithMetadata"
}

// EncodeWithSelector encodes getUserWithMetadata arguments to ABI bytes including function selector
func (t GetUserWithMetadataCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], GetUserWithMetadataSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const GetUserWithMetadataReturnStaticSize = 32

// GetUserWithMetadataReturn represents an ABI tuple
type GetUserWithMetadataReturn struct {
	Field1 UserWithMetadata
}

// EncodedSize returns the total encoded size of GetUserWithMetadataReturn
func (t GetUserWithMetadataReturn) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.Field1.EncodedSize()

	return GetUserWithMetadataReturnStaticSize + dynamicSize
}

// EncodeTo encodes GetUserWithMetadataReturn to ABI bytes in the provided buffer
func (value GetUserWithMetadataReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := GetUserWithMetadataReturnStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Field1: (string,uint256,uint256,string)
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.Field1.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes GetUserWithMetadataReturn to ABI bytes
func (value GetUserWithMetadataReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes GetUserWithMetadataReturn from ABI bytes in the provided buffer
func (t *GetUserWithMetadataReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field Field1
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Field1")
		}
		n, err = t.Field1.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetUsersArrayCall represents the input arguments for getUsersArray function
type GetUsersArrayCall struct {
	abi.EmptyTuple
}

// GetMethodName returns the function name
func (t GetUsersArrayCall) GetMethodName() string {
	return "getUsersArray"
}

// EncodeWithSelector encodes getUsersArray arguments to ABI bytes including function selector
func (t GetUsersArrayCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], GetUsersArraySelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const GetUsersArrayReturnStaticSize = 32

// GetUsersArrayReturn represents an ABI tuple
type GetUsersArrayReturn struct {
	Field1 []AddressStringPair
}

// EncodedSize returns the total encoded size of GetUsersArrayReturn
func (t GetUsersArrayReturn) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += NestedSizeAddressStringPairSlice(t.Field1)

	return GetUsersArrayReturnStaticSize + dynamicSize
}

// EncodeTo encodes GetUsersArrayReturn to ABI bytes in the provided buffer
func (value GetUsersArrayReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := GetUsersArrayReturnStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Field1: (address,string)[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = NestedEncodeAddressStringPairSlice(value.Field1, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes GetUsersArrayReturn to ABI bytes
func (value GetUsersArrayReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes GetUsersArrayReturn from ABI bytes in the provided buffer
func (t *GetUsersArrayReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field Field1
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Field1")
		}
		t.Field1, n, err = NestedDecodeAddressStringPairSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}
