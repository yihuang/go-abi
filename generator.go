package abi

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"text/template"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"

	"github.com/ethereum/go-ethereum/accounts/abi"
)

var Title = cases.Title(language.English, cases.NoLower)

type M = map[string]interface{}

// Generator handles ABI code generation
type Generator struct {
	buf bytes.Buffer

	PackageName string
	Imports     []string
	Selectors   []SelectorInfo
}

// SelectorInfo holds information about a function selector
type SelectorInfo struct {
	Name  string
	Sig   string
	Bytes [4]byte
}

// NewGenerator creates a new ABI code generator
func NewGenerator(packageName string) *Generator {
	return &Generator{
		PackageName: packageName,
		Imports: []string{
			"fmt",
			"encoding/binary",
			"math/big",
			"github.com/ethereum/go-ethereum/common",
			"github.com/yihuang/go-abi",
		},
		Selectors: []SelectorInfo{},
	}
}

func (g *Generator) L(format string, args ...any) {
	fmt.Fprintf(&g.buf, format, args...)
	fmt.Fprint(&g.buf, "\n")
}

func (g *Generator) T(tpl string, m map[string]interface{}) {
	t := template.Must(template.New("").Parse(tpl))
	t.Execute(&g.buf, m)
}

// GenerateFromABI generates Go code from ABI JSON
func (g *Generator) GenerateFromABI(abiDef abi.ABI) (string, error) {
	// Write do not edit warning
	g.L("// Code generated by go-abi. DO NOT EDIT.")
	g.L("")

	// Write package declaration
	g.L("package %s", g.PackageName)

	// Write imports
	if len(g.Imports) > 0 {
		g.L("import (")
		for _, imp := range g.Imports {
			g.L("\"%s\"", imp)
		}
		g.L(")")
	}

	// First, generate all tuple structs needed for this function
	var methods []abi.Method
	for _, name := range SortedMapKeys(abiDef.Methods) {
		methods = append(methods, abiDef.Methods[name])
	}

	// Collect all selectors
	for _, method := range methods {
		selectorName := fmt.Sprintf("%sSelector", Title.String(method.Name))
		g.Selectors = append(g.Selectors, SelectorInfo{
			Name:  selectorName,
			Sig:   method.Sig,
			Bytes: [4]byte{method.ID[0], method.ID[1], method.ID[2], method.ID[3]},
		})
	}

	// Generate all selector constants at the beginning
	g.genAllSelectors()

	if err := g.genTuples(methods); err != nil {
		return "", err
	}

	// Generate code for each function
	for _, method := range methods {
		if err := g.genFunction(method); err != nil {
			return "", fmt.Errorf("failed to generate function %s: %w", method.Name, err)
		}
	}

	// Format the generated code
	return string(g.buf.Bytes()), nil
}

func (g *Generator) genStruct(s Struct) error {
	g.L(`
const %sStaticSize = %d

// %s represents an ABI tuple
type %s struct {
`, s.Name, GetTupleSize(s.Types()), s.Name, s.Name)

	for _, f := range s.Fields {
		goType := abiTypeToGoType(*f.Type)
		g.L("%s %s", f.Name, goType)
	}
	g.L("}")
	return nil
}

// genFunction generates Go code for a single function
func (g *Generator) genFunction(method abi.Method) error {
	selectorName := fmt.Sprintf("%sSelector", Title.String(method.Name))

	// Generate struct and methods for functions with inputs
	if len(method.Inputs) > 0 {
		s := StructFromInputs(method)
		if err := g.genStruct(s); err != nil {
			return err
		}

		g.genStructMethods(s)

		g.L(`
// EncodeWithSelector encodes %s arguments to ABI bytes including function selector
func (t %s) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4 + t.EncodedSize())
	copy(result[:4], %s[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}
`, method.Name, s.Name, selectorName)
	}

	// Generate struct and methods for functions with outputs
	if len(method.Outputs) > 0 {
		s := StructFromOutputs(method)
		if err := g.genStruct(s); err != nil {
			return err
		}

		g.genStructMethods(s)
	}

	return nil
}

// abiTypeToGoType converts ABI type to Go type
func abiTypeToGoType(abiType abi.Type) string {
	switch abiType.T {
	case abi.UintTy:
		// Use native Go types for common sizes to avoid big.Int allocations
		switch abiType.Size {
		case 8, 16, 32, 64:
			return fmt.Sprintf("uint%d", abiType.Size)
		default:
			return "*big.Int"
		}
	case abi.IntTy:
		// Use native Go types for common sizes to avoid big.Int allocations
		switch abiType.Size {
		case 8, 16, 32, 64:
			return fmt.Sprintf("int%d", abiType.Size)
		default:
			return "*big.Int"
		}
	case abi.AddressTy:
		return "common.Address"
	case abi.BoolTy:
		return "bool"
	case abi.StringTy:
		return "string"
	case abi.BytesTy:
		return "[]byte"
	case abi.FixedBytesTy:
		return fmt.Sprintf("[%d]byte", abiType.Size)
	case abi.SliceTy:
		// Dynamic arrays like uint256[]
		if abiType.Elem == nil {
			panic("invalid slice type: nil element")
		}
		elemType := abiTypeToGoType(*abiType.Elem)
		return fmt.Sprintf("[]%s", elemType)
	case abi.ArrayTy:
		// Fixed-size arrays like uint256[10]
		if abiType.Elem == nil {
			panic("invalid array type: nil element")
		}
		elemType := abiTypeToGoType(*abiType.Elem)
		return fmt.Sprintf("[%d]%s", abiType.Size, elemType)
	case abi.TupleTy:
		// Handle tuple types - generate struct type name
		return TupleStructName(abiType)
	default:
		panic(fmt.Sprintf("unsupported ABI type: %s", abiType.String()))
	}
}

// genTuples generates all tuple structs needed for a function
func (g *Generator) genTuples(methods []abi.Method) error {
	// Collect all tuple types from function inputs and outputs
	tupleTypes := make(map[string]abi.Type)

	var collectTuples func(t abi.Type)
	collectTuples = func(t abi.Type) {
		if t.T == abi.TupleTy {
			structName := TupleStructName(t)
			if _, exists := tupleTypes[structName]; !exists {
				tupleTypes[structName] = t
				// Recursively collect nested tuples
				for _, elem := range t.TupleElems {
					collectTuples(*elem)
				}
			}
		} else if t.T == abi.ArrayTy || t.T == abi.SliceTy {
			// Check array elements for tuples
			if t.Elem != nil {
				collectTuples(*t.Elem)
			}
		}
	}

	// Collect tuples from all methods
	for _, method := range methods {
		// Collect tuples from all inputs
		for _, input := range method.Inputs {
			collectTuples(input.Type)
		}
		// Collect tuples from all outputs
		for _, output := range method.Outputs {
			collectTuples(output.Type)
		}
	}

	// Generate struct definitions for collected tuples
	for _, name := range SortedMapKeys(tupleTypes) {
		s := StructFromTuple(tupleTypes[name])
		if err := g.genStruct(s); err != nil {
			return err
		}

		// Generate encode method for the tuple struct
		g.genStructMethods(s)
	}

	return nil
}

// genSize generates size calculation logic for a type
func (g *Generator) genSize(t abi.Type, acc string, ref string) {
	if !IsDynamicType(t) {
		g.L("%s += %d // static element %s", acc, GetTypeSize(t), ref)
		return
	}

	switch t.T {
	case abi.StringTy:
		g.L("%s += 32 + abi.Pad32(len(%s)) // length + padded string data", acc, ref)

	case abi.BytesTy:
		g.L("%s += 32 + abi.Pad32(len(%s)) // length + padded bytes data", acc, ref)

	case abi.SliceTy:
		if IsDynamicType(*t.Elem) {
			// Dynamic array with dynamic elements
			g.L("%s += 32 + 32 * len(%s) // length + offset pointers for dynamic elements", acc, ref)
			g.L("for _, elem := range %s {", ref)
			g.genSize(*t.Elem, acc, "elem")
			g.L("}")
		} else {
			// Dynamic array with static elements
			g.L("%s += 32 + %d * len(%s) // length + static elements", acc, GetTypeSize(*t.Elem), ref)
		}

	case abi.ArrayTy:
		// Fixed size array of dynamic element types
		g.L("for _, elem := range %s {", ref)
		g.genSize(*t.Elem, acc, "elem")
		g.L("}")

	case abi.TupleTy:
		// Dynamic tuple, just call tuple struct method
		g.L("%s += %s.EncodedSize() // dynamic tuple", acc, ref)

	default:
		panic("impossible")
	}
}

// genEncodedSize generates the size calculation logic without selector
func (g *Generator) genEncodedSize(s Struct) {
	g.L(`
// EncodedSize returns the total encoded size of %s
func (t %s) EncodedSize() int {
	dynamicSize := 0
`, s.Name, s.Name)

	for _, f := range s.Fields {
		if !IsDynamicType(*f.Type) {
			continue
		}
		g.genSize(*f.Type, "dynamicSize", "t."+f.Name)
	}

	g.L(`
	return %sStaticSize + dynamicSize
}`, s.Name)
}

// genEncodedTo the `EncodeTo(buf []byte) (int, error)` method
func (g *Generator) genEncodedTo(s Struct) {
	g.L(`
// EncodeTo encodes %s to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t %s) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := %sStaticSize // Start dynamic data after static section
`, s.Name, s.Name, s.Name)

	var offset int
	for _, f := range s.Fields {
		if !IsDynamicType(*f.Type) {
			g.L("// %s (static)", f.Name)
			offset = g.genStaticItem("t."+f.Name, *f.Type, offset)
			continue
		}

		g.L(`
	// %s (offset)
	binary.BigEndian.PutUint64(buf[%d+24:%d+32], uint64(dynamicOffset))
`, f.Name, offset, offset)

		// Generate encoding for dynamic element
		g.L("// %s (dynamic)", f.Name)
		g.genDynamicItem(fmt.Sprintf("t.%s", f.Name), *f.Type)

		offset += 32
	}

	g.L(`
	return dynamicOffset, nil
}
`)
}

// genStructMethods generates an Encode method for tuple structs
func (g *Generator) genStructMethods(s Struct) {
	g.genEncodedSize(s)
	g.genEncodedTo(s)

	g.L(`// Encode encodes %s to ABI bytes
func (t %s) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}
`, s.Name, s.Name)

	g.genDecodeFrom(s)
	g.genDecode(s)
}

func (g *Generator) genIntOffset(ref string, t abi.Type) {
	// Check if we can use native Go types for optimization
	switch t.Size {
	case 8:
		if t.T == abi.IntTy {
			// int8 - sign extend to 32 bytes
			g.L(`
if %s < 0 {
	for i := 0; i < 31; i++ { buf[offset+i] = 0xff }
}
buf[offset+31] = byte(%s)
`, ref, ref)
		} else {
			// uint8 - zero extend to 32 bytes
			g.L("buf[offset+31] = byte(%s)", ref)
		}
	case 16:
		if t.T == abi.IntTy {
			// int16 - sign extend to 32 bytes
			g.L(`
if %s < 0 {
	for i := 0; i < 30; i++ { buf[offset+i] = 0xff }
}
binary.BigEndian.PutUint16(buf[offset+30:offset+32], uint16(%s))
`, ref, ref)
		} else {
			// uint16 - zero extend to 32 bytes
			g.L("binary.BigEndian.PutUint16(buf[offset+30:offset+32], uint16(%s))", ref)
		}
	case 24, 32:
		if t.T == abi.IntTy {
			// int32 - sign extend to 32 bytes
			g.L(`
if %s < 0 {
	for i := 0; i < 28; i++ { buf[offset+i] = 0xff }
}
binary.BigEndian.PutUint32(buf[offset+28:offset+32], uint32(%s))
`, ref, ref)
		} else {
			// uint32 - zero extend to 32 bytes
			g.L("binary.BigEndian.PutUint32(buf[offset+28:offset+32], uint32(%s))", ref)
		}
	case 40, 48, 56, 64:
		if t.T == abi.IntTy {
			// int64 - sign extend to 32 bytes
			g.L(`
if %s < 0 {
	for i := 0; i < 24; i++ { buf[offset+i] = 0xff }
}
binary.BigEndian.PutUint64(buf[offset+24:offset+32], uint64(%s))
`, ref, ref)
		} else {
			// uint64 - zero extend to 32 bytes
			g.L("binary.BigEndian.PutUint64(buf[offset+24:offset+32], uint64(%s))", ref)
		}
	default:
		signed := "false"
		if t.T == abi.IntTy {
			signed = "true"
		}

		g.L(`
if err := abi.EncodeBigInt(%s, buf[offset:offset+32], %s); err != nil {
	return 0, err
}
`, ref, signed)
	}
}

func (g *Generator) genInt(ref string, t abi.Type, offset int) int {
	// Check if we can use native Go types for optimization
	switch t.Size {
	case 8:
		if t.T == abi.IntTy {
			// int8 - sign extend to 32 bytes
			g.L(`
if %s < 0 {
	for i := 0; i < 31; i++ { buf[%d+i] = 0xff }
}
buf[%d+31] = byte(%s)
`, ref, offset, offset, ref)
		} else {
			// uint8 - zero extend to 32 bytes
			g.L("buf[%d+31] = byte(%s)", offset, ref)
		}

	case 16:
		if t.T == abi.IntTy {
			// int16 - sign extend to 32 bytes
			g.L(`
if %s < 0 {
	for i := 0; i < 30; i++ { buf[%d+i] = 0xff }
}
binary.BigEndian.PutUint16(buf[%d+30:%d+32], uint16(%s))
`, ref, offset, offset, offset, ref)
		} else {
			// uint16 - zero extend to 32 bytes
			g.L("binary.BigEndian.PutUint16(buf[%d+30:%d+32], uint16(%s))", offset, offset, ref)
		}

	case 24, 32:
		if t.T == abi.IntTy {
			// int32 - sign extend to 32 bytes
			g.L(`
if %s < 0 {
	for i := 0; i < 28; i++ { buf[%d+i] = 0xff }
}
binary.BigEndian.PutUint32(buf[%d+28:%d+32], uint32(%s))
`, ref, offset, offset, offset, ref)
		} else {
			// uint32 - zero extend to 32 bytes
			g.L("binary.BigEndian.PutUint32(buf[%d+28:%d+32], uint32(%s))", offset, offset, ref)
		}

	case 40, 48, 56, 64:
		if t.T == abi.IntTy {
			// int64 - sign extend to 32 bytes
			g.L(`
if %s < 0 {
	for i := 0; i < 24; i++ { buf[%d+i] = 0xff }
}
binary.BigEndian.PutUint64(buf[%d+24:%d+32], uint64(%s))
`, ref, offset, offset, offset, ref)
		} else {
			// uint64 - zero extend to 32 bytes
			g.L("binary.BigEndian.PutUint64(buf[%d+24:%d+32], uint64(%s))", offset, offset, ref)
		}

	default:
		signed := "false"
		if t.T == abi.IntTy {
			signed = "true"
		}
		g.L(`
if err := abi.EncodeBigInt(%s, buf[%d:%d], %s); err != nil {
	return 0, err
}
`, ref, offset, offset+32, signed)

	}

	return offset + 32
}

// genAllSelectors generates all selector constants at the beginning of the file
func (g *Generator) genAllSelectors() {
	if len(g.Selectors) == 0 {
		return
	}

	g.L(`
	// Function selectors
	var (`)
	for _, selector := range g.Selectors {
		g.L("// %s", selector.Sig)
		g.L("%s = [4]byte{0x%02x, 0x%02x, 0x%02x, 0x%02x}",
			selector.Name,
			selector.Bytes[0],
			selector.Bytes[1],
			selector.Bytes[2],
			selector.Bytes[3])
	}
	g.L(")")

	g.L(`
	// Big endian integer versions of function selectors
	const (`)
	for _, selector := range g.Selectors {
		// Generate integer version of selector
		selectorInt := binary.BigEndian.Uint32(selector.Bytes[:])
		g.L("%sInt = %d", selector.Name, selectorInt)
	}
	g.L(")")
}

// genStaticItemOffset generates encoding for a single tuple element in tuple Encode method
func (g *Generator) genStaticItemOffset(ref string, t abi.Type) {
	switch t.T {
	case abi.AddressTy:
		g.L("copy(buf[offset+12:offset+32], %s[:])", ref)

	case abi.UintTy, abi.IntTy:
		g.genIntOffset(ref, t)

	case abi.BoolTy:
		g.L(`
if %s {
	buf[offset+31] = 1
}
`, ref)

	case abi.FixedBytesTy:
		g.L("copy(buf[offset:offset+32], %s[:])", ref)

	case abi.ArrayTy:
		// Fixed-size array with static elements
		elemSize := GetTypeSize(*t.Elem)
		g.L(`
// Encode fixed-size array %s
for _, item := range %s {
`, ref, ref)

		g.genStaticItemOffset("item", *t.Elem)

		g.L(`
	offset += %d
}
`, elemSize)

	case abi.TupleTy:
		// Nested static tuple - use the generated EncodeTo method
		g.L(`
// Encode nested tuple %s
if _, err := %s.EncodeTo(buf[offset:]); err != nil {
	return 0, err
}
`, ref, ref)

	default:
		panic("unknown static type")
	}
}

// genStaticItem generates encoding for a single tuple element in tuple Encode method
func (g *Generator) genStaticItem(ref string, elemType abi.Type, offset int) int {
	switch elemType.T {
	case abi.AddressTy:
		g.L("copy(buf[%d+12:%d+32], %s[:])", offset, offset, ref)
		offset += 32

	case abi.UintTy, abi.IntTy:
		offset = g.genInt(ref, elemType, offset)

	case abi.BoolTy:
		g.L(`
if %s {
	buf[%d+31] = 1
}
`, ref, offset)
		offset += 32

	case abi.FixedBytesTy:
		g.L("copy(buf[%d:%d+32], %s[:])", offset, offset, ref)
		offset += 32

	case abi.ArrayTy:
		// Fixed-size array with static elements
		g.L(`
// Encode fixed-size array %s
{
	offset := %d
	for _, item := range %s {
`, ref, offset, ref)

		g.genStaticItemOffset("item", *elemType.Elem)

		g.L(`
	offset += %d
	}
}
`, GetTypeSize(*elemType.Elem))

		offset += elemType.Size * GetTypeSize(*elemType.Elem)

	case abi.TupleTy:
		// Nested static tuple - use the generated EncodeTo method
		g.L(`
// Encode nested tuple %s
if _, err := %s.EncodeTo(buf[%d:]); err != nil {
	return 0, err
}
`, ref, ref, offset)

		offset += GetTypeSize(elemType)

	default:
		panic("unknown static type")
	}

	return offset
}

// genDynamicItem generate code to write element into the dynamic section
func (g *Generator) genDynamicItem(ref string, t abi.Type) {
	switch t.T {
	case abi.StringTy:
		g.L(`// length
binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(%s)))
dynamicOffset += 32

// data
copy(buf[dynamicOffset:], []byte(%s))
dynamicOffset += abi.Pad32(len(%s))
`, ref, ref, ref)

	case abi.BytesTy:
		g.L(`// length
binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(%s)))
dynamicOffset += 32

// data
copy(buf[dynamicOffset:], %s)
dynamicOffset += abi.Pad32(len(%s))
`, ref, ref, ref)

	case abi.TupleTy:
		g.L(`n, err := %s.EncodeTo(buf[dynamicOffset:])
if err != nil {
	return 0, err
}
dynamicOffset += n
`, ref)

	case abi.SliceTy:
		g.L(`{
	// length
	binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(%s)))
	dynamicOffset += 32
`, ref)

		if IsDynamicType(*t.Elem) {
			g.L(`
	var written int

	// data with dynamic region
	{
		buf := buf[dynamicOffset:]
		dynamicOffset := len(%s) * 32 // start after static region

		var offset int
		for _, item := range %s {
			// write offsets
			binary.BigEndian.PutUint64(buf[offset+24:offset+32], uint64(dynamicOffset))
			offset += 32

			// write data (dynamic)
`, ref, ref)

			g.genDynamicItem("item", *t.Elem)

			g.L(`
		}
		written = dynamicOffset
	}
	dynamicOffset += written
`)
		} else {
			elemSize := GetTypeSize(*t.Elem)
			g.L(`
	// data without dynamic region
	buf := buf[dynamicOffset:]
	var offset int
	for _, item := range %s {
`, ref)
			g.genStaticItemOffset("item", *t.Elem)
			g.L(`
		offset += %d
	}
	dynamicOffset += offset
`, elemSize)
		}

		g.L("}")

	case abi.ArrayTy:
		g.L(`
{
	var written int

	// data with dynamic region
	{
		buf := buf[dynamicOffset:]
		dynamicOffset := %d * 32 // start after static region

		var offset int
		for _, item := range %s {
			// write offsets
			binary.BigEndian.PutUint64(buf[offset+24:offset+32], uint64(dynamicOffset))
			offset += 32

			// write data (dynamic)
`, t.Size, ref)

		g.genDynamicItem("item", *t.Elem)

		g.L(`
		}
		written = dynamicOffset
	}
	dynamicOffset += written
}
`)

	default:
		panic("unknown dynamic type")
	}
}

// genDecode generates the Decode method
func (g *Generator) genDecode(s Struct) {
	g.L(`// Decode decodes %s from ABI bytes
func (t *%s) Decode(data []byte) error {
	return t.DecodeFrom(data)
}
`, s.Name, s.Name)
}

// genDecodeFrom generates the DecodeFrom method
func (g *Generator) genDecodeFrom(s Struct) {
	g.L(`// DecodeFrom decodes %s from ABI bytes in the provided buffer
func (t *%s) DecodeFrom(data0 []byte) error {
	if len(data0) < %sStaticSize {
		return fmt.Errorf("insufficient data for %s")
	}
`, s.Name, s.Name, s.Name, s.Name)

	// Generate decoding for each field
	offset := 0
	for _, f := range s.Fields {
		ref := "t." + f.Name
		if !IsDynamicType(*f.Type) {
			g.genStaticDecode(ref, *f.Type, offset, 0)
			offset += GetTypeSize(*f.Type)
			continue
		}

		// For dynamic types, we need to read the offset first
		g.L(`// %s
{
	offset := int(binary.BigEndian.Uint64(data0[%d+24:%d+32]))
`, f.Name, offset, offset)

		g.genDynamicDecode(ref, *f.Type, 0)

		g.L("}")
		offset += 32
	}

	g.L(`
	return nil
}
`)
}

// genStaticDecodeOffset generates decoding logic for static types
func (g *Generator) genStaticDecodeOffset(ref string, t abi.Type, depth int) {
	typeName := abiTypeToGoType(t)

	g.L(`// %s (static)`, ref)

	switch t.T {
	case abi.AddressTy:
		g.L(`copy(%s[:], data%d[offset+12:offset+32])`, ref, depth)

	case abi.UintTy, abi.IntTy:
		if t.Size == 8 || t.Size == 16 || t.Size == 32 || t.Size == 64 {
			// Native Go types
			if t.Size == 8 {
				// uint8/int8 - read single byte
				if t.T == abi.IntTy {
					g.L(`%s = %s(data%d[offset+31])`, ref, typeName, depth)
				} else {
					g.L(`%s = %s(data%d[offset+31])`, ref, typeName, depth)
				}
			} else {
				// uint16/32/64 - use binary.BigEndian
				if t.T == abi.IntTy {
					g.L(`%s = %s(binary.BigEndian.Uint%d(data%d[offset+%d:offset+%d]))`, ref, typeName, t.Size, depth, 32-t.Size/8, 32)
				} else {
					g.L(`%s = %s(binary.BigEndian.Uint%d(data%d[offset+%d:offset+%d]))`, ref, typeName, t.Size, depth, 32-t.Size/8, 32)
				}
			}
		} else {
			// big.Int types
			g.L(`%s = new(big.Int).SetBytes(data%d[offset:offset+32])`, ref, depth)
		}

	case abi.BoolTy:
		g.L(`%s = data%d[offset+31] == 1`, ref, depth)

	case abi.FixedBytesTy:
		g.L(`copy(%s[:], data%d[offset:offset+%d])`, ref, depth, t.Size)

	case abi.ArrayTy:
		// Fixed-size array with static elements
		g.T(`// Decode fixed-size array {{.ref}}
for i{{.depth}} := 0; i{{.depth}} < {{.size}}; i{{.depth}}++ {
`, M{"ref": ref, "size": t.Size, "depth": depth})

		elemRef := fmt.Sprintf("%s[i%d]", ref, depth)
		g.genStaticDecodeOffset(elemRef, *t.Elem, depth+1)

		g.L(`
offset += %d
	}`, GetTypeSize(*t.Elem))

	case abi.TupleTy:
		// Nested static tuple
		g.L(`if err := %s.DecodeFrom(data%d[offset:offset+%d]); err != nil {
		return err
	}`, ref, depth, GetTypeSize(t))

	default:
		panic("unknown static type")
	}
}

// genStaticDecode generates decoding logic for static types
func (g *Generator) genStaticDecode(ref string, t abi.Type, offset int, depth int) {
	typeName := abiTypeToGoType(t)

	g.L(`// %s (static)`, ref)

	switch t.T {
	case abi.AddressTy:
		g.L(`copy(%s[:], data%d[%d+12:%d+32])`, ref, depth, offset, offset)

	case abi.UintTy, abi.IntTy:
		if t.Size == 8 || t.Size == 16 || t.Size == 32 || t.Size == 64 {
			// Native Go types
			if t.Size == 8 {
				// uint8/int8 - read single byte
				if t.T == abi.IntTy {
					g.L(`%s = %s(data%d[%d+31])`, ref, typeName, depth, offset)
				} else {
					g.L(`%s = %s(data%d[%d+31])`, ref, typeName, depth, offset)
				}
			} else {
				// uint16/32/64 - use binary.BigEndian
				if t.T == abi.IntTy {
					g.L(`%s = %s(binary.BigEndian.Uint%d(data%d[%d+%d:%d+%d]))`, ref, typeName, t.Size, depth, offset, 32-t.Size/8, offset, 32)
				} else {
					g.L(`%s = %s(binary.BigEndian.Uint%d(data%d[%d+%d:%d+%d]))`, ref, typeName, t.Size, depth, offset, 32-t.Size/8, offset, 32)
				}
			}
		} else {
			// big.Int types
			g.L(`%s = new(big.Int).SetBytes(data%d[%d:%d])`, ref, depth, offset, offset+32)
		}

	case abi.BoolTy:
		g.L(`%s = data%d[%d+31] == 1`, ref, depth, offset)

	case abi.FixedBytesTy:
		g.L(`copy(%s[:], data%d[%d:%d+%d])`, ref, depth, offset, offset, t.Size)

	case abi.ArrayTy:
		// Fixed-size array with static elements
		g.T(`// Decode fixed-size array {{.ref}}
	for i{{.depth}} := 0; i{{.depth}} < {{.length}}; i{{.depth}}++ {
		offset := {{.offset}} + i{{.depth}} * {{.size}}
		data{{.depth_plus}} := data{{.depth}}
`, M{"depth": depth, "depth_plus": depth + 1, "ref": ref, "length": t.Size, "offset": offset, "size": GetTypeSize(*t.Elem)})

		g.genStaticDecodeOffset(fmt.Sprintf("%s[i%d]", ref, depth), *t.Elem, depth+1)

		g.L(`}`)

	case abi.TupleTy:
		// Nested static tuple
		g.L(`if err := %s.DecodeFrom(data%d[%d:%d]); err != nil {
		return err
	}`, ref, depth, offset, offset+GetTypeSize(t))

	default:
		panic("unknown static type")
	}
}

// genDynamicDecode generates decoding logic for dynamic types
func (g *Generator) genDynamicDecode(ref string, t abi.Type, depth int) {
	g.L(`// %s (dynamic)`, ref)

	if RequiresLengthPrefix(t) {
		g.L(`if offset+32 > len(data%d) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data%d[offset+24:offset+32]))
		offset += 32`, depth, depth)
	} else {
		g.L(`if offset >= len(data%d) {
			return fmt.Errorf("insufficient data for dynamic data, %s")
		}`, depth, ref)
	}

	switch t.T {
	case abi.StringTy:
		g.L(`// string data
		%s = string(data%d[offset:offset+length])`, ref, depth)

	case abi.BytesTy:
		g.L(`// bytes data
		%s = data%d[offset:offset+length]`, ref, depth)

	case abi.TupleTy:
		// Dynamic tuple
		g.L(`if err := %s.DecodeFrom(data%d[offset:]); err != nil {
			return err
		}`, ref, depth)

	case abi.SliceTy:
		// Dynamic slice
		typeName := abiTypeToGoType(*t.Elem)

		g.L(`// slice data
		%s = make([]%s, length)
		data%d := data%d[offset:]
		`, ref, typeName, depth+1, depth)

		newRef := fmt.Sprintf("%s[i%d]", ref, depth)
		if !IsDynamicType(*t.Elem) {
			// Static elements - direct decoding
			g.L(`offset = 0
			for i%d := 0; i%[1]d < length; i%[1]d++ {`, depth)

			g.genStaticDecodeOffset(newRef, *t.Elem, depth+1)

			g.L(`offset += %d }`, GetTypeSize(*t.Elem))
		} else {
			// Dynamic elements - each element has an offset
			g.T(`// Dynamic elements with offsets (dynamic array)
			for i{{.depth}} := 0; i{{.depth}} < length; i{{.depth}}++ {
				// Read element offset
				tmp := i{{.depth}} * 32
				if tmp + 32 > len(data{{.depth_plus}}) {
					return fmt.Errorf("insufficient data for element offset")
				}
				offset := int(binary.BigEndian.Uint64(data{{.depth_plus}}[tmp+24: tmp+32]))
				// Decode dynamic element at offset
			`, M{"depth": depth, "depth_plus": depth + 1})

			// Generate decoding for dynamic element directly - inline the logic
			g.genDynamicDecode(newRef, *t.Elem, depth+1)

			g.L("}")
		}

	case abi.ArrayTy:
		// Fixed-size array with dynamic elements
		g.L(`// Fixed-size array %s
		`, ref)

		// Dynamic elements - each element has an offset
		g.T(`// Dynamic elements with offsets
		for i{{.depth}} := 0; i{{.depth}} < {{.size}}; i{{.depth}}++ {
			// Read element offset
			tmp := i{{.depth}} * 32
			offset := int(binary.BigEndian.Uint64(data{{.depth}}[tmp+24:tmp+32]))
			if offset >= len(data{{.depth}}) {
				return fmt.Errorf("invalid element offset")
			}
			// Decode dynamic element at offset
			{
				data{{.depth_plus}} := data{{.depth}}[offset:]
			`, M{"depth": depth, "depth_plus": depth + 1, "size": t.Size})

		g.genDynamicDecode(fmt.Sprintf("%s[i%d]", ref, depth), *t.Elem, depth+1)

		g.L(`}
		}`)

	default:
		panic("unknown dynamic type")
	}
}
