// Code generated by go-abi. DO NOT EDIT.

package abi

import (
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"math/big"

	"github.com/ethereum/go-ethereum/common"
)

// Function selectors
var (
	// stdlib(bool,uint8,uint16,uint32,uint64,uint256,int8,int16,int32,int64,int256,address,bytes32,string,bytes,bool[],uint8[],uint16[],uint32[],uint64[],uint256[],int8[],int16[],int32[],int64[],int256[],address[],bytes32[],string[],bytes[])
	StdlibSelector = [4]byte{0x59, 0x46, 0x2e, 0x8e}
)

// Big endian integer versions of function selectors
const (
	StdlibID = 1497771662
)

// EncodeAddress encodes address to ABI bytes
func EncodeAddress(value common.Address, buf []byte) (int, error) {
	copy(buf[12:32], value[:])
	return 32, nil
}

// EncodeAddressSlice encodes address[] to ABI bytes
func EncodeAddressSlice(value []common.Address, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeAddress(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeBool encodes bool to ABI bytes
func EncodeBool(value bool, buf []byte) (int, error) {
	if value {
		buf[31] = 1
	}
	return 32, nil
}

// EncodeBoolSlice encodes bool[] to ABI bytes
func EncodeBoolSlice(value []bool, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeBool(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeBytes encodes bytes to ABI bytes
func EncodeBytes(value []byte, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))

	// Encode data
	copy(buf[32:], value)

	return 32 + Pad32(len(value)), nil
}

// EncodeBytes32 encodes bytes32 to ABI bytes
func EncodeBytes32(value [32]byte, buf []byte) (int, error) {
	copy(buf[:32], value[:])
	return 32, nil
}

// EncodeBytes32Slice encodes bytes32[] to ABI bytes
func EncodeBytes32Slice(value [][32]byte, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeBytes32(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeBytesSlice encodes bytes[] to ABI bytes
func EncodeBytesSlice(value [][]byte, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with dynamic types
	var offset int
	dynamicOffset := len(value) * 32
	for _, elem := range value {
		// Write offset for element
		offset += 32
		binary.BigEndian.PutUint64(buf[offset-8:offset], uint64(dynamicOffset))

		// Write element at dynamic region
		n, err := EncodeBytes(elem, buf[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}

	return dynamicOffset + 32, nil
}

// EncodeInt16 encodes int16 to ABI bytes
func EncodeInt16(value int16, buf []byte) (int, error) {
	if value < 0 {
		for i := 0; i < 30; i++ {
			buf[i] = 0xff
		}
	}
	binary.BigEndian.PutUint16(buf[30:32], uint16(value))
	return 32, nil
}

// EncodeInt16Slice encodes int16[] to ABI bytes
func EncodeInt16Slice(value []int16, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeInt16(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeInt256 encodes int256 to ABI bytes
func EncodeInt256(value *big.Int, buf []byte) (int, error) {
	if err := EncodeBigInt(value, buf[:32], true); err != nil {
		return 0, err
	}
	return 32, nil
}

// EncodeInt256Slice encodes int256[] to ABI bytes
func EncodeInt256Slice(value []*big.Int, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeInt256(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeInt32 encodes int32 to ABI bytes
func EncodeInt32(value int32, buf []byte) (int, error) {
	if value < 0 {
		for i := 0; i < 28; i++ {
			buf[i] = 0xff
		}
	}
	binary.BigEndian.PutUint32(buf[28:32], uint32(value))
	return 32, nil
}

// EncodeInt32Slice encodes int32[] to ABI bytes
func EncodeInt32Slice(value []int32, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeInt32(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeInt64 encodes int64 to ABI bytes
func EncodeInt64(value int64, buf []byte) (int, error) {
	if value < 0 {
		for i := 0; i < 24; i++ {
			buf[i] = 0xff
		}
	}
	binary.BigEndian.PutUint64(buf[24:32], uint64(value))
	return 32, nil
}

// EncodeInt64Slice encodes int64[] to ABI bytes
func EncodeInt64Slice(value []int64, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeInt64(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeInt8 encodes int8 to ABI bytes
func EncodeInt8(value int8, buf []byte) (int, error) {
	if value < 0 {
		for i := 0; i < 31; i++ {
			buf[i] = 0xff
		}
	}
	buf[31] = byte(value)
	return 32, nil
}

// EncodeInt8Slice encodes int8[] to ABI bytes
func EncodeInt8Slice(value []int8, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeInt8(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeString encodes string to ABI bytes
func EncodeString(value string, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))

	// Encode data
	copy(buf[32:], []byte(value))

	return 32 + Pad32(len(value)), nil
}

// EncodeStringSlice encodes string[] to ABI bytes
func EncodeStringSlice(value []string, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with dynamic types
	var offset int
	dynamicOffset := len(value) * 32
	for _, elem := range value {
		// Write offset for element
		offset += 32
		binary.BigEndian.PutUint64(buf[offset-8:offset], uint64(dynamicOffset))

		// Write element at dynamic region
		n, err := EncodeString(elem, buf[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}

	return dynamicOffset + 32, nil
}

// EncodeUint16 encodes uint16 to ABI bytes
func EncodeUint16(value uint16, buf []byte) (int, error) {
	binary.BigEndian.PutUint16(buf[30:32], uint16(value))
	return 32, nil
}

// EncodeUint16Slice encodes uint16[] to ABI bytes
func EncodeUint16Slice(value []uint16, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeUint16(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeUint256 encodes uint256 to ABI bytes
func EncodeUint256(value *big.Int, buf []byte) (int, error) {
	if err := EncodeBigInt(value, buf[:32], false); err != nil {
		return 0, err
	}
	return 32, nil
}

// EncodeUint256Slice encodes uint256[] to ABI bytes
func EncodeUint256Slice(value []*big.Int, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeUint256(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeUint32 encodes uint32 to ABI bytes
func EncodeUint32(value uint32, buf []byte) (int, error) {
	binary.BigEndian.PutUint32(buf[28:32], uint32(value))
	return 32, nil
}

// EncodeUint32Slice encodes uint32[] to ABI bytes
func EncodeUint32Slice(value []uint32, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeUint32(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeUint64 encodes uint64 to ABI bytes
func EncodeUint64(value uint64, buf []byte) (int, error) {
	binary.BigEndian.PutUint64(buf[24:32], uint64(value))
	return 32, nil
}

// EncodeUint64Slice encodes uint64[] to ABI bytes
func EncodeUint64Slice(value []uint64, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeUint64(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeUint8 encodes uint8 to ABI bytes
func EncodeUint8(value uint8, buf []byte) (int, error) {
	buf[31] = byte(value)
	return 32, nil
}

// EncodeUint8Slice encodes uint8[] to ABI bytes
func EncodeUint8Slice(value []uint8, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeUint8(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// SizeAddressSlice returns the encoded size of address[]
func SizeAddressSlice(value []common.Address) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeBoolSlice returns the encoded size of bool[]
func SizeBoolSlice(value []bool) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeBytes returns the encoded size of bytes
func SizeBytes(value []byte) int {
	size := 32 + Pad32(len(value)) // length + padded bytes data
	return size
}

// SizeBytes32Slice returns the encoded size of bytes32[]
func SizeBytes32Slice(value [][32]byte) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeBytesSlice returns the encoded size of bytes[]
func SizeBytesSlice(value [][]byte) int {
	size := 32 + 32*len(value) // length + offset pointers for dynamic elements
	for _, elem := range value {
		size += SizeBytes(elem)
	}
	return size
}

// SizeInt16Slice returns the encoded size of int16[]
func SizeInt16Slice(value []int16) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeInt256Slice returns the encoded size of int256[]
func SizeInt256Slice(value []*big.Int) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeInt32Slice returns the encoded size of int32[]
func SizeInt32Slice(value []int32) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeInt64Slice returns the encoded size of int64[]
func SizeInt64Slice(value []int64) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeInt8Slice returns the encoded size of int8[]
func SizeInt8Slice(value []int8) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeString returns the encoded size of string
func SizeString(value string) int {
	size := 32 + Pad32(len(value)) // length + padded string data
	return size
}

// SizeStringSlice returns the encoded size of string[]
func SizeStringSlice(value []string) int {
	size := 32 + 32*len(value) // length + offset pointers for dynamic elements
	for _, elem := range value {
		size += SizeString(elem)
	}
	return size
}

// SizeUint16Slice returns the encoded size of uint16[]
func SizeUint16Slice(value []uint16) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeUint256Slice returns the encoded size of uint256[]
func SizeUint256Slice(value []*big.Int) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeUint32Slice returns the encoded size of uint32[]
func SizeUint32Slice(value []uint32) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeUint64Slice returns the encoded size of uint64[]
func SizeUint64Slice(value []uint64) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeUint8Slice returns the encoded size of uint8[]
func SizeUint8Slice(value []uint8) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// DecodeAddress decodes address from ABI bytes
func DecodeAddress(data []byte) (common.Address, int, error) {
	var result common.Address
	copy(result[:], data[12:32])
	return result, 32, nil
}

// DecodeAddressSlice decodes address[] from ABI bytes
func DecodeAddressSlice(data []byte) ([]common.Address, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 32*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with static types
	result := make([]common.Address, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeAddress(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeBool decodes bool from ABI bytes
func DecodeBool(data []byte) (bool, int, error) {
	result := data[31] != 0
	return result, 32, nil
}

// DecodeBoolSlice decodes bool[] from ABI bytes
func DecodeBoolSlice(data []byte) ([]bool, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 32*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with static types
	result := make([]bool, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeBool(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeBytes decodes bytes from ABI bytes
func DecodeBytes(data []byte) ([]byte, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32+Pad32(length) {
		return nil, 0, io.ErrUnexpectedEOF
	}

	// Decode data
	result := make([]byte, length)
	copy(result, data[32:32+length])
	return result, 32 + Pad32(length), nil
}

// DecodeBytes32 decodes bytes32 from ABI bytes
func DecodeBytes32(data []byte) ([32]byte, int, error) {
	var result [32]byte
	copy(result[:], data[:32])
	return result, 32, nil
}

// DecodeBytes32Slice decodes bytes32[] from ABI bytes
func DecodeBytes32Slice(data []byte) ([][32]byte, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 32*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with static types
	result := make([][32]byte, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeBytes32(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeBytesSlice decodes bytes[] from ABI bytes
func DecodeBytesSlice(data []byte) ([][]byte, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 32*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with dynamic types
	result := make([][]byte, length)
	dynamicOffset := length * 32
	for i := 0; i < length; i++ {
		offset += 32
		tmp := int(binary.BigEndian.Uint64(data[offset-8 : offset]))
		if dynamicOffset != tmp {
			return nil, 0, fmt.Errorf("invalid offset for slice element %d: expected %d, got %d", i, dynamicOffset, tmp)
		}
		result[i], n, err = DecodeBytes(data[dynamicOffset:])
		if err != nil {
			return nil, 0, err
		}
		dynamicOffset += n
	}
	return result, dynamicOffset + 32, nil
}

// DecodeInt16 decodes int16 from ABI bytes
func DecodeInt16(data []byte) (int16, int, error) {
	var result int16
	result = int16(binary.BigEndian.Uint16(data[30:32]))
	if data[0]&0x80 != 0 { // Check sign bit
		result = result | ^0x7fff // Sign extend
	}
	return result, 32, nil
}

// DecodeInt16Slice decodes int16[] from ABI bytes
func DecodeInt16Slice(data []byte) ([]int16, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 32*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with static types
	result := make([]int16, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeInt16(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeInt256 decodes int256 from ABI bytes
func DecodeInt256(data []byte) (*big.Int, int, error) {
	result, err := DecodeBigInt(data[:32], true)
	if err != nil {
		return nil, 0, err
	}
	return result, 32, nil
}

// DecodeInt256Slice decodes int256[] from ABI bytes
func DecodeInt256Slice(data []byte) ([]*big.Int, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 32*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with static types
	result := make([]*big.Int, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeInt256(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeInt32 decodes int32 from ABI bytes
func DecodeInt32(data []byte) (int32, int, error) {
	var result int32
	result = int32(binary.BigEndian.Uint32(data[28:32]))
	if data[0]&0x80 != 0 { // Check sign bit
		result = result | ^0x7fffffff // Sign extend
	}
	return result, 32, nil
}

// DecodeInt32Slice decodes int32[] from ABI bytes
func DecodeInt32Slice(data []byte) ([]int32, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 32*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with static types
	result := make([]int32, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeInt32(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeInt64 decodes int64 from ABI bytes
func DecodeInt64(data []byte) (int64, int, error) {
	var result int64
	result = int64(binary.BigEndian.Uint64(data[24:32]))
	if data[0]&0x80 != 0 { // Check sign bit
		result = result | ^0x7fffffffffffffff // Sign extend
	}
	return result, 32, nil
}

// DecodeInt64Slice decodes int64[] from ABI bytes
func DecodeInt64Slice(data []byte) ([]int64, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 32*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with static types
	result := make([]int64, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeInt64(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeInt8 decodes int8 from ABI bytes
func DecodeInt8(data []byte) (int8, int, error) {
	var result int8
	result = int8(data[31])
	if data[0]&0x80 != 0 { // Check sign bit
		result = result | ^0x7f // Sign extend
	}
	return result, 32, nil
}

// DecodeInt8Slice decodes int8[] from ABI bytes
func DecodeInt8Slice(data []byte) ([]int8, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 32*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with static types
	result := make([]int8, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeInt8(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeString decodes string from ABI bytes
func DecodeString(data []byte) (string, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32+Pad32(length) {
		return "", 0, io.ErrUnexpectedEOF
	}

	// Decode data
	result := string(data[32 : 32+length])
	return result, 32 + Pad32(length), nil
}

// DecodeStringSlice decodes string[] from ABI bytes
func DecodeStringSlice(data []byte) ([]string, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 32*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with dynamic types
	result := make([]string, length)
	dynamicOffset := length * 32
	for i := 0; i < length; i++ {
		offset += 32
		tmp := int(binary.BigEndian.Uint64(data[offset-8 : offset]))
		if dynamicOffset != tmp {
			return nil, 0, fmt.Errorf("invalid offset for slice element %d: expected %d, got %d", i, dynamicOffset, tmp)
		}
		result[i], n, err = DecodeString(data[dynamicOffset:])
		if err != nil {
			return nil, 0, err
		}
		dynamicOffset += n
	}
	return result, dynamicOffset + 32, nil
}

// DecodeUint16 decodes uint16 from ABI bytes
func DecodeUint16(data []byte) (uint16, int, error) {
	result := binary.BigEndian.Uint16(data[30:32])
	return result, 32, nil
}

// DecodeUint16Slice decodes uint16[] from ABI bytes
func DecodeUint16Slice(data []byte) ([]uint16, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 32*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with static types
	result := make([]uint16, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeUint16(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeUint256 decodes uint256 from ABI bytes
func DecodeUint256(data []byte) (*big.Int, int, error) {
	result, err := DecodeBigInt(data[:32], false)
	if err != nil {
		return nil, 0, err
	}
	return result, 32, nil
}

// DecodeUint256Slice decodes uint256[] from ABI bytes
func DecodeUint256Slice(data []byte) ([]*big.Int, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 32*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with static types
	result := make([]*big.Int, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeUint256(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeUint32 decodes uint32 from ABI bytes
func DecodeUint32(data []byte) (uint32, int, error) {
	result := binary.BigEndian.Uint32(data[28:32])
	return result, 32, nil
}

// DecodeUint32Slice decodes uint32[] from ABI bytes
func DecodeUint32Slice(data []byte) ([]uint32, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 32*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with static types
	result := make([]uint32, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeUint32(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeUint64 decodes uint64 from ABI bytes
func DecodeUint64(data []byte) (uint64, int, error) {
	result := binary.BigEndian.Uint64(data[24:32])
	return result, 32, nil
}

// DecodeUint64Slice decodes uint64[] from ABI bytes
func DecodeUint64Slice(data []byte) ([]uint64, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 32*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with static types
	result := make([]uint64, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeUint64(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeUint8 decodes uint8 from ABI bytes
func DecodeUint8(data []byte) (uint8, int, error) {
	result := uint8(data[31])
	return result, 32, nil
}

// DecodeUint8Slice decodes uint8[] from ABI bytes
func DecodeUint8Slice(data []byte) ([]uint8, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 32*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with static types
	result := make([]uint8, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeUint8(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

const StdlibCallStaticSize = 960

// StdlibCall represents an ABI tuple
type StdlibCall struct {
	Field1  bool
	Field2  uint8
	Field3  uint16
	Field4  uint32
	Field5  uint64
	Field6  *big.Int
	Field7  int8
	Field8  int16
	Field9  int32
	Field10 int64
	Field11 *big.Int
	Field12 common.Address
	Field13 [32]byte
	Field14 string
	Field15 []byte
	Field16 []bool
	Field17 []uint8
	Field18 []uint16
	Field19 []uint32
	Field20 []uint64
	Field21 []*big.Int
	Field22 []int8
	Field23 []int16
	Field24 []int32
	Field25 []int64
	Field26 []*big.Int
	Field27 []common.Address
	Field28 [][32]byte
	Field29 []string
	Field30 [][]byte
}

// EncodedSize returns the total encoded size of StdlibCall
func (t StdlibCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += SizeString(t.Field14)
	dynamicSize += SizeBytes(t.Field15)
	dynamicSize += SizeBoolSlice(t.Field16)
	dynamicSize += SizeUint8Slice(t.Field17)
	dynamicSize += SizeUint16Slice(t.Field18)
	dynamicSize += SizeUint32Slice(t.Field19)
	dynamicSize += SizeUint64Slice(t.Field20)
	dynamicSize += SizeUint256Slice(t.Field21)
	dynamicSize += SizeInt8Slice(t.Field22)
	dynamicSize += SizeInt16Slice(t.Field23)
	dynamicSize += SizeInt32Slice(t.Field24)
	dynamicSize += SizeInt64Slice(t.Field25)
	dynamicSize += SizeInt256Slice(t.Field26)
	dynamicSize += SizeAddressSlice(t.Field27)
	dynamicSize += SizeBytes32Slice(t.Field28)
	dynamicSize += SizeStringSlice(t.Field29)
	dynamicSize += SizeBytesSlice(t.Field30)

	return StdlibCallStaticSize + dynamicSize
}

// EncodeTo encodes StdlibCall to ABI bytes in the provided buffer
func (value StdlibCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := StdlibCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Field1: bool
	if _, err := EncodeBool(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	// Field Field2: uint8
	if _, err := EncodeUint8(value.Field2, buf[32:]); err != nil {
		return 0, err
	}

	// Field Field3: uint16
	if _, err := EncodeUint16(value.Field3, buf[64:]); err != nil {
		return 0, err
	}

	// Field Field4: uint32
	if _, err := EncodeUint32(value.Field4, buf[96:]); err != nil {
		return 0, err
	}

	// Field Field5: uint64
	if _, err := EncodeUint64(value.Field5, buf[128:]); err != nil {
		return 0, err
	}

	// Field Field6: uint256
	if _, err := EncodeUint256(value.Field6, buf[160:]); err != nil {
		return 0, err
	}

	// Field Field7: int8
	if _, err := EncodeInt8(value.Field7, buf[192:]); err != nil {
		return 0, err
	}

	// Field Field8: int16
	if _, err := EncodeInt16(value.Field8, buf[224:]); err != nil {
		return 0, err
	}

	// Field Field9: int32
	if _, err := EncodeInt32(value.Field9, buf[256:]); err != nil {
		return 0, err
	}

	// Field Field10: int64
	if _, err := EncodeInt64(value.Field10, buf[288:]); err != nil {
		return 0, err
	}

	// Field Field11: int256
	if _, err := EncodeInt256(value.Field11, buf[320:]); err != nil {
		return 0, err
	}

	// Field Field12: address
	if _, err := EncodeAddress(value.Field12, buf[352:]); err != nil {
		return 0, err
	}

	// Field Field13: bytes32
	if _, err := EncodeBytes32(value.Field13, buf[384:]); err != nil {
		return 0, err
	}

	// Field Field14: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[416+24:416+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeString(value.Field14, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field15: bytes
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[448+24:448+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeBytes(value.Field15, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field16: bool[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[480+24:480+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeBoolSlice(value.Field16, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field17: uint8[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[512+24:512+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeUint8Slice(value.Field17, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field18: uint16[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[544+24:544+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeUint16Slice(value.Field18, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field19: uint32[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[576+24:576+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeUint32Slice(value.Field19, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field20: uint64[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[608+24:608+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeUint64Slice(value.Field20, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field21: uint256[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[640+24:640+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeUint256Slice(value.Field21, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field22: int8[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[672+24:672+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeInt8Slice(value.Field22, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field23: int16[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[704+24:704+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeInt16Slice(value.Field23, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field24: int32[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[736+24:736+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeInt32Slice(value.Field24, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field25: int64[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[768+24:768+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeInt64Slice(value.Field25, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field26: int256[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[800+24:800+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeInt256Slice(value.Field26, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field27: address[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[832+24:832+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeAddressSlice(value.Field27, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field28: bytes32[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[864+24:864+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeBytes32Slice(value.Field28, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field29: string[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[896+24:896+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeStringSlice(value.Field29, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field30: bytes[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[928+24:928+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeBytesSlice(value.Field30, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes StdlibCall to ABI bytes
func (value StdlibCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes StdlibCall from ABI bytes in the provided buffer
func (t *StdlibCall) Decode(data []byte) (int, error) {
	if len(data) < 960 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 960
	// Decode static field Field1: bool
	t.Field1, _, err = DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field2: uint8
	t.Field2, _, err = DecodeUint8(data[32:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field3: uint16
	t.Field3, _, err = DecodeUint16(data[64:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field4: uint32
	t.Field4, _, err = DecodeUint32(data[96:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field5: uint64
	t.Field5, _, err = DecodeUint64(data[128:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field6: uint256
	t.Field6, _, err = DecodeUint256(data[160:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field7: int8
	t.Field7, _, err = DecodeInt8(data[192:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field8: int16
	t.Field8, _, err = DecodeInt16(data[224:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field9: int32
	t.Field9, _, err = DecodeInt32(data[256:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field10: int64
	t.Field10, _, err = DecodeInt64(data[288:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field11: int256
	t.Field11, _, err = DecodeInt256(data[320:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field12: address
	t.Field12, _, err = DecodeAddress(data[352:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field13: bytes32
	t.Field13, _, err = DecodeBytes32(data[384:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Field14
	{
		offset := int(binary.BigEndian.Uint64(data[416+24 : 416+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Field14")
		}
		t.Field14, n, err = DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field15
	{
		offset := int(binary.BigEndian.Uint64(data[448+24 : 448+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Field15")
		}
		t.Field15, n, err = DecodeBytes(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field16
	{
		offset := int(binary.BigEndian.Uint64(data[480+24 : 480+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Field16")
		}
		t.Field16, n, err = DecodeBoolSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field17
	{
		offset := int(binary.BigEndian.Uint64(data[512+24 : 512+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Field17")
		}
		t.Field17, n, err = DecodeUint8Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field18
	{
		offset := int(binary.BigEndian.Uint64(data[544+24 : 544+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Field18")
		}
		t.Field18, n, err = DecodeUint16Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field19
	{
		offset := int(binary.BigEndian.Uint64(data[576+24 : 576+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Field19")
		}
		t.Field19, n, err = DecodeUint32Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field20
	{
		offset := int(binary.BigEndian.Uint64(data[608+24 : 608+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Field20")
		}
		t.Field20, n, err = DecodeUint64Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field21
	{
		offset := int(binary.BigEndian.Uint64(data[640+24 : 640+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Field21")
		}
		t.Field21, n, err = DecodeUint256Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field22
	{
		offset := int(binary.BigEndian.Uint64(data[672+24 : 672+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Field22")
		}
		t.Field22, n, err = DecodeInt8Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field23
	{
		offset := int(binary.BigEndian.Uint64(data[704+24 : 704+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Field23")
		}
		t.Field23, n, err = DecodeInt16Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field24
	{
		offset := int(binary.BigEndian.Uint64(data[736+24 : 736+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Field24")
		}
		t.Field24, n, err = DecodeInt32Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field25
	{
		offset := int(binary.BigEndian.Uint64(data[768+24 : 768+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Field25")
		}
		t.Field25, n, err = DecodeInt64Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field26
	{
		offset := int(binary.BigEndian.Uint64(data[800+24 : 800+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Field26")
		}
		t.Field26, n, err = DecodeInt256Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field27
	{
		offset := int(binary.BigEndian.Uint64(data[832+24 : 832+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Field27")
		}
		t.Field27, n, err = DecodeAddressSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field28
	{
		offset := int(binary.BigEndian.Uint64(data[864+24 : 864+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Field28")
		}
		t.Field28, n, err = DecodeBytes32Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field29
	{
		offset := int(binary.BigEndian.Uint64(data[896+24 : 896+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Field29")
		}
		t.Field29, n, err = DecodeStringSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field30
	{
		offset := int(binary.BigEndian.Uint64(data[928+24 : 928+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Field30")
		}
		t.Field30, n, err = DecodeBytesSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// EncodeWithSelector encodes stdlib arguments to ABI bytes including function selector
func (t StdlibCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], StdlibSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// StdlibReturn represents the input arguments for stdlib function
type StdlibReturn struct {
	EmptyTuple
}
