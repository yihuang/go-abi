// Code generated by go-abi. DO NOT EDIT.

package abi

import (
	"encoding/binary"
	"io"
	"math/big"

	"github.com/ethereum/go-ethereum/common"
)

// Function selectors
var (
	// stdlib(bool,address,bytes32,string,bytes,uint8,int8,uint16,int16,uint24,int24,uint32,int32,uint40,int40,uint48,int48,uint56,int56,uint64,int64,uint72,int72,uint80,int80,uint88,int88,uint96,int96,uint104,int104,uint112,int112,uint120,int120,uint128,int128,bool[],address[],bytes32[],string[],bytes[],uint8[],int8[],uint16[],int16[],uint24[],int24[],uint32[],int32[],uint40[],int40[],uint48[],int48[],uint56[],int56[],uint64[],int64[],uint72[],int72[],uint80[],int80[],uint88[],int88[],uint96[],int96[],uint104[],int104[],uint112[],int112[],uint120[],int120[],uint128[],int128[])
	StdlibSelector = [4]byte{0x30, 0x78, 0xd0, 0x78}
)

// Big endian integer versions of function selectors
const (
	StdlibID = 813224056
)

// EncodeAddress encodes address to ABI bytes
func EncodeAddress(value common.Address, buf []byte) (int, error) {
	copy(buf[12:32], value[:])
	return 32, nil
}

// EncodeAddressSlice encodes address[] to ABI bytes
func EncodeAddressSlice(value []common.Address, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeAddress(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeBool encodes bool to ABI bytes
func EncodeBool(value bool, buf []byte) (int, error) {
	if value {
		buf[31] = 1
	}
	return 32, nil
}

// EncodeBoolSlice encodes bool[] to ABI bytes
func EncodeBoolSlice(value []bool, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeBool(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeBytes encodes bytes to ABI bytes
func EncodeBytes(value []byte, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))

	// Encode data
	copy(buf[32:], value)

	return 32 + Pad32(len(value)), nil
}

// EncodeBytes32 encodes bytes32 to ABI bytes
func EncodeBytes32(value [32]byte, buf []byte) (int, error) {
	copy(buf[:32], value[:])
	return 32, nil
}

// EncodeBytes32Slice encodes bytes32[] to ABI bytes
func EncodeBytes32Slice(value [][32]byte, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeBytes32(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeBytesSlice encodes bytes[] to ABI bytes
func EncodeBytesSlice(value [][]byte, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with dynamic types
	var offset int
	dynamicOffset := len(value) * 32
	for _, elem := range value {
		// Write offset for element
		offset += 32
		binary.BigEndian.PutUint64(buf[offset-8:offset], uint64(dynamicOffset))

		// Write element at dynamic region
		n, err := EncodeBytes(elem, buf[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}

	return dynamicOffset + 32, nil
}

// EncodeInt16 encodes int16 to ABI bytes
func EncodeInt16(value int16, buf []byte) (int, error) {
	if value < 0 {
		for i := 0; i < 30; i++ {
			buf[i] = 0xff
		}
	}
	binary.BigEndian.PutUint16(buf[30:32], uint16(value))
	return 32, nil
}

// EncodeInt16Slice encodes int16[] to ABI bytes
func EncodeInt16Slice(value []int16, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeInt16(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeInt24 encodes int24 to ABI bytes
func EncodeInt24(value int32, buf []byte) (int, error) {
	if value < 0 {
		for i := 0; i < 28; i++ {
			buf[i] = 0xff
		}
	}
	binary.BigEndian.PutUint32(buf[28:32], uint32(value))
	return 32, nil
}

// EncodeInt24Slice encodes int24[] to ABI bytes
func EncodeInt24Slice(value []int32, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeInt24(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeInt256 encodes int72 to ABI bytes
func EncodeInt256(value *big.Int, buf []byte) (int, error) {
	if err := EncodeBigInt(value, buf[:32], true); err != nil {
		return 0, err
	}
	return 32, nil
}

// EncodeInt256Slice encodes int72[] to ABI bytes
func EncodeInt256Slice(value []*big.Int, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeInt256(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeInt32 encodes int32 to ABI bytes
func EncodeInt32(value int32, buf []byte) (int, error) {
	if value < 0 {
		for i := 0; i < 28; i++ {
			buf[i] = 0xff
		}
	}
	binary.BigEndian.PutUint32(buf[28:32], uint32(value))
	return 32, nil
}

// EncodeInt32Slice encodes int32[] to ABI bytes
func EncodeInt32Slice(value []int32, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeInt32(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeInt40 encodes int40 to ABI bytes
func EncodeInt40(value int64, buf []byte) (int, error) {
	if value < 0 {
		for i := 0; i < 24; i++ {
			buf[i] = 0xff
		}
	}
	binary.BigEndian.PutUint64(buf[24:32], uint64(value))
	return 32, nil
}

// EncodeInt40Slice encodes int40[] to ABI bytes
func EncodeInt40Slice(value []int64, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeInt40(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeInt48 encodes int48 to ABI bytes
func EncodeInt48(value int64, buf []byte) (int, error) {
	if value < 0 {
		for i := 0; i < 24; i++ {
			buf[i] = 0xff
		}
	}
	binary.BigEndian.PutUint64(buf[24:32], uint64(value))
	return 32, nil
}

// EncodeInt48Slice encodes int48[] to ABI bytes
func EncodeInt48Slice(value []int64, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeInt48(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeInt56 encodes int56 to ABI bytes
func EncodeInt56(value int64, buf []byte) (int, error) {
	if value < 0 {
		for i := 0; i < 24; i++ {
			buf[i] = 0xff
		}
	}
	binary.BigEndian.PutUint64(buf[24:32], uint64(value))
	return 32, nil
}

// EncodeInt56Slice encodes int56[] to ABI bytes
func EncodeInt56Slice(value []int64, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeInt56(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeInt64 encodes int64 to ABI bytes
func EncodeInt64(value int64, buf []byte) (int, error) {
	if value < 0 {
		for i := 0; i < 24; i++ {
			buf[i] = 0xff
		}
	}
	binary.BigEndian.PutUint64(buf[24:32], uint64(value))
	return 32, nil
}

// EncodeInt64Slice encodes int64[] to ABI bytes
func EncodeInt64Slice(value []int64, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeInt64(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeInt8 encodes int8 to ABI bytes
func EncodeInt8(value int8, buf []byte) (int, error) {
	if value < 0 {
		for i := 0; i < 31; i++ {
			buf[i] = 0xff
		}
	}
	buf[31] = byte(value)
	return 32, nil
}

// EncodeInt8Slice encodes int8[] to ABI bytes
func EncodeInt8Slice(value []int8, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeInt8(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeString encodes string to ABI bytes
func EncodeString(value string, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))

	// Encode data
	copy(buf[32:], []byte(value))

	return 32 + Pad32(len(value)), nil
}

// EncodeStringSlice encodes string[] to ABI bytes
func EncodeStringSlice(value []string, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with dynamic types
	var offset int
	dynamicOffset := len(value) * 32
	for _, elem := range value {
		// Write offset for element
		offset += 32
		binary.BigEndian.PutUint64(buf[offset-8:offset], uint64(dynamicOffset))

		// Write element at dynamic region
		n, err := EncodeString(elem, buf[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}

	return dynamicOffset + 32, nil
}

// EncodeUint16 encodes uint16 to ABI bytes
func EncodeUint16(value uint16, buf []byte) (int, error) {
	binary.BigEndian.PutUint16(buf[30:32], uint16(value))
	return 32, nil
}

// EncodeUint16Slice encodes uint16[] to ABI bytes
func EncodeUint16Slice(value []uint16, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeUint16(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeUint24 encodes uint24 to ABI bytes
func EncodeUint24(value uint32, buf []byte) (int, error) {
	binary.BigEndian.PutUint32(buf[28:32], uint32(value))
	return 32, nil
}

// EncodeUint24Slice encodes uint24[] to ABI bytes
func EncodeUint24Slice(value []uint32, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeUint24(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeUint256 encodes uint72 to ABI bytes
func EncodeUint256(value *big.Int, buf []byte) (int, error) {
	if err := EncodeBigInt(value, buf[:32], false); err != nil {
		return 0, err
	}
	return 32, nil
}

// EncodeUint256Slice encodes uint72[] to ABI bytes
func EncodeUint256Slice(value []*big.Int, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeUint256(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeUint32 encodes uint32 to ABI bytes
func EncodeUint32(value uint32, buf []byte) (int, error) {
	binary.BigEndian.PutUint32(buf[28:32], uint32(value))
	return 32, nil
}

// EncodeUint32Slice encodes uint32[] to ABI bytes
func EncodeUint32Slice(value []uint32, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeUint32(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeUint40 encodes uint40 to ABI bytes
func EncodeUint40(value uint64, buf []byte) (int, error) {
	binary.BigEndian.PutUint64(buf[24:32], uint64(value))
	return 32, nil
}

// EncodeUint40Slice encodes uint40[] to ABI bytes
func EncodeUint40Slice(value []uint64, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeUint40(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeUint48 encodes uint48 to ABI bytes
func EncodeUint48(value uint64, buf []byte) (int, error) {
	binary.BigEndian.PutUint64(buf[24:32], uint64(value))
	return 32, nil
}

// EncodeUint48Slice encodes uint48[] to ABI bytes
func EncodeUint48Slice(value []uint64, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeUint48(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeUint56 encodes uint56 to ABI bytes
func EncodeUint56(value uint64, buf []byte) (int, error) {
	binary.BigEndian.PutUint64(buf[24:32], uint64(value))
	return 32, nil
}

// EncodeUint56Slice encodes uint56[] to ABI bytes
func EncodeUint56Slice(value []uint64, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeUint56(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeUint64 encodes uint64 to ABI bytes
func EncodeUint64(value uint64, buf []byte) (int, error) {
	binary.BigEndian.PutUint64(buf[24:32], uint64(value))
	return 32, nil
}

// EncodeUint64Slice encodes uint64[] to ABI bytes
func EncodeUint64Slice(value []uint64, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeUint64(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// EncodeUint8 encodes uint8 to ABI bytes
func EncodeUint8(value uint8, buf []byte) (int, error) {
	buf[31] = byte(value)
	return 32, nil
}

// EncodeUint8Slice encodes uint8[] to ABI bytes
func EncodeUint8Slice(value []uint8, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := EncodeUint8(elem, buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// SizeAddressSlice returns the encoded size of address[]
func SizeAddressSlice(value []common.Address) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeBoolSlice returns the encoded size of bool[]
func SizeBoolSlice(value []bool) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeBytes returns the encoded size of bytes
func SizeBytes(value []byte) int {
	size := 32 + Pad32(len(value)) // length + padded bytes data
	return size
}

// SizeBytes32Slice returns the encoded size of bytes32[]
func SizeBytes32Slice(value [][32]byte) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeBytesSlice returns the encoded size of bytes[]
func SizeBytesSlice(value [][]byte) int {
	size := 32 + 32*len(value) // length + offset pointers for dynamic elements
	for _, elem := range value {
		size += SizeBytes(elem)
	}
	return size
}

// SizeInt16Slice returns the encoded size of int16[]
func SizeInt16Slice(value []int16) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeInt24Slice returns the encoded size of int24[]
func SizeInt24Slice(value []int32) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeInt256Slice returns the encoded size of int72[]
func SizeInt256Slice(value []*big.Int) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeInt32Slice returns the encoded size of int32[]
func SizeInt32Slice(value []int32) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeInt40Slice returns the encoded size of int40[]
func SizeInt40Slice(value []int64) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeInt48Slice returns the encoded size of int48[]
func SizeInt48Slice(value []int64) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeInt56Slice returns the encoded size of int56[]
func SizeInt56Slice(value []int64) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeInt64Slice returns the encoded size of int64[]
func SizeInt64Slice(value []int64) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeInt8Slice returns the encoded size of int8[]
func SizeInt8Slice(value []int8) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeString returns the encoded size of string
func SizeString(value string) int {
	size := 32 + Pad32(len(value)) // length + padded string data
	return size
}

// SizeStringSlice returns the encoded size of string[]
func SizeStringSlice(value []string) int {
	size := 32 + 32*len(value) // length + offset pointers for dynamic elements
	for _, elem := range value {
		size += SizeString(elem)
	}
	return size
}

// SizeUint16Slice returns the encoded size of uint16[]
func SizeUint16Slice(value []uint16) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeUint24Slice returns the encoded size of uint24[]
func SizeUint24Slice(value []uint32) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeUint256Slice returns the encoded size of uint72[]
func SizeUint256Slice(value []*big.Int) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeUint32Slice returns the encoded size of uint32[]
func SizeUint32Slice(value []uint32) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeUint40Slice returns the encoded size of uint40[]
func SizeUint40Slice(value []uint64) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeUint48Slice returns the encoded size of uint48[]
func SizeUint48Slice(value []uint64) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeUint56Slice returns the encoded size of uint56[]
func SizeUint56Slice(value []uint64) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeUint64Slice returns the encoded size of uint64[]
func SizeUint64Slice(value []uint64) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// SizeUint8Slice returns the encoded size of uint8[]
func SizeUint8Slice(value []uint8) int {
	size := 32 + 32*len(value) // length + static elements
	return size
}

// DecodeAddress decodes address from ABI bytes
func DecodeAddress(data []byte) (common.Address, int, error) {
	var result common.Address
	for i := 0; i < 12; i++ {
		if data[i] != 0x00 {
			return result, 0, ErrDirtyPadding
		}
	}
	copy(result[:], data[12:32])
	return result, 32, nil
}

// DecodeAddressSlice decodes address[] from ABI bytes
func DecodeAddressSlice(data []byte) ([]common.Address, int, error) {
	// Decode length
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	length, err := DecodeSize(data)
	if err != nil {
		return nil, 0, err
	}
	data = data[32:]
	if length > len(data) || length*32 > len(data) {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		offset int
	)
	// Decode elements with static types
	result := make([]common.Address, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeAddress(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeBool decodes bool from ABI bytes
func DecodeBool(data []byte) (bool, int, error) {
	// Validate boolean encoding - only 0 or 1 are valid
	for i := 0; i < 31; i++ {
		if data[i] != 0x00 {
			return false, 0, ErrDirtyPadding
		}
	}
	switch data[31] {
	case 0x01:
		return true, 32, nil
	case 0x00:
		return false, 32, nil
	default:
		return false, 0, ErrDirtyPadding
	}
}

// DecodeBoolSlice decodes bool[] from ABI bytes
func DecodeBoolSlice(data []byte) ([]bool, int, error) {
	// Decode length
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	length, err := DecodeSize(data)
	if err != nil {
		return nil, 0, err
	}
	data = data[32:]
	if length > len(data) || length*32 > len(data) {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		offset int
	)
	// Decode elements with static types
	result := make([]bool, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeBool(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeBytes decodes bytes from ABI bytes
func DecodeBytes(data []byte) ([]byte, int, error) {
	// Decode length
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	length, err := DecodeSize(data)
	if err != nil {
		return nil, 0, err
	}
	data = data[32:]
	paddedLength := Pad32(length)
	if len(data) < paddedLength {
		return nil, 0, io.ErrUnexpectedEOF
	}
	// check padding bytes
	for i := length; i < paddedLength; i++ {
		if data[i] != 0x00 {
			return nil, 0, ErrDirtyPadding
		}
	}

	// Decode data
	result := make([]byte, length)
	copy(result, data[:length])
	return result, 32 + Pad32(length), nil
}

// DecodeBytes32 decodes bytes32 from ABI bytes
func DecodeBytes32(data []byte) ([32]byte, int, error) {
	var result [32]byte
	copy(result[:], data[:32])
	return result, 32, nil
}

// DecodeBytes32Slice decodes bytes32[] from ABI bytes
func DecodeBytes32Slice(data []byte) ([][32]byte, int, error) {
	// Decode length
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	length, err := DecodeSize(data)
	if err != nil {
		return nil, 0, err
	}
	data = data[32:]
	if length > len(data) || length*32 > len(data) {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		offset int
	)
	// Decode elements with static types
	result := make([][32]byte, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeBytes32(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeBytesSlice decodes bytes[] from ABI bytes
func DecodeBytesSlice(data []byte) ([][]byte, int, error) {
	// Decode length
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	length, err := DecodeSize(data)
	if err != nil {
		return nil, 0, err
	}
	data = data[32:]
	if length > len(data) || length*32 > len(data) {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		offset int
	)
	// Decode elements with dynamic types
	result := make([][]byte, length)
	dynamicOffset := length * 32
	for i := 0; i < length; i++ {
		tmp, err := DecodeSize(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += 32

		if dynamicOffset != tmp {
			return nil, 0, ErrInvalidOffsetForSliceElement
		}
		result[i], n, err = DecodeBytes(data[dynamicOffset:])
		if err != nil {
			return nil, 0, err
		}
		dynamicOffset += n
	}
	return result, dynamicOffset + 32, nil
}

// DecodeInt16 decodes int16 from ABI bytes
func DecodeInt16(data []byte) (int16, int, error) {
	// Validate sign extension for int16 (padding bytes: 30)
	if data[30]&0x80 != 0 {
		// Negative value, check all padding bytes are 0xFF
		for i := 0; i < 30; i++ {
			if data[i] != 0xFF {
				return 0, 0, ErrDirtyPadding
			}
		}
	} else {
		// Non-negative value, check all padding bytes are zero
		for i := 0; i < 30; i++ {
			if data[i] != 0x00 {
				return 0, 0, ErrDirtyPadding
			}
		}
	}
	result := int16(binary.BigEndian.Uint16(data[30:32]))
	return result, 32, nil
}

// DecodeInt16Slice decodes int16[] from ABI bytes
func DecodeInt16Slice(data []byte) ([]int16, int, error) {
	// Decode length
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	length, err := DecodeSize(data)
	if err != nil {
		return nil, 0, err
	}
	data = data[32:]
	if length > len(data) || length*32 > len(data) {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		offset int
	)
	// Decode elements with static types
	result := make([]int16, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeInt16(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeInt24 decodes int24 from ABI bytes
func DecodeInt24(data []byte) (int32, int, error) {
	// Validate sign extension for int24 (padding bytes: 29)
	if data[29]&0x80 != 0 {
		// Negative value, check all padding bytes are 0xFF
		for i := 0; i < 29; i++ {
			if data[i] != 0xFF {
				return 0, 0, ErrDirtyPadding
			}
		}
	} else {
		// Non-negative value, check all padding bytes are zero
		for i := 0; i < 29; i++ {
			if data[i] != 0x00 {
				return 0, 0, ErrDirtyPadding
			}
		}
	}
	// Decode int24 using int32
	result := int32(binary.BigEndian.Uint32(data[28:32]))
	return result, 32, nil
}

// DecodeInt24Slice decodes int24[] from ABI bytes
func DecodeInt24Slice(data []byte) ([]int32, int, error) {
	// Decode length
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	length, err := DecodeSize(data)
	if err != nil {
		return nil, 0, err
	}
	data = data[32:]
	if length > len(data) || length*32 > len(data) {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		offset int
	)
	// Decode elements with static types
	result := make([]int32, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeInt24(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeInt256 decodes int72 from ABI bytes
func DecodeInt256(data []byte) (*big.Int, int, error) {
	result, err := DecodeBigInt(data[:32], true)
	if err != nil {
		return nil, 0, err
	}
	return result, 32, nil
}

// DecodeInt256Slice decodes int72[] from ABI bytes
func DecodeInt256Slice(data []byte) ([]*big.Int, int, error) {
	// Decode length
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	length, err := DecodeSize(data)
	if err != nil {
		return nil, 0, err
	}
	data = data[32:]
	if length > len(data) || length*32 > len(data) {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		offset int
	)
	// Decode elements with static types
	result := make([]*big.Int, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeInt256(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeInt32 decodes int32 from ABI bytes
func DecodeInt32(data []byte) (int32, int, error) {
	// Validate sign extension for int32 (padding bytes: 28)
	if data[28]&0x80 != 0 {
		// Negative value, check all padding bytes are 0xFF
		for i := 0; i < 28; i++ {
			if data[i] != 0xFF {
				return 0, 0, ErrDirtyPadding
			}
		}
	} else {
		// Non-negative value, check all padding bytes are zero
		for i := 0; i < 28; i++ {
			if data[i] != 0x00 {
				return 0, 0, ErrDirtyPadding
			}
		}
	}
	// Decode int32 using int32
	result := int32(binary.BigEndian.Uint32(data[28:32]))
	return result, 32, nil
}

// DecodeInt32Slice decodes int32[] from ABI bytes
func DecodeInt32Slice(data []byte) ([]int32, int, error) {
	// Decode length
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	length, err := DecodeSize(data)
	if err != nil {
		return nil, 0, err
	}
	data = data[32:]
	if length > len(data) || length*32 > len(data) {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		offset int
	)
	// Decode elements with static types
	result := make([]int32, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeInt32(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeInt40 decodes int40 from ABI bytes
func DecodeInt40(data []byte) (int64, int, error) {
	// Validate sign extension for int40 (padding bytes: 27)
	if data[27]&0x80 != 0 {
		// Negative value, check all padding bytes are 0xFF
		for i := 0; i < 27; i++ {
			if data[i] != 0xFF {
				return 0, 0, ErrDirtyPadding
			}
		}
	} else {
		// Non-negative value, check all padding bytes are zero
		for i := 0; i < 27; i++ {
			if data[i] != 0x00 {
				return 0, 0, ErrDirtyPadding
			}
		}
	}
	// Decode int40 using int64
	result := int64(binary.BigEndian.Uint64(data[24:32]))
	return result, 32, nil
}

// DecodeInt40Slice decodes int40[] from ABI bytes
func DecodeInt40Slice(data []byte) ([]int64, int, error) {
	// Decode length
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	length, err := DecodeSize(data)
	if err != nil {
		return nil, 0, err
	}
	data = data[32:]
	if length > len(data) || length*32 > len(data) {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		offset int
	)
	// Decode elements with static types
	result := make([]int64, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeInt40(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeInt48 decodes int48 from ABI bytes
func DecodeInt48(data []byte) (int64, int, error) {
	// Validate sign extension for int48 (padding bytes: 26)
	if data[26]&0x80 != 0 {
		// Negative value, check all padding bytes are 0xFF
		for i := 0; i < 26; i++ {
			if data[i] != 0xFF {
				return 0, 0, ErrDirtyPadding
			}
		}
	} else {
		// Non-negative value, check all padding bytes are zero
		for i := 0; i < 26; i++ {
			if data[i] != 0x00 {
				return 0, 0, ErrDirtyPadding
			}
		}
	}
	// Decode int48 using int64
	result := int64(binary.BigEndian.Uint64(data[24:32]))
	return result, 32, nil
}

// DecodeInt48Slice decodes int48[] from ABI bytes
func DecodeInt48Slice(data []byte) ([]int64, int, error) {
	// Decode length
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	length, err := DecodeSize(data)
	if err != nil {
		return nil, 0, err
	}
	data = data[32:]
	if length > len(data) || length*32 > len(data) {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		offset int
	)
	// Decode elements with static types
	result := make([]int64, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeInt48(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeInt56 decodes int56 from ABI bytes
func DecodeInt56(data []byte) (int64, int, error) {
	// Validate sign extension for int56 (padding bytes: 25)
	if data[25]&0x80 != 0 {
		// Negative value, check all padding bytes are 0xFF
		for i := 0; i < 25; i++ {
			if data[i] != 0xFF {
				return 0, 0, ErrDirtyPadding
			}
		}
	} else {
		// Non-negative value, check all padding bytes are zero
		for i := 0; i < 25; i++ {
			if data[i] != 0x00 {
				return 0, 0, ErrDirtyPadding
			}
		}
	}
	// Decode int56 using int64
	result := int64(binary.BigEndian.Uint64(data[24:32]))
	return result, 32, nil
}

// DecodeInt56Slice decodes int56[] from ABI bytes
func DecodeInt56Slice(data []byte) ([]int64, int, error) {
	// Decode length
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	length, err := DecodeSize(data)
	if err != nil {
		return nil, 0, err
	}
	data = data[32:]
	if length > len(data) || length*32 > len(data) {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		offset int
	)
	// Decode elements with static types
	result := make([]int64, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeInt56(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeInt64 decodes int64 from ABI bytes
func DecodeInt64(data []byte) (int64, int, error) {
	// Validate sign extension for int64 (padding bytes: 24)
	if data[24]&0x80 != 0 {
		// Negative value, check all padding bytes are 0xFF
		for i := 0; i < 24; i++ {
			if data[i] != 0xFF {
				return 0, 0, ErrDirtyPadding
			}
		}
	} else {
		// Non-negative value, check all padding bytes are zero
		for i := 0; i < 24; i++ {
			if data[i] != 0x00 {
				return 0, 0, ErrDirtyPadding
			}
		}
	}
	// Decode int64 using int64
	result := int64(binary.BigEndian.Uint64(data[24:32]))
	return result, 32, nil
}

// DecodeInt64Slice decodes int64[] from ABI bytes
func DecodeInt64Slice(data []byte) ([]int64, int, error) {
	// Decode length
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	length, err := DecodeSize(data)
	if err != nil {
		return nil, 0, err
	}
	data = data[32:]
	if length > len(data) || length*32 > len(data) {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		offset int
	)
	// Decode elements with static types
	result := make([]int64, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeInt64(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeInt8 decodes int8 from ABI bytes
func DecodeInt8(data []byte) (int8, int, error) {
	// Validate sign extension for int8 (padding bytes: 31)
	if data[31]&0x80 != 0 {
		// Negative value, check all padding bytes are 0xFF
		for i := 0; i < 31; i++ {
			if data[i] != 0xFF {
				return 0, 0, ErrDirtyPadding
			}
		}
	} else {
		// Non-negative value, check all padding bytes are zero
		for i := 0; i < 31; i++ {
			if data[i] != 0x00 {
				return 0, 0, ErrDirtyPadding
			}
		}
	}
	result := int8(data[31])
	return result, 32, nil
}

// DecodeInt8Slice decodes int8[] from ABI bytes
func DecodeInt8Slice(data []byte) ([]int8, int, error) {
	// Decode length
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	length, err := DecodeSize(data)
	if err != nil {
		return nil, 0, err
	}
	data = data[32:]
	if length > len(data) || length*32 > len(data) {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		offset int
	)
	// Decode elements with static types
	result := make([]int8, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeInt8(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeString decodes string from ABI bytes
func DecodeString(data []byte) (string, int, error) {
	// Decode length
	if len(data) < 32 {
		return "", 0, io.ErrUnexpectedEOF
	}
	length, err := DecodeSize(data)
	if err != nil {
		return "", 0, err
	}
	data = data[32:]
	paddedLength := Pad32(length)
	if len(data) < paddedLength {
		return "", 0, io.ErrUnexpectedEOF
	}
	// check padding bytes
	for i := length; i < paddedLength; i++ {
		if data[i] != 0x00 {
			return "", 0, ErrDirtyPadding
		}
	}

	// Decode data
	result := string(data[:length])
	return result, 32 + Pad32(length), nil
}

// DecodeStringSlice decodes string[] from ABI bytes
func DecodeStringSlice(data []byte) ([]string, int, error) {
	// Decode length
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	length, err := DecodeSize(data)
	if err != nil {
		return nil, 0, err
	}
	data = data[32:]
	if length > len(data) || length*32 > len(data) {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		offset int
	)
	// Decode elements with dynamic types
	result := make([]string, length)
	dynamicOffset := length * 32
	for i := 0; i < length; i++ {
		tmp, err := DecodeSize(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += 32

		if dynamicOffset != tmp {
			return nil, 0, ErrInvalidOffsetForSliceElement
		}
		result[i], n, err = DecodeString(data[dynamicOffset:])
		if err != nil {
			return nil, 0, err
		}
		dynamicOffset += n
	}
	return result, dynamicOffset + 32, nil
}

// DecodeUint16 decodes uint16 from ABI bytes
func DecodeUint16(data []byte) (uint16, int, error) {
	// Validate no extra bits are set for uint16 (padding bytes: 30)
	for i := 0; i < 30; i++ {
		if data[i] != 0x00 {
			return 0, 0, ErrDirtyPadding
		}
	}
	result := binary.BigEndian.Uint16(data[30:32])
	return result, 32, nil
}

// DecodeUint16Slice decodes uint16[] from ABI bytes
func DecodeUint16Slice(data []byte) ([]uint16, int, error) {
	// Decode length
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	length, err := DecodeSize(data)
	if err != nil {
		return nil, 0, err
	}
	data = data[32:]
	if length > len(data) || length*32 > len(data) {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		offset int
	)
	// Decode elements with static types
	result := make([]uint16, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeUint16(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeUint24 decodes uint24 from ABI bytes
func DecodeUint24(data []byte) (uint32, int, error) {
	// Validate no extra bits are set for uint24 (padding bytes: 29)
	for i := 0; i < 29; i++ {
		if data[i] != 0x00 {
			return 0, 0, ErrDirtyPadding
		}
	}
	result := binary.BigEndian.Uint32(data[28:32])
	return result, 32, nil
}

// DecodeUint24Slice decodes uint24[] from ABI bytes
func DecodeUint24Slice(data []byte) ([]uint32, int, error) {
	// Decode length
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	length, err := DecodeSize(data)
	if err != nil {
		return nil, 0, err
	}
	data = data[32:]
	if length > len(data) || length*32 > len(data) {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		offset int
	)
	// Decode elements with static types
	result := make([]uint32, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeUint24(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeUint256 decodes uint72 from ABI bytes
func DecodeUint256(data []byte) (*big.Int, int, error) {
	result, err := DecodeBigInt(data[:32], false)
	if err != nil {
		return nil, 0, err
	}
	return result, 32, nil
}

// DecodeUint256Slice decodes uint72[] from ABI bytes
func DecodeUint256Slice(data []byte) ([]*big.Int, int, error) {
	// Decode length
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	length, err := DecodeSize(data)
	if err != nil {
		return nil, 0, err
	}
	data = data[32:]
	if length > len(data) || length*32 > len(data) {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		offset int
	)
	// Decode elements with static types
	result := make([]*big.Int, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeUint256(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeUint32 decodes uint32 from ABI bytes
func DecodeUint32(data []byte) (uint32, int, error) {
	// Validate no extra bits are set for uint32 (padding bytes: 28)
	for i := 0; i < 28; i++ {
		if data[i] != 0x00 {
			return 0, 0, ErrDirtyPadding
		}
	}
	result := binary.BigEndian.Uint32(data[28:32])
	return result, 32, nil
}

// DecodeUint32Slice decodes uint32[] from ABI bytes
func DecodeUint32Slice(data []byte) ([]uint32, int, error) {
	// Decode length
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	length, err := DecodeSize(data)
	if err != nil {
		return nil, 0, err
	}
	data = data[32:]
	if length > len(data) || length*32 > len(data) {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		offset int
	)
	// Decode elements with static types
	result := make([]uint32, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeUint32(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeUint40 decodes uint40 from ABI bytes
func DecodeUint40(data []byte) (uint64, int, error) {
	// Validate no extra bits are set for uint40 (padding bytes: 27)
	for i := 0; i < 27; i++ {
		if data[i] != 0x00 {
			return 0, 0, ErrDirtyPadding
		}
	}
	result := binary.BigEndian.Uint64(data[24:32])
	return result, 32, nil
}

// DecodeUint40Slice decodes uint40[] from ABI bytes
func DecodeUint40Slice(data []byte) ([]uint64, int, error) {
	// Decode length
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	length, err := DecodeSize(data)
	if err != nil {
		return nil, 0, err
	}
	data = data[32:]
	if length > len(data) || length*32 > len(data) {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		offset int
	)
	// Decode elements with static types
	result := make([]uint64, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeUint40(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeUint48 decodes uint48 from ABI bytes
func DecodeUint48(data []byte) (uint64, int, error) {
	// Validate no extra bits are set for uint48 (padding bytes: 26)
	for i := 0; i < 26; i++ {
		if data[i] != 0x00 {
			return 0, 0, ErrDirtyPadding
		}
	}
	result := binary.BigEndian.Uint64(data[24:32])
	return result, 32, nil
}

// DecodeUint48Slice decodes uint48[] from ABI bytes
func DecodeUint48Slice(data []byte) ([]uint64, int, error) {
	// Decode length
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	length, err := DecodeSize(data)
	if err != nil {
		return nil, 0, err
	}
	data = data[32:]
	if length > len(data) || length*32 > len(data) {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		offset int
	)
	// Decode elements with static types
	result := make([]uint64, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeUint48(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeUint56 decodes uint56 from ABI bytes
func DecodeUint56(data []byte) (uint64, int, error) {
	// Validate no extra bits are set for uint56 (padding bytes: 25)
	for i := 0; i < 25; i++ {
		if data[i] != 0x00 {
			return 0, 0, ErrDirtyPadding
		}
	}
	result := binary.BigEndian.Uint64(data[24:32])
	return result, 32, nil
}

// DecodeUint56Slice decodes uint56[] from ABI bytes
func DecodeUint56Slice(data []byte) ([]uint64, int, error) {
	// Decode length
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	length, err := DecodeSize(data)
	if err != nil {
		return nil, 0, err
	}
	data = data[32:]
	if length > len(data) || length*32 > len(data) {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		offset int
	)
	// Decode elements with static types
	result := make([]uint64, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeUint56(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeUint64 decodes uint64 from ABI bytes
func DecodeUint64(data []byte) (uint64, int, error) {
	// Validate no extra bits are set for uint64 (padding bytes: 24)
	for i := 0; i < 24; i++ {
		if data[i] != 0x00 {
			return 0, 0, ErrDirtyPadding
		}
	}
	result := binary.BigEndian.Uint64(data[24:32])
	return result, 32, nil
}

// DecodeUint64Slice decodes uint64[] from ABI bytes
func DecodeUint64Slice(data []byte) ([]uint64, int, error) {
	// Decode length
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	length, err := DecodeSize(data)
	if err != nil {
		return nil, 0, err
	}
	data = data[32:]
	if length > len(data) || length*32 > len(data) {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		offset int
	)
	// Decode elements with static types
	result := make([]uint64, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeUint64(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

// DecodeUint8 decodes uint8 from ABI bytes
func DecodeUint8(data []byte) (uint8, int, error) {
	// Validate no extra bits are set for uint8 (padding bytes: 31)
	for i := 0; i < 31; i++ {
		if data[i] != 0x00 {
			return 0, 0, ErrDirtyPadding
		}
	}
	result := uint8(data[31])
	return result, 32, nil
}

// DecodeUint8Slice decodes uint8[] from ABI bytes
func DecodeUint8Slice(data []byte) ([]uint8, int, error) {
	// Decode length
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	length, err := DecodeSize(data)
	if err != nil {
		return nil, 0, err
	}
	data = data[32:]
	if length > len(data) || length*32 > len(data) {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		offset int
	)
	// Decode elements with static types
	result := make([]uint8, length)
	for i := 0; i < length; i++ {
		result[i], n, err = DecodeUint8(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

var _ Method = (*StdlibCall)(nil)

const StdlibCallStaticSize = 2368

var _ Tuple = (*StdlibCall)(nil)

// StdlibCall represents an ABI tuple
type StdlibCall struct {
	Field1  bool
	Field2  common.Address
	Field3  [32]byte
	Field4  string
	Field5  []byte
	Field6  uint8
	Field7  int8
	Field8  uint16
	Field9  int16
	Field10 uint32
	Field11 int32
	Field12 uint32
	Field13 int32
	Field14 uint64
	Field15 int64
	Field16 uint64
	Field17 int64
	Field18 uint64
	Field19 int64
	Field20 uint64
	Field21 int64
	Field22 *big.Int
	Field23 *big.Int
	Field24 *big.Int
	Field25 *big.Int
	Field26 *big.Int
	Field27 *big.Int
	Field28 *big.Int
	Field29 *big.Int
	Field30 *big.Int
	Field31 *big.Int
	Field32 *big.Int
	Field33 *big.Int
	Field34 *big.Int
	Field35 *big.Int
	Field36 *big.Int
	Field37 *big.Int
	Field38 []bool
	Field39 []common.Address
	Field40 [][32]byte
	Field41 []string
	Field42 [][]byte
	Field43 []uint8
	Field44 []int8
	Field45 []uint16
	Field46 []int16
	Field47 []uint32
	Field48 []int32
	Field49 []uint32
	Field50 []int32
	Field51 []uint64
	Field52 []int64
	Field53 []uint64
	Field54 []int64
	Field55 []uint64
	Field56 []int64
	Field57 []uint64
	Field58 []int64
	Field59 []*big.Int
	Field60 []*big.Int
	Field61 []*big.Int
	Field62 []*big.Int
	Field63 []*big.Int
	Field64 []*big.Int
	Field65 []*big.Int
	Field66 []*big.Int
	Field67 []*big.Int
	Field68 []*big.Int
	Field69 []*big.Int
	Field70 []*big.Int
	Field71 []*big.Int
	Field72 []*big.Int
	Field73 []*big.Int
	Field74 []*big.Int
}

// EncodedSize returns the total encoded size of StdlibCall
func (t StdlibCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += SizeString(t.Field4)
	dynamicSize += SizeBytes(t.Field5)
	dynamicSize += SizeBoolSlice(t.Field38)
	dynamicSize += SizeAddressSlice(t.Field39)
	dynamicSize += SizeBytes32Slice(t.Field40)
	dynamicSize += SizeStringSlice(t.Field41)
	dynamicSize += SizeBytesSlice(t.Field42)
	dynamicSize += SizeUint8Slice(t.Field43)
	dynamicSize += SizeInt8Slice(t.Field44)
	dynamicSize += SizeUint16Slice(t.Field45)
	dynamicSize += SizeInt16Slice(t.Field46)
	dynamicSize += SizeUint24Slice(t.Field47)
	dynamicSize += SizeInt24Slice(t.Field48)
	dynamicSize += SizeUint32Slice(t.Field49)
	dynamicSize += SizeInt32Slice(t.Field50)
	dynamicSize += SizeUint40Slice(t.Field51)
	dynamicSize += SizeInt40Slice(t.Field52)
	dynamicSize += SizeUint48Slice(t.Field53)
	dynamicSize += SizeInt48Slice(t.Field54)
	dynamicSize += SizeUint56Slice(t.Field55)
	dynamicSize += SizeInt56Slice(t.Field56)
	dynamicSize += SizeUint64Slice(t.Field57)
	dynamicSize += SizeInt64Slice(t.Field58)
	dynamicSize += SizeUint256Slice(t.Field59)
	dynamicSize += SizeInt256Slice(t.Field60)
	dynamicSize += SizeUint256Slice(t.Field61)
	dynamicSize += SizeInt256Slice(t.Field62)
	dynamicSize += SizeUint256Slice(t.Field63)
	dynamicSize += SizeInt256Slice(t.Field64)
	dynamicSize += SizeUint256Slice(t.Field65)
	dynamicSize += SizeInt256Slice(t.Field66)
	dynamicSize += SizeUint256Slice(t.Field67)
	dynamicSize += SizeInt256Slice(t.Field68)
	dynamicSize += SizeUint256Slice(t.Field69)
	dynamicSize += SizeInt256Slice(t.Field70)
	dynamicSize += SizeUint256Slice(t.Field71)
	dynamicSize += SizeInt256Slice(t.Field72)
	dynamicSize += SizeUint256Slice(t.Field73)
	dynamicSize += SizeInt256Slice(t.Field74)

	return StdlibCallStaticSize + dynamicSize
}

// EncodeTo encodes StdlibCall to ABI bytes in the provided buffer
func (value StdlibCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := StdlibCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Field1: bool
	if _, err := EncodeBool(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	// Field Field2: address
	if _, err := EncodeAddress(value.Field2, buf[32:]); err != nil {
		return 0, err
	}

	// Field Field3: bytes32
	if _, err := EncodeBytes32(value.Field3, buf[64:]); err != nil {
		return 0, err
	}

	// Field Field4: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[96+24:96+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeString(value.Field4, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field5: bytes
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[128+24:128+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeBytes(value.Field5, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field6: uint8
	if _, err := EncodeUint8(value.Field6, buf[160:]); err != nil {
		return 0, err
	}

	// Field Field7: int8
	if _, err := EncodeInt8(value.Field7, buf[192:]); err != nil {
		return 0, err
	}

	// Field Field8: uint16
	if _, err := EncodeUint16(value.Field8, buf[224:]); err != nil {
		return 0, err
	}

	// Field Field9: int16
	if _, err := EncodeInt16(value.Field9, buf[256:]); err != nil {
		return 0, err
	}

	// Field Field10: uint24
	if _, err := EncodeUint24(value.Field10, buf[288:]); err != nil {
		return 0, err
	}

	// Field Field11: int24
	if _, err := EncodeInt24(value.Field11, buf[320:]); err != nil {
		return 0, err
	}

	// Field Field12: uint32
	if _, err := EncodeUint32(value.Field12, buf[352:]); err != nil {
		return 0, err
	}

	// Field Field13: int32
	if _, err := EncodeInt32(value.Field13, buf[384:]); err != nil {
		return 0, err
	}

	// Field Field14: uint40
	if _, err := EncodeUint40(value.Field14, buf[416:]); err != nil {
		return 0, err
	}

	// Field Field15: int40
	if _, err := EncodeInt40(value.Field15, buf[448:]); err != nil {
		return 0, err
	}

	// Field Field16: uint48
	if _, err := EncodeUint48(value.Field16, buf[480:]); err != nil {
		return 0, err
	}

	// Field Field17: int48
	if _, err := EncodeInt48(value.Field17, buf[512:]); err != nil {
		return 0, err
	}

	// Field Field18: uint56
	if _, err := EncodeUint56(value.Field18, buf[544:]); err != nil {
		return 0, err
	}

	// Field Field19: int56
	if _, err := EncodeInt56(value.Field19, buf[576:]); err != nil {
		return 0, err
	}

	// Field Field20: uint64
	if _, err := EncodeUint64(value.Field20, buf[608:]); err != nil {
		return 0, err
	}

	// Field Field21: int64
	if _, err := EncodeInt64(value.Field21, buf[640:]); err != nil {
		return 0, err
	}

	// Field Field22: uint72
	if _, err := EncodeUint256(value.Field22, buf[672:]); err != nil {
		return 0, err
	}

	// Field Field23: int72
	if _, err := EncodeInt256(value.Field23, buf[704:]); err != nil {
		return 0, err
	}

	// Field Field24: uint80
	if _, err := EncodeUint256(value.Field24, buf[736:]); err != nil {
		return 0, err
	}

	// Field Field25: int80
	if _, err := EncodeInt256(value.Field25, buf[768:]); err != nil {
		return 0, err
	}

	// Field Field26: uint88
	if _, err := EncodeUint256(value.Field26, buf[800:]); err != nil {
		return 0, err
	}

	// Field Field27: int88
	if _, err := EncodeInt256(value.Field27, buf[832:]); err != nil {
		return 0, err
	}

	// Field Field28: uint96
	if _, err := EncodeUint256(value.Field28, buf[864:]); err != nil {
		return 0, err
	}

	// Field Field29: int96
	if _, err := EncodeInt256(value.Field29, buf[896:]); err != nil {
		return 0, err
	}

	// Field Field30: uint104
	if _, err := EncodeUint256(value.Field30, buf[928:]); err != nil {
		return 0, err
	}

	// Field Field31: int104
	if _, err := EncodeInt256(value.Field31, buf[960:]); err != nil {
		return 0, err
	}

	// Field Field32: uint112
	if _, err := EncodeUint256(value.Field32, buf[992:]); err != nil {
		return 0, err
	}

	// Field Field33: int112
	if _, err := EncodeInt256(value.Field33, buf[1024:]); err != nil {
		return 0, err
	}

	// Field Field34: uint120
	if _, err := EncodeUint256(value.Field34, buf[1056:]); err != nil {
		return 0, err
	}

	// Field Field35: int120
	if _, err := EncodeInt256(value.Field35, buf[1088:]); err != nil {
		return 0, err
	}

	// Field Field36: uint128
	if _, err := EncodeUint256(value.Field36, buf[1120:]); err != nil {
		return 0, err
	}

	// Field Field37: int128
	if _, err := EncodeInt256(value.Field37, buf[1152:]); err != nil {
		return 0, err
	}

	// Field Field38: bool[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[1184+24:1184+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeBoolSlice(value.Field38, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field39: address[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[1216+24:1216+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeAddressSlice(value.Field39, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field40: bytes32[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[1248+24:1248+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeBytes32Slice(value.Field40, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field41: string[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[1280+24:1280+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeStringSlice(value.Field41, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field42: bytes[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[1312+24:1312+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeBytesSlice(value.Field42, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field43: uint8[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[1344+24:1344+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeUint8Slice(value.Field43, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field44: int8[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[1376+24:1376+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeInt8Slice(value.Field44, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field45: uint16[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[1408+24:1408+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeUint16Slice(value.Field45, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field46: int16[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[1440+24:1440+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeInt16Slice(value.Field46, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field47: uint24[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[1472+24:1472+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeUint24Slice(value.Field47, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field48: int24[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[1504+24:1504+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeInt24Slice(value.Field48, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field49: uint32[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[1536+24:1536+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeUint32Slice(value.Field49, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field50: int32[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[1568+24:1568+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeInt32Slice(value.Field50, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field51: uint40[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[1600+24:1600+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeUint40Slice(value.Field51, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field52: int40[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[1632+24:1632+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeInt40Slice(value.Field52, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field53: uint48[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[1664+24:1664+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeUint48Slice(value.Field53, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field54: int48[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[1696+24:1696+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeInt48Slice(value.Field54, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field55: uint56[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[1728+24:1728+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeUint56Slice(value.Field55, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field56: int56[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[1760+24:1760+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeInt56Slice(value.Field56, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field57: uint64[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[1792+24:1792+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeUint64Slice(value.Field57, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field58: int64[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[1824+24:1824+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeInt64Slice(value.Field58, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field59: uint72[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[1856+24:1856+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeUint256Slice(value.Field59, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field60: int72[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[1888+24:1888+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeInt256Slice(value.Field60, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field61: uint80[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[1920+24:1920+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeUint256Slice(value.Field61, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field62: int80[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[1952+24:1952+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeInt256Slice(value.Field62, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field63: uint88[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[1984+24:1984+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeUint256Slice(value.Field63, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field64: int88[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[2016+24:2016+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeInt256Slice(value.Field64, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field65: uint96[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[2048+24:2048+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeUint256Slice(value.Field65, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field66: int96[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[2080+24:2080+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeInt256Slice(value.Field66, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field67: uint104[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[2112+24:2112+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeUint256Slice(value.Field67, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field68: int104[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[2144+24:2144+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeInt256Slice(value.Field68, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field69: uint112[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[2176+24:2176+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeUint256Slice(value.Field69, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field70: int112[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[2208+24:2208+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeInt256Slice(value.Field70, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field71: uint120[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[2240+24:2240+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeUint256Slice(value.Field71, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field72: int120[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[2272+24:2272+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeInt256Slice(value.Field72, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field73: uint128[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[2304+24:2304+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeUint256Slice(value.Field73, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Field74: int128[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[2336+24:2336+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeInt256Slice(value.Field74, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes StdlibCall to ABI bytes
func (value StdlibCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes StdlibCall from ABI bytes in the provided buffer
func (t *StdlibCall) Decode(data []byte) (int, error) {
	if len(data) < 2368 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err    error
		n      int
		offset int
	)
	dynamicOffset := 2368
	// Decode static field Field1: bool
	t.Field1, _, err = DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field2: address
	t.Field2, _, err = DecodeAddress(data[32:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field3: bytes32
	t.Field3, _, err = DecodeBytes32(data[64:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Field4
	{
		offset, err = DecodeSize(data[96:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field4, n, err = DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field5
	{
		offset, err = DecodeSize(data[128:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field5, n, err = DecodeBytes(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode static field Field6: uint8
	t.Field6, _, err = DecodeUint8(data[160:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field7: int8
	t.Field7, _, err = DecodeInt8(data[192:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field8: uint16
	t.Field8, _, err = DecodeUint16(data[224:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field9: int16
	t.Field9, _, err = DecodeInt16(data[256:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field10: uint24
	t.Field10, _, err = DecodeUint24(data[288:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field11: int24
	t.Field11, _, err = DecodeInt24(data[320:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field12: uint32
	t.Field12, _, err = DecodeUint32(data[352:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field13: int32
	t.Field13, _, err = DecodeInt32(data[384:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field14: uint40
	t.Field14, _, err = DecodeUint40(data[416:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field15: int40
	t.Field15, _, err = DecodeInt40(data[448:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field16: uint48
	t.Field16, _, err = DecodeUint48(data[480:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field17: int48
	t.Field17, _, err = DecodeInt48(data[512:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field18: uint56
	t.Field18, _, err = DecodeUint56(data[544:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field19: int56
	t.Field19, _, err = DecodeInt56(data[576:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field20: uint64
	t.Field20, _, err = DecodeUint64(data[608:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field21: int64
	t.Field21, _, err = DecodeInt64(data[640:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field22: uint72
	t.Field22, _, err = DecodeUint256(data[672:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field23: int72
	t.Field23, _, err = DecodeInt256(data[704:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field24: uint80
	t.Field24, _, err = DecodeUint256(data[736:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field25: int80
	t.Field25, _, err = DecodeInt256(data[768:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field26: uint88
	t.Field26, _, err = DecodeUint256(data[800:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field27: int88
	t.Field27, _, err = DecodeInt256(data[832:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field28: uint96
	t.Field28, _, err = DecodeUint256(data[864:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field29: int96
	t.Field29, _, err = DecodeInt256(data[896:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field30: uint104
	t.Field30, _, err = DecodeUint256(data[928:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field31: int104
	t.Field31, _, err = DecodeInt256(data[960:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field32: uint112
	t.Field32, _, err = DecodeUint256(data[992:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field33: int112
	t.Field33, _, err = DecodeInt256(data[1024:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field34: uint120
	t.Field34, _, err = DecodeUint256(data[1056:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field35: int120
	t.Field35, _, err = DecodeInt256(data[1088:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field36: uint128
	t.Field36, _, err = DecodeUint256(data[1120:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field37: int128
	t.Field37, _, err = DecodeInt256(data[1152:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Field38
	{
		offset, err = DecodeSize(data[1184:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field38, n, err = DecodeBoolSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field39
	{
		offset, err = DecodeSize(data[1216:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field39, n, err = DecodeAddressSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field40
	{
		offset, err = DecodeSize(data[1248:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field40, n, err = DecodeBytes32Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field41
	{
		offset, err = DecodeSize(data[1280:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field41, n, err = DecodeStringSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field42
	{
		offset, err = DecodeSize(data[1312:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field42, n, err = DecodeBytesSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field43
	{
		offset, err = DecodeSize(data[1344:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field43, n, err = DecodeUint8Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field44
	{
		offset, err = DecodeSize(data[1376:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field44, n, err = DecodeInt8Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field45
	{
		offset, err = DecodeSize(data[1408:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field45, n, err = DecodeUint16Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field46
	{
		offset, err = DecodeSize(data[1440:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field46, n, err = DecodeInt16Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field47
	{
		offset, err = DecodeSize(data[1472:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field47, n, err = DecodeUint24Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field48
	{
		offset, err = DecodeSize(data[1504:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field48, n, err = DecodeInt24Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field49
	{
		offset, err = DecodeSize(data[1536:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field49, n, err = DecodeUint32Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field50
	{
		offset, err = DecodeSize(data[1568:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field50, n, err = DecodeInt32Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field51
	{
		offset, err = DecodeSize(data[1600:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field51, n, err = DecodeUint40Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field52
	{
		offset, err = DecodeSize(data[1632:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field52, n, err = DecodeInt40Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field53
	{
		offset, err = DecodeSize(data[1664:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field53, n, err = DecodeUint48Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field54
	{
		offset, err = DecodeSize(data[1696:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field54, n, err = DecodeInt48Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field55
	{
		offset, err = DecodeSize(data[1728:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field55, n, err = DecodeUint56Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field56
	{
		offset, err = DecodeSize(data[1760:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field56, n, err = DecodeInt56Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field57
	{
		offset, err = DecodeSize(data[1792:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field57, n, err = DecodeUint64Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field58
	{
		offset, err = DecodeSize(data[1824:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field58, n, err = DecodeInt64Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field59
	{
		offset, err = DecodeSize(data[1856:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field59, n, err = DecodeUint256Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field60
	{
		offset, err = DecodeSize(data[1888:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field60, n, err = DecodeInt256Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field61
	{
		offset, err = DecodeSize(data[1920:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field61, n, err = DecodeUint256Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field62
	{
		offset, err = DecodeSize(data[1952:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field62, n, err = DecodeInt256Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field63
	{
		offset, err = DecodeSize(data[1984:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field63, n, err = DecodeUint256Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field64
	{
		offset, err = DecodeSize(data[2016:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field64, n, err = DecodeInt256Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field65
	{
		offset, err = DecodeSize(data[2048:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field65, n, err = DecodeUint256Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field66
	{
		offset, err = DecodeSize(data[2080:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field66, n, err = DecodeInt256Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field67
	{
		offset, err = DecodeSize(data[2112:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field67, n, err = DecodeUint256Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field68
	{
		offset, err = DecodeSize(data[2144:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field68, n, err = DecodeInt256Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field69
	{
		offset, err = DecodeSize(data[2176:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field69, n, err = DecodeUint256Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field70
	{
		offset, err = DecodeSize(data[2208:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field70, n, err = DecodeInt256Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field71
	{
		offset, err = DecodeSize(data[2240:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field71, n, err = DecodeUint256Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field72
	{
		offset, err = DecodeSize(data[2272:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field72, n, err = DecodeInt256Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field73
	{
		offset, err = DecodeSize(data[2304:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field73, n, err = DecodeUint256Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Field74
	{
		offset, err = DecodeSize(data[2336:])
		if err != nil {
			return 0, err
		}
		if offset != dynamicOffset {
			return 0, ErrInvalidOffsetForDynamicField
		}
		t.Field74, n, err = DecodeInt256Slice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t StdlibCall) GetMethodName() string {
	return "stdlib"
}

// GetMethodID returns the function id
func (t StdlibCall) GetMethodID() uint32 {
	return StdlibID
}

// GetMethodSelector returns the function selector
func (t StdlibCall) GetMethodSelector() [4]byte {
	return StdlibSelector
}

// EncodeWithSelector encodes stdlib arguments to ABI bytes including function selector
func (t StdlibCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], StdlibSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewStdlibCall constructs a new StdlibCall
func NewStdlibCall(
	field1 bool,
	field2 common.Address,
	field3 [32]byte,
	field4 string,
	field5 []byte,
	field6 uint8,
	field7 int8,
	field8 uint16,
	field9 int16,
	field10 uint32,
	field11 int32,
	field12 uint32,
	field13 int32,
	field14 uint64,
	field15 int64,
	field16 uint64,
	field17 int64,
	field18 uint64,
	field19 int64,
	field20 uint64,
	field21 int64,
	field22 *big.Int,
	field23 *big.Int,
	field24 *big.Int,
	field25 *big.Int,
	field26 *big.Int,
	field27 *big.Int,
	field28 *big.Int,
	field29 *big.Int,
	field30 *big.Int,
	field31 *big.Int,
	field32 *big.Int,
	field33 *big.Int,
	field34 *big.Int,
	field35 *big.Int,
	field36 *big.Int,
	field37 *big.Int,
	field38 []bool,
	field39 []common.Address,
	field40 [][32]byte,
	field41 []string,
	field42 [][]byte,
	field43 []uint8,
	field44 []int8,
	field45 []uint16,
	field46 []int16,
	field47 []uint32,
	field48 []int32,
	field49 []uint32,
	field50 []int32,
	field51 []uint64,
	field52 []int64,
	field53 []uint64,
	field54 []int64,
	field55 []uint64,
	field56 []int64,
	field57 []uint64,
	field58 []int64,
	field59 []*big.Int,
	field60 []*big.Int,
	field61 []*big.Int,
	field62 []*big.Int,
	field63 []*big.Int,
	field64 []*big.Int,
	field65 []*big.Int,
	field66 []*big.Int,
	field67 []*big.Int,
	field68 []*big.Int,
	field69 []*big.Int,
	field70 []*big.Int,
	field71 []*big.Int,
	field72 []*big.Int,
	field73 []*big.Int,
	field74 []*big.Int,
) *StdlibCall {
	return &StdlibCall{
		Field1:  field1,
		Field2:  field2,
		Field3:  field3,
		Field4:  field4,
		Field5:  field5,
		Field6:  field6,
		Field7:  field7,
		Field8:  field8,
		Field9:  field9,
		Field10: field10,
		Field11: field11,
		Field12: field12,
		Field13: field13,
		Field14: field14,
		Field15: field15,
		Field16: field16,
		Field17: field17,
		Field18: field18,
		Field19: field19,
		Field20: field20,
		Field21: field21,
		Field22: field22,
		Field23: field23,
		Field24: field24,
		Field25: field25,
		Field26: field26,
		Field27: field27,
		Field28: field28,
		Field29: field29,
		Field30: field30,
		Field31: field31,
		Field32: field32,
		Field33: field33,
		Field34: field34,
		Field35: field35,
		Field36: field36,
		Field37: field37,
		Field38: field38,
		Field39: field39,
		Field40: field40,
		Field41: field41,
		Field42: field42,
		Field43: field43,
		Field44: field44,
		Field45: field45,
		Field46: field46,
		Field47: field47,
		Field48: field48,
		Field49: field49,
		Field50: field50,
		Field51: field51,
		Field52: field52,
		Field53: field53,
		Field54: field54,
		Field55: field55,
		Field56: field56,
		Field57: field57,
		Field58: field58,
		Field59: field59,
		Field60: field60,
		Field61: field61,
		Field62: field62,
		Field63: field63,
		Field64: field64,
		Field65: field65,
		Field66: field66,
		Field67: field67,
		Field68: field68,
		Field69: field69,
		Field70: field70,
		Field71: field71,
		Field72: field72,
		Field73: field73,
		Field74: field74,
	}
}

// StdlibReturn represents the output arguments for stdlib function
type StdlibReturn struct {
	EmptyTuple
}
