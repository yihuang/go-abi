package abi

import (
	"go/ast"
	"go/parser"
	"go/token"
	"strings"
)

// Generator creates type-safe ABI bindings from Go struct definitions
// This allows developers to define their types in Go and generate
// efficient ABI encoding/decoding code without reflection

type Generator struct {
	fset *token.FileSet
	pkg  *ast.Package
}

// NewGenerator creates a new ABI code generator
func NewGenerator() *Generator {
	return &Generator{
		fset: token.NewFileSet(),
	}
}

// GenerateFromSource generates ABI bindings from Go source code
func (g *Generator) GenerateFromSource(source string, packageName string) (string, error) {
	// Parse the source code
	f, err := parser.ParseFile(g.fset, "", source, parser.ParseComments)
	if err != nil {
		return "", err
	}

	var generated strings.Builder

	// Write header
	generated.WriteString("// Code generated by go-abi. DO NOT EDIT.\n\n")
	generated.WriteString("package " + packageName + "\n\n")
	generated.WriteString(`import (
	"math/big"
	"github.com/huangyi/go-abi/pkg/abi"
)

`)

	// Process all type declarations
	for _, decl := range f.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.TYPE {
			continue
		}

		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			// Check if this type has ABI comments
			if hasABIComment(genDecl.Doc) {
				code, err := g.generateType(typeSpec)
				if err != nil {
					return "", err
				}
				generated.WriteString(code)
				generated.WriteString("\n")
			}
		}
	}

	return generated.String(), nil
}

// hasABIComment checks if the comment contains ABI generation markers
func hasABIComment(doc *ast.CommentGroup) bool {
	if doc == nil {
		return false
	}

	for _, comment := range doc.List {
		if strings.Contains(comment.Text, "abi:") {
			return true
		}
	}

	return false
}

// generateType generates ABI encoding/decoding code for a type
func (g *Generator) generateType(typeSpec *ast.TypeSpec) (string, error) {
	var code strings.Builder

	switch t := typeSpec.Type.(type) {
	case *ast.StructType:
		return g.generateStructType(typeSpec.Name.Name, t), nil
	default:
		// For non-struct types, we might generate basic type wrappers
		return g.generateBasicType(typeSpec.Name.Name, t), nil
	}

	return code.String(), nil
}

// generateStructType generates ABI code for a struct
func (g *Generator) generateStructType(typeName string, structType *ast.StructType) string {
	var code strings.Builder

	// Generate encoder method
	code.WriteString("// " + typeName + "Encoder implements ABI encoding for " + typeName + "\n")
	code.WriteString("type " + typeName + "Encoder struct {}\n\n")

	code.WriteString("// Encode encodes " + typeName + " to ABI format\n")
	code.WriteString("func (e " + typeName + "Encoder) Encode(v " + typeName + ") ([]byte, error) {\n")
	code.WriteString(	"// TODO: Implement struct encoding\n")
	code.WriteString(	"return nil, nil\n")
	code.WriteString("}\n\n")

	// Generate decoder method
	code.WriteString("// Decode decodes ABI data to " + typeName + "\n")
	code.WriteString("func (e " + typeName + "Encoder) Decode(data []byte, v *" + typeName + ") (uint, error) {\n")
	code.WriteString(	"// TODO: Implement struct decoding\n")
	code.WriteString(	"return 0, nil\n")
	code.WriteString("}\n\n")

	return code.String()
}

// generateBasicType generates ABI code for basic types
func (g *Generator) generateBasicType(typeName string, expr ast.Expr) string {
	var code strings.Builder

	// Generate type-specific encoder
	code.WriteString("// " + typeName + "Encoder implements ABI encoding for " + typeName + "\n")
	code.WriteString("type " + typeName + "Encoder struct {}\n\n")

	code.WriteString("// Encode encodes " + typeName + " to ABI format\n")
	code.WriteString("func (e " + typeName + "Encoder) Encode(v " + typeName + ") ([]byte, error) {\n")
	code.WriteString(	"// TODO: Implement basic type encoding\n")
	code.WriteString(	"return nil, nil\n")
	code.WriteString("}\n\n")

	code.WriteString("// Decode decodes ABI data to " + typeName + "\n")
	code.WriteString("func (e " + typeName + "Encoder) Decode(data []byte, v *" + typeName + ") (uint, error) {\n")
	code.WriteString(	"// TODO: Implement basic type decoding\n")
	code.WriteString(	"return 0, nil\n")
	code.WriteString("}\n\n")

	return code.String()
}