// Code generated by go-abi. DO NOT EDIT.

package examples

import (
	"fmt"
	"github.com/ethereum/go-ethereum/common"
	"github.com/yihuang/go-abi"
	"math/big"
)

// Function selectors
var (
	// allowance(address,address)
	AllowanceSelector = [4]byte{0xdd, 0x62, 0xed, 0x3e}
	// approve(address,uint256)
	ApproveSelector = [4]byte{0x09, 0x5e, 0xa7, 0xb3}
	// balanceOf(address)
	BalanceOfSelector = [4]byte{0x70, 0xa0, 0x82, 0x31}
	// decimals()
	DecimalsSelector = [4]byte{0x31, 0x3c, 0xe5, 0x67}
	// name()
	NameSelector = [4]byte{0x06, 0xfd, 0xde, 0x03}
	// symbol()
	SymbolSelector = [4]byte{0x95, 0xd8, 0x9b, 0x41}
	// totalSupply()
	TotalSupplySelector = [4]byte{0x18, 0x16, 0x0d, 0xdd}
	// transfer(address,uint256)
	TransferSelector = [4]byte{0xa9, 0x05, 0x9c, 0xbb}
	// transferFrom(address,address,uint256)
	TransferFromSelector = [4]byte{0x23, 0xb8, 0x72, 0xdd}
)

// Big endian integer versions of function selectors
const (
	AllowanceSelectorInt    = 3714247998
	ApproveSelectorInt      = 157198259
	BalanceOfSelectorInt    = 1889567281
	DecimalsSelectorInt     = 826074471
	NameSelectorInt         = 117300739
	SymbolSelectorInt       = 2514000705
	TotalSupplySelectorInt  = 404098525
	TransferSelectorInt     = 2835717307
	TransferFromSelectorInt = 599290589
)

const AllowanceCallStaticSize = 64

// AllowanceCall represents an ABI tuple
type AllowanceCall struct {
	Owner   common.Address
	Spender common.Address
}

// EncodedSize returns the total encoded size of AllowanceCall
func (t AllowanceCall) EncodedSize() int {
	dynamicSize := 0

	return AllowanceCallStaticSize + dynamicSize
}

// EncodeTo encodes AllowanceCall to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t AllowanceCall) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := AllowanceCallStaticSize // Start dynamic data after static section

	// Owner (static)
	copy(buf[0+12:0+32], t.Owner[:])
	// Spender (static)
	copy(buf[32+12:32+32], t.Spender[:])

	return dynamicOffset, nil
}

// Encode encodes AllowanceCall to ABI bytes
func (t AllowanceCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// DecodeFrom decodes AllowanceCall from ABI bytes in the provided buffer
func (t *AllowanceCall) DecodeFrom(data0 []byte) error {
	if len(data0) < AllowanceCallStaticSize {
		return fmt.Errorf("insufficient data for AllowanceCall")
	}

	// t.Owner (static)
	copy(t.Owner[:], data0[0+12:0+32])
	// t.Spender (static)
	copy(t.Spender[:], data0[32+12:32+32])

	return nil
}

// Decode decodes AllowanceCall from ABI bytes
func (t *AllowanceCall) Decode(data []byte) error {
	return t.DecodeFrom(data)
}

// EncodeWithSelector encodes allowance arguments to ABI bytes including function selector
func (t AllowanceCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], AllowanceSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const ApproveCallStaticSize = 64

// ApproveCall represents an ABI tuple
type ApproveCall struct {
	Spender common.Address
	Amount  *big.Int
}

// EncodedSize returns the total encoded size of ApproveCall
func (t ApproveCall) EncodedSize() int {
	dynamicSize := 0

	return ApproveCallStaticSize + dynamicSize
}

// EncodeTo encodes ApproveCall to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t ApproveCall) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := ApproveCallStaticSize // Start dynamic data after static section

	// Spender (static)
	copy(buf[0+12:0+32], t.Spender[:])
	// Amount (static)

	if err := abi.EncodeBigInt(t.Amount, buf[32:64], false); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes ApproveCall to ABI bytes
func (t ApproveCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// DecodeFrom decodes ApproveCall from ABI bytes in the provided buffer
func (t *ApproveCall) DecodeFrom(data0 []byte) error {
	if len(data0) < ApproveCallStaticSize {
		return fmt.Errorf("insufficient data for ApproveCall")
	}

	// t.Spender (static)
	copy(t.Spender[:], data0[0+12:0+32])
	// t.Amount (static)
	t.Amount = new(big.Int).SetBytes(data0[32:64])

	return nil
}

// Decode decodes ApproveCall from ABI bytes
func (t *ApproveCall) Decode(data []byte) error {
	return t.DecodeFrom(data)
}

// EncodeWithSelector encodes approve arguments to ABI bytes including function selector
func (t ApproveCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], ApproveSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const BalanceOfCallStaticSize = 32

// BalanceOfCall represents an ABI tuple
type BalanceOfCall struct {
	Account common.Address
}

// EncodedSize returns the total encoded size of BalanceOfCall
func (t BalanceOfCall) EncodedSize() int {
	dynamicSize := 0

	return BalanceOfCallStaticSize + dynamicSize
}

// EncodeTo encodes BalanceOfCall to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t BalanceOfCall) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := BalanceOfCallStaticSize // Start dynamic data after static section

	// Account (static)
	copy(buf[0+12:0+32], t.Account[:])

	return dynamicOffset, nil
}

// Encode encodes BalanceOfCall to ABI bytes
func (t BalanceOfCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// DecodeFrom decodes BalanceOfCall from ABI bytes in the provided buffer
func (t *BalanceOfCall) DecodeFrom(data0 []byte) error {
	if len(data0) < BalanceOfCallStaticSize {
		return fmt.Errorf("insufficient data for BalanceOfCall")
	}

	// t.Account (static)
	copy(t.Account[:], data0[0+12:0+32])

	return nil
}

// Decode decodes BalanceOfCall from ABI bytes
func (t *BalanceOfCall) Decode(data []byte) error {
	return t.DecodeFrom(data)
}

// EncodeWithSelector encodes balanceOf arguments to ABI bytes including function selector
func (t BalanceOfCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], BalanceOfSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const TransferCallStaticSize = 64

// TransferCall represents an ABI tuple
type TransferCall struct {
	To     common.Address
	Amount *big.Int
}

// EncodedSize returns the total encoded size of TransferCall
func (t TransferCall) EncodedSize() int {
	dynamicSize := 0

	return TransferCallStaticSize + dynamicSize
}

// EncodeTo encodes TransferCall to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t TransferCall) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := TransferCallStaticSize // Start dynamic data after static section

	// To (static)
	copy(buf[0+12:0+32], t.To[:])
	// Amount (static)

	if err := abi.EncodeBigInt(t.Amount, buf[32:64], false); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TransferCall to ABI bytes
func (t TransferCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// DecodeFrom decodes TransferCall from ABI bytes in the provided buffer
func (t *TransferCall) DecodeFrom(data0 []byte) error {
	if len(data0) < TransferCallStaticSize {
		return fmt.Errorf("insufficient data for TransferCall")
	}

	// t.To (static)
	copy(t.To[:], data0[0+12:0+32])
	// t.Amount (static)
	t.Amount = new(big.Int).SetBytes(data0[32:64])

	return nil
}

// Decode decodes TransferCall from ABI bytes
func (t *TransferCall) Decode(data []byte) error {
	return t.DecodeFrom(data)
}

// EncodeWithSelector encodes transfer arguments to ABI bytes including function selector
func (t TransferCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TransferSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const TransferFromCallStaticSize = 96

// TransferFromCall represents an ABI tuple
type TransferFromCall struct {
	From   common.Address
	To     common.Address
	Amount *big.Int
}

// EncodedSize returns the total encoded size of TransferFromCall
func (t TransferFromCall) EncodedSize() int {
	dynamicSize := 0

	return TransferFromCallStaticSize + dynamicSize
}

// EncodeTo encodes TransferFromCall to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t TransferFromCall) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := TransferFromCallStaticSize // Start dynamic data after static section

	// From (static)
	copy(buf[0+12:0+32], t.From[:])
	// To (static)
	copy(buf[32+12:32+32], t.To[:])
	// Amount (static)

	if err := abi.EncodeBigInt(t.Amount, buf[64:96], false); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TransferFromCall to ABI bytes
func (t TransferFromCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// DecodeFrom decodes TransferFromCall from ABI bytes in the provided buffer
func (t *TransferFromCall) DecodeFrom(data0 []byte) error {
	if len(data0) < TransferFromCallStaticSize {
		return fmt.Errorf("insufficient data for TransferFromCall")
	}

	// t.From (static)
	copy(t.From[:], data0[0+12:0+32])
	// t.To (static)
	copy(t.To[:], data0[32+12:32+32])
	// t.Amount (static)
	t.Amount = new(big.Int).SetBytes(data0[64:96])

	return nil
}

// Decode decodes TransferFromCall from ABI bytes
func (t *TransferFromCall) Decode(data []byte) error {
	return t.DecodeFrom(data)
}

// EncodeWithSelector encodes transferFrom arguments to ABI bytes including function selector
func (t TransferFromCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TransferFromSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}
