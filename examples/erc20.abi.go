// Code generated by go-abi. DO NOT EDIT.

package examples

import (
	"fmt"
	"github.com/ethereum/go-ethereum/common"
	"github.com/yihuang/go-abi"
	"math/big"
)

const AllowanceArgsStaticSize = 64

// AllowanceArgs represents an ABI tuple
type AllowanceArgs struct {
	Owner   common.Address
	Spender common.Address
}

// EncodedSize returns the total encoded size of AllowanceArgs
func (t AllowanceArgs) EncodedSize() int {
	dynamicSize := 0

	return AllowanceArgsStaticSize + dynamicSize
}

// EncodeTo encodes AllowanceArgs to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t AllowanceArgs) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := AllowanceArgsStaticSize // Start dynamic data after static section

	// Owner (static)
	copy(buf[0+12:0+32], t.Owner[:])
	// Spender (static)
	copy(buf[32+12:32+32], t.Spender[:])

	return dynamicOffset, nil
}

// Encode encodes AllowanceArgs to ABI bytes
func (t AllowanceArgs) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// DecodeFrom decodes AllowanceArgs from ABI bytes in the provided buffer
func (t *AllowanceArgs) DecodeFrom(data0 []byte) error {
	if len(data0) < AllowanceArgsStaticSize {
		return fmt.Errorf("insufficient data for AllowanceArgs")
	}

	// t.Owner (static)
	copy(t.Owner[:], data0[0+12:0+32])
	// t.Spender (static)
	copy(t.Spender[:], data0[32+12:32+32])

	return nil
}

// Decode decodes AllowanceArgs from ABI bytes
func (t *AllowanceArgs) Decode(data []byte) error {
	return t.DecodeFrom(data)
}

// EncodeWithSelector encodes allowance arguments to ABI bytes including function selector
func (t AllowanceArgs) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], AllowanceArgsSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// AllowanceArgsSelector is the function selector for allowance(address,address)
var AllowanceArgsSelector = [4]byte{0xdd, 0x62, 0xed, 0x3e}

// Selector returns the function selector for allowance
func (AllowanceArgs) Selector() [4]byte {
	return AllowanceArgsSelector
}

const ApproveArgsStaticSize = 64

// ApproveArgs represents an ABI tuple
type ApproveArgs struct {
	Spender common.Address
	Amount  *big.Int
}

// EncodedSize returns the total encoded size of ApproveArgs
func (t ApproveArgs) EncodedSize() int {
	dynamicSize := 0

	return ApproveArgsStaticSize + dynamicSize
}

// EncodeTo encodes ApproveArgs to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t ApproveArgs) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := ApproveArgsStaticSize // Start dynamic data after static section

	// Spender (static)
	copy(buf[0+12:0+32], t.Spender[:])
	// Amount (static)

	if err := abi.EncodeBigInt(t.Amount, buf[32:64], false); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes ApproveArgs to ABI bytes
func (t ApproveArgs) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// DecodeFrom decodes ApproveArgs from ABI bytes in the provided buffer
func (t *ApproveArgs) DecodeFrom(data0 []byte) error {
	if len(data0) < ApproveArgsStaticSize {
		return fmt.Errorf("insufficient data for ApproveArgs")
	}

	// t.Spender (static)
	copy(t.Spender[:], data0[0+12:0+32])
	// t.Amount (static)
	t.Amount = new(big.Int).SetBytes(data0[32:64])

	return nil
}

// Decode decodes ApproveArgs from ABI bytes
func (t *ApproveArgs) Decode(data []byte) error {
	return t.DecodeFrom(data)
}

// EncodeWithSelector encodes approve arguments to ABI bytes including function selector
func (t ApproveArgs) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], ApproveArgsSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// ApproveArgsSelector is the function selector for approve(address,uint256)
var ApproveArgsSelector = [4]byte{0x09, 0x5e, 0xa7, 0xb3}

// Selector returns the function selector for approve
func (ApproveArgs) Selector() [4]byte {
	return ApproveArgsSelector
}

const BalanceOfArgsStaticSize = 32

// BalanceOfArgs represents an ABI tuple
type BalanceOfArgs struct {
	Account common.Address
}

// EncodedSize returns the total encoded size of BalanceOfArgs
func (t BalanceOfArgs) EncodedSize() int {
	dynamicSize := 0

	return BalanceOfArgsStaticSize + dynamicSize
}

// EncodeTo encodes BalanceOfArgs to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t BalanceOfArgs) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := BalanceOfArgsStaticSize // Start dynamic data after static section

	// Account (static)
	copy(buf[0+12:0+32], t.Account[:])

	return dynamicOffset, nil
}

// Encode encodes BalanceOfArgs to ABI bytes
func (t BalanceOfArgs) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// DecodeFrom decodes BalanceOfArgs from ABI bytes in the provided buffer
func (t *BalanceOfArgs) DecodeFrom(data0 []byte) error {
	if len(data0) < BalanceOfArgsStaticSize {
		return fmt.Errorf("insufficient data for BalanceOfArgs")
	}

	// t.Account (static)
	copy(t.Account[:], data0[0+12:0+32])

	return nil
}

// Decode decodes BalanceOfArgs from ABI bytes
func (t *BalanceOfArgs) Decode(data []byte) error {
	return t.DecodeFrom(data)
}

// EncodeWithSelector encodes balanceOf arguments to ABI bytes including function selector
func (t BalanceOfArgs) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], BalanceOfArgsSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// BalanceOfArgsSelector is the function selector for balanceOf(address)
var BalanceOfArgsSelector = [4]byte{0x70, 0xa0, 0x82, 0x31}

// Selector returns the function selector for balanceOf
func (BalanceOfArgs) Selector() [4]byte {
	return BalanceOfArgsSelector
}

const TransferArgsStaticSize = 64

// TransferArgs represents an ABI tuple
type TransferArgs struct {
	To     common.Address
	Amount *big.Int
}

// EncodedSize returns the total encoded size of TransferArgs
func (t TransferArgs) EncodedSize() int {
	dynamicSize := 0

	return TransferArgsStaticSize + dynamicSize
}

// EncodeTo encodes TransferArgs to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t TransferArgs) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := TransferArgsStaticSize // Start dynamic data after static section

	// To (static)
	copy(buf[0+12:0+32], t.To[:])
	// Amount (static)

	if err := abi.EncodeBigInt(t.Amount, buf[32:64], false); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TransferArgs to ABI bytes
func (t TransferArgs) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// DecodeFrom decodes TransferArgs from ABI bytes in the provided buffer
func (t *TransferArgs) DecodeFrom(data0 []byte) error {
	if len(data0) < TransferArgsStaticSize {
		return fmt.Errorf("insufficient data for TransferArgs")
	}

	// t.To (static)
	copy(t.To[:], data0[0+12:0+32])
	// t.Amount (static)
	t.Amount = new(big.Int).SetBytes(data0[32:64])

	return nil
}

// Decode decodes TransferArgs from ABI bytes
func (t *TransferArgs) Decode(data []byte) error {
	return t.DecodeFrom(data)
}

// EncodeWithSelector encodes transfer arguments to ABI bytes including function selector
func (t TransferArgs) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TransferArgsSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// TransferArgsSelector is the function selector for transfer(address,uint256)
var TransferArgsSelector = [4]byte{0xa9, 0x05, 0x9c, 0xbb}

// Selector returns the function selector for transfer
func (TransferArgs) Selector() [4]byte {
	return TransferArgsSelector
}

const TransferFromArgsStaticSize = 96

// TransferFromArgs represents an ABI tuple
type TransferFromArgs struct {
	From   common.Address
	To     common.Address
	Amount *big.Int
}

// EncodedSize returns the total encoded size of TransferFromArgs
func (t TransferFromArgs) EncodedSize() int {
	dynamicSize := 0

	return TransferFromArgsStaticSize + dynamicSize
}

// EncodeTo encodes TransferFromArgs to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t TransferFromArgs) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := TransferFromArgsStaticSize // Start dynamic data after static section

	// From (static)
	copy(buf[0+12:0+32], t.From[:])
	// To (static)
	copy(buf[32+12:32+32], t.To[:])
	// Amount (static)

	if err := abi.EncodeBigInt(t.Amount, buf[64:96], false); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TransferFromArgs to ABI bytes
func (t TransferFromArgs) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// DecodeFrom decodes TransferFromArgs from ABI bytes in the provided buffer
func (t *TransferFromArgs) DecodeFrom(data0 []byte) error {
	if len(data0) < TransferFromArgsStaticSize {
		return fmt.Errorf("insufficient data for TransferFromArgs")
	}

	// t.From (static)
	copy(t.From[:], data0[0+12:0+32])
	// t.To (static)
	copy(t.To[:], data0[32+12:32+32])
	// t.Amount (static)
	t.Amount = new(big.Int).SetBytes(data0[64:96])

	return nil
}

// Decode decodes TransferFromArgs from ABI bytes
func (t *TransferFromArgs) Decode(data []byte) error {
	return t.DecodeFrom(data)
}

// EncodeWithSelector encodes transferFrom arguments to ABI bytes including function selector
func (t TransferFromArgs) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TransferFromArgsSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// TransferFromArgsSelector is the function selector for transferFrom(address,address,uint256)
var TransferFromArgsSelector = [4]byte{0x23, 0xb8, 0x72, 0xdd}

// Selector returns the function selector for transferFrom
func (TransferFromArgs) Selector() [4]byte {
	return TransferFromArgsSelector
}
