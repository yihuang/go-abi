// Code generated by go-abi. DO NOT EDIT.

package examples

import (
	"encoding/binary"
	"fmt"
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/yihuang/go-abi"
)

// Function selectors
var (
	// allowance(address,address)
	AllowanceSelector = [4]byte{0xdd, 0x62, 0xed, 0x3e}
	// approve(address,uint256)
	ApproveSelector = [4]byte{0x09, 0x5e, 0xa7, 0xb3}
	// balanceOf(address)
	BalanceOfSelector = [4]byte{0x70, 0xa0, 0x82, 0x31}
	// decimals()
	DecimalsSelector = [4]byte{0x31, 0x3c, 0xe5, 0x67}
	// name()
	NameSelector = [4]byte{0x06, 0xfd, 0xde, 0x03}
	// symbol()
	SymbolSelector = [4]byte{0x95, 0xd8, 0x9b, 0x41}
	// totalSupply()
	TotalSupplySelector = [4]byte{0x18, 0x16, 0x0d, 0xdd}
	// transfer(address,uint256)
	TransferSelector = [4]byte{0xa9, 0x05, 0x9c, 0xbb}
	// transferFrom(address,address,uint256)
	TransferFromSelector = [4]byte{0x23, 0xb8, 0x72, 0xdd}
)

// Big endian integer versions of function selectors
const (
	AllowanceID    = 3714247998
	ApproveID      = 157198259
	BalanceOfID    = 1889567281
	DecimalsID     = 826074471
	NameID         = 117300739
	SymbolID       = 2514000705
	TotalSupplyID  = 404098525
	TransferID     = 2835717307
	TransferFromID = 599290589
)

// Event signatures
var (
	// Approval(address,address,uint256)
	ApprovalTopic = [32]byte{
		0x8c,
		0x5b,
		0xe1,
		0xe5,
		0xeb,
		0xec,
		0x7d,
		0x5b,
		0xd1,
		0x4f,
		0x71,
		0x42,
		0x7d,
		0x1e,
		0x84,
		0xf3,
		0xdd,
		0x03,
		0x14,
		0xc0,
		0xf7,
		0xb2,
		0x29,
		0x1e,
		0x5b,
		0x20,
		0x0a,
		0xc8,
		0xc7,
		0xc3,
		0xb9,
		0x25,
	}
	// Transfer(address,address,uint256)
	TransferTopic = [32]byte{
		0xdd,
		0xf2,
		0x52,
		0xad,
		0x1b,
		0xe2,
		0xc8,
		0x9b,
		0x69,
		0xc2,
		0xb0,
		0x68,
		0xfc,
		0x37,
		0x8d,
		0xaa,
		0x95,
		0x2b,
		0xa7,
		0xf1,
		0x63,
		0xc4,
		0xa1,
		0x16,
		0x28,
		0xf5,
		0x5a,
		0x4d,
		0xf5,
		0x23,
		0xb3,
		0xef,
	}
)

const AllowanceCallStaticSize = 64

// AllowanceCall represents an ABI tuple
type AllowanceCall struct {
	Owner   common.Address
	Spender common.Address
}

// EncodedSize returns the total encoded size of AllowanceCall
func (t AllowanceCall) EncodedSize() int {
	dynamicSize := 0

	return AllowanceCallStaticSize + dynamicSize
}

// EncodeTo encodes AllowanceCall to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t AllowanceCall) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := AllowanceCallStaticSize // Start dynamic data after static section

	// Owner (static)
	copy(buf[0+12:0+32], t.Owner[:])
	// Spender (static)
	copy(buf[32+12:32+32], t.Spender[:])

	return dynamicOffset, nil
}

// Encode encodes AllowanceCall to ABI bytes
func (t AllowanceCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes AllowanceCall from ABI bytes in the provided buffer
func (t *AllowanceCall) Decode(data0 []byte) error {
	if len(data0) < AllowanceCallStaticSize {
		return fmt.Errorf("insufficient data for AllowanceCall")
	}

	// t.Owner (static)
	copy(t.Owner[:], data0[0+12:0+32])
	// t.Spender (static)
	copy(t.Spender[:], data0[32+12:32+32])

	return nil
}

// EncodeWithSelector encodes allowance arguments to ABI bytes including function selector
func (t AllowanceCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], AllowanceSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const AllowanceReturnStaticSize = 32

// AllowanceReturn represents an ABI tuple
type AllowanceReturn struct {
	Result1 *big.Int
}

// EncodedSize returns the total encoded size of AllowanceReturn
func (t AllowanceReturn) EncodedSize() int {
	dynamicSize := 0

	return AllowanceReturnStaticSize + dynamicSize
}

// EncodeTo encodes AllowanceReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t AllowanceReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := AllowanceReturnStaticSize // Start dynamic data after static section

	// Result1 (static)

	if err := abi.EncodeBigInt(t.Result1, buf[0:32], false); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes AllowanceReturn to ABI bytes
func (t AllowanceReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes AllowanceReturn from ABI bytes in the provided buffer
func (t *AllowanceReturn) Decode(data0 []byte) error {
	if len(data0) < AllowanceReturnStaticSize {
		return fmt.Errorf("insufficient data for AllowanceReturn")
	}

	// t.Result1 (static)
	t.Result1 = new(big.Int).SetBytes(data0[0:32])

	return nil
}

const ApproveCallStaticSize = 64

// ApproveCall represents an ABI tuple
type ApproveCall struct {
	Spender common.Address
	Amount  *big.Int
}

// EncodedSize returns the total encoded size of ApproveCall
func (t ApproveCall) EncodedSize() int {
	dynamicSize := 0

	return ApproveCallStaticSize + dynamicSize
}

// EncodeTo encodes ApproveCall to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t ApproveCall) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := ApproveCallStaticSize // Start dynamic data after static section

	// Spender (static)
	copy(buf[0+12:0+32], t.Spender[:])
	// Amount (static)

	if err := abi.EncodeBigInt(t.Amount, buf[32:64], false); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes ApproveCall to ABI bytes
func (t ApproveCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes ApproveCall from ABI bytes in the provided buffer
func (t *ApproveCall) Decode(data0 []byte) error {
	if len(data0) < ApproveCallStaticSize {
		return fmt.Errorf("insufficient data for ApproveCall")
	}

	// t.Spender (static)
	copy(t.Spender[:], data0[0+12:0+32])
	// t.Amount (static)
	t.Amount = new(big.Int).SetBytes(data0[32:64])

	return nil
}

// EncodeWithSelector encodes approve arguments to ABI bytes including function selector
func (t ApproveCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], ApproveSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const ApproveReturnStaticSize = 32

// ApproveReturn represents an ABI tuple
type ApproveReturn struct {
	Result1 bool
}

// EncodedSize returns the total encoded size of ApproveReturn
func (t ApproveReturn) EncodedSize() int {
	dynamicSize := 0

	return ApproveReturnStaticSize + dynamicSize
}

// EncodeTo encodes ApproveReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t ApproveReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := ApproveReturnStaticSize // Start dynamic data after static section

	// Result1 (static)

	if t.Result1 {
		buf[0+31] = 1
	}

	return dynamicOffset, nil
}

// Encode encodes ApproveReturn to ABI bytes
func (t ApproveReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes ApproveReturn from ABI bytes in the provided buffer
func (t *ApproveReturn) Decode(data0 []byte) error {
	if len(data0) < ApproveReturnStaticSize {
		return fmt.Errorf("insufficient data for ApproveReturn")
	}

	// t.Result1 (static)
	t.Result1 = data0[0+31] == 1

	return nil
}

const BalanceOfCallStaticSize = 32

// BalanceOfCall represents an ABI tuple
type BalanceOfCall struct {
	Account common.Address
}

// EncodedSize returns the total encoded size of BalanceOfCall
func (t BalanceOfCall) EncodedSize() int {
	dynamicSize := 0

	return BalanceOfCallStaticSize + dynamicSize
}

// EncodeTo encodes BalanceOfCall to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t BalanceOfCall) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := BalanceOfCallStaticSize // Start dynamic data after static section

	// Account (static)
	copy(buf[0+12:0+32], t.Account[:])

	return dynamicOffset, nil
}

// Encode encodes BalanceOfCall to ABI bytes
func (t BalanceOfCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes BalanceOfCall from ABI bytes in the provided buffer
func (t *BalanceOfCall) Decode(data0 []byte) error {
	if len(data0) < BalanceOfCallStaticSize {
		return fmt.Errorf("insufficient data for BalanceOfCall")
	}

	// t.Account (static)
	copy(t.Account[:], data0[0+12:0+32])

	return nil
}

// EncodeWithSelector encodes balanceOf arguments to ABI bytes including function selector
func (t BalanceOfCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], BalanceOfSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const BalanceOfReturnStaticSize = 32

// BalanceOfReturn represents an ABI tuple
type BalanceOfReturn struct {
	Result1 *big.Int
}

// EncodedSize returns the total encoded size of BalanceOfReturn
func (t BalanceOfReturn) EncodedSize() int {
	dynamicSize := 0

	return BalanceOfReturnStaticSize + dynamicSize
}

// EncodeTo encodes BalanceOfReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t BalanceOfReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := BalanceOfReturnStaticSize // Start dynamic data after static section

	// Result1 (static)

	if err := abi.EncodeBigInt(t.Result1, buf[0:32], false); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes BalanceOfReturn to ABI bytes
func (t BalanceOfReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes BalanceOfReturn from ABI bytes in the provided buffer
func (t *BalanceOfReturn) Decode(data0 []byte) error {
	if len(data0) < BalanceOfReturnStaticSize {
		return fmt.Errorf("insufficient data for BalanceOfReturn")
	}

	// t.Result1 (static)
	t.Result1 = new(big.Int).SetBytes(data0[0:32])

	return nil
}

const DecimalsReturnStaticSize = 32

// DecimalsReturn represents an ABI tuple
type DecimalsReturn struct {
	Result1 uint8
}

// EncodedSize returns the total encoded size of DecimalsReturn
func (t DecimalsReturn) EncodedSize() int {
	dynamicSize := 0

	return DecimalsReturnStaticSize + dynamicSize
}

// EncodeTo encodes DecimalsReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t DecimalsReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := DecimalsReturnStaticSize // Start dynamic data after static section

	// Result1 (static)
	buf[0+31] = byte(t.Result1)

	return dynamicOffset, nil
}

// Encode encodes DecimalsReturn to ABI bytes
func (t DecimalsReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes DecimalsReturn from ABI bytes in the provided buffer
func (t *DecimalsReturn) Decode(data0 []byte) error {
	if len(data0) < DecimalsReturnStaticSize {
		return fmt.Errorf("insufficient data for DecimalsReturn")
	}

	// t.Result1 (static)
	t.Result1 = uint8(data0[0+31])

	return nil
}

const NameReturnStaticSize = 32

// NameReturn represents an ABI tuple
type NameReturn struct {
	Result1 string
}

// EncodedSize returns the total encoded size of NameReturn
func (t NameReturn) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += 32 + abi.Pad32(len(t.Result1)) // length + padded string data

	return NameReturnStaticSize + dynamicSize
}

// EncodeTo encodes NameReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t NameReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := NameReturnStaticSize // Start dynamic data after static section

	// Result1 (offset)
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))

	// Result1 (dynamic)
	// length
	binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.Result1)))
	dynamicOffset += 32

	// data
	copy(buf[dynamicOffset:], []byte(t.Result1))
	dynamicOffset += abi.Pad32(len(t.Result1))

	return dynamicOffset, nil
}

// Encode encodes NameReturn to ABI bytes
func (t NameReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes NameReturn from ABI bytes in the provided buffer
func (t *NameReturn) Decode(data0 []byte) error {
	if len(data0) < NameReturnStaticSize {
		return fmt.Errorf("insufficient data for NameReturn")
	}

	// Result1
	{
		offset := int(binary.BigEndian.Uint64(data0[0+24 : 0+32]))

		// t.Result1 (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// string data
		t.Result1 = string(data0[offset : offset+length])
	}

	return nil
}

const SymbolReturnStaticSize = 32

// SymbolReturn represents an ABI tuple
type SymbolReturn struct {
	Result1 string
}

// EncodedSize returns the total encoded size of SymbolReturn
func (t SymbolReturn) EncodedSize() int {
	dynamicSize := 0

	dynamicSize += 32 + abi.Pad32(len(t.Result1)) // length + padded string data

	return SymbolReturnStaticSize + dynamicSize
}

// EncodeTo encodes SymbolReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t SymbolReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := SymbolReturnStaticSize // Start dynamic data after static section

	// Result1 (offset)
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))

	// Result1 (dynamic)
	// length
	binary.BigEndian.PutUint64(buf[dynamicOffset+24:dynamicOffset+32], uint64(len(t.Result1)))
	dynamicOffset += 32

	// data
	copy(buf[dynamicOffset:], []byte(t.Result1))
	dynamicOffset += abi.Pad32(len(t.Result1))

	return dynamicOffset, nil
}

// Encode encodes SymbolReturn to ABI bytes
func (t SymbolReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes SymbolReturn from ABI bytes in the provided buffer
func (t *SymbolReturn) Decode(data0 []byte) error {
	if len(data0) < SymbolReturnStaticSize {
		return fmt.Errorf("insufficient data for SymbolReturn")
	}

	// Result1
	{
		offset := int(binary.BigEndian.Uint64(data0[0+24 : 0+32]))

		// t.Result1 (dynamic)
		if offset+32 > len(data0) {
			return fmt.Errorf("insufficient data for length prefix")
		}
		length := int(binary.BigEndian.Uint64(data0[offset+24 : offset+32]))
		offset += 32
		// string data
		t.Result1 = string(data0[offset : offset+length])
	}

	return nil
}

const TotalSupplyReturnStaticSize = 32

// TotalSupplyReturn represents an ABI tuple
type TotalSupplyReturn struct {
	Result1 *big.Int
}

// EncodedSize returns the total encoded size of TotalSupplyReturn
func (t TotalSupplyReturn) EncodedSize() int {
	dynamicSize := 0

	return TotalSupplyReturnStaticSize + dynamicSize
}

// EncodeTo encodes TotalSupplyReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t TotalSupplyReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := TotalSupplyReturnStaticSize // Start dynamic data after static section

	// Result1 (static)

	if err := abi.EncodeBigInt(t.Result1, buf[0:32], false); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TotalSupplyReturn to ABI bytes
func (t TotalSupplyReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TotalSupplyReturn from ABI bytes in the provided buffer
func (t *TotalSupplyReturn) Decode(data0 []byte) error {
	if len(data0) < TotalSupplyReturnStaticSize {
		return fmt.Errorf("insufficient data for TotalSupplyReturn")
	}

	// t.Result1 (static)
	t.Result1 = new(big.Int).SetBytes(data0[0:32])

	return nil
}

const TransferCallStaticSize = 64

// TransferCall represents an ABI tuple
type TransferCall struct {
	To     common.Address
	Amount *big.Int
}

// EncodedSize returns the total encoded size of TransferCall
func (t TransferCall) EncodedSize() int {
	dynamicSize := 0

	return TransferCallStaticSize + dynamicSize
}

// EncodeTo encodes TransferCall to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t TransferCall) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := TransferCallStaticSize // Start dynamic data after static section

	// To (static)
	copy(buf[0+12:0+32], t.To[:])
	// Amount (static)

	if err := abi.EncodeBigInt(t.Amount, buf[32:64], false); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TransferCall to ABI bytes
func (t TransferCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TransferCall from ABI bytes in the provided buffer
func (t *TransferCall) Decode(data0 []byte) error {
	if len(data0) < TransferCallStaticSize {
		return fmt.Errorf("insufficient data for TransferCall")
	}

	// t.To (static)
	copy(t.To[:], data0[0+12:0+32])
	// t.Amount (static)
	t.Amount = new(big.Int).SetBytes(data0[32:64])

	return nil
}

// EncodeWithSelector encodes transfer arguments to ABI bytes including function selector
func (t TransferCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TransferSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const TransferReturnStaticSize = 32

// TransferReturn represents an ABI tuple
type TransferReturn struct {
	Result1 bool
}

// EncodedSize returns the total encoded size of TransferReturn
func (t TransferReturn) EncodedSize() int {
	dynamicSize := 0

	return TransferReturnStaticSize + dynamicSize
}

// EncodeTo encodes TransferReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t TransferReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := TransferReturnStaticSize // Start dynamic data after static section

	// Result1 (static)

	if t.Result1 {
		buf[0+31] = 1
	}

	return dynamicOffset, nil
}

// Encode encodes TransferReturn to ABI bytes
func (t TransferReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TransferReturn from ABI bytes in the provided buffer
func (t *TransferReturn) Decode(data0 []byte) error {
	if len(data0) < TransferReturnStaticSize {
		return fmt.Errorf("insufficient data for TransferReturn")
	}

	// t.Result1 (static)
	t.Result1 = data0[0+31] == 1

	return nil
}

const TransferFromCallStaticSize = 96

// TransferFromCall represents an ABI tuple
type TransferFromCall struct {
	From   common.Address
	To     common.Address
	Amount *big.Int
}

// EncodedSize returns the total encoded size of TransferFromCall
func (t TransferFromCall) EncodedSize() int {
	dynamicSize := 0

	return TransferFromCallStaticSize + dynamicSize
}

// EncodeTo encodes TransferFromCall to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t TransferFromCall) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := TransferFromCallStaticSize // Start dynamic data after static section

	// From (static)
	copy(buf[0+12:0+32], t.From[:])
	// To (static)
	copy(buf[32+12:32+32], t.To[:])
	// Amount (static)

	if err := abi.EncodeBigInt(t.Amount, buf[64:96], false); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TransferFromCall to ABI bytes
func (t TransferFromCall) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TransferFromCall from ABI bytes in the provided buffer
func (t *TransferFromCall) Decode(data0 []byte) error {
	if len(data0) < TransferFromCallStaticSize {
		return fmt.Errorf("insufficient data for TransferFromCall")
	}

	// t.From (static)
	copy(t.From[:], data0[0+12:0+32])
	// t.To (static)
	copy(t.To[:], data0[32+12:32+32])
	// t.Amount (static)
	t.Amount = new(big.Int).SetBytes(data0[64:96])

	return nil
}

// EncodeWithSelector encodes transferFrom arguments to ABI bytes including function selector
func (t TransferFromCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TransferFromSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const TransferFromReturnStaticSize = 32

// TransferFromReturn represents an ABI tuple
type TransferFromReturn struct {
	Result1 bool
}

// EncodedSize returns the total encoded size of TransferFromReturn
func (t TransferFromReturn) EncodedSize() int {
	dynamicSize := 0

	return TransferFromReturnStaticSize + dynamicSize
}

// EncodeTo encodes TransferFromReturn to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t TransferFromReturn) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := TransferFromReturnStaticSize // Start dynamic data after static section

	// Result1 (static)

	if t.Result1 {
		buf[0+31] = 1
	}

	return dynamicOffset, nil
}

// Encode encodes TransferFromReturn to ABI bytes
func (t TransferFromReturn) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TransferFromReturn from ABI bytes in the provided buffer
func (t *TransferFromReturn) Decode(data0 []byte) error {
	if len(data0) < TransferFromReturnStaticSize {
		return fmt.Errorf("insufficient data for TransferFromReturn")
	}

	// t.Result1 (static)
	t.Result1 = data0[0+31] == 1

	return nil
}

// Approval represents an ABI event
type ApprovalEvent struct {
	Owner   common.Address
	Spender common.Address
	Value   *big.Int
}

// EncodeTopics encodes indexed fields of Approval event to topics
func (e ApprovalEvent) EncodeTopics() ([][32]byte, error) {
	topics := make([][32]byte, 0, 3)
	topics = append(topics, ApprovalTopic)

	// Encode indexed field Owner
	{
		buf := make([]byte, 32)
		offset := 0

		// Owner (static)
		copy(buf[offset+12:offset+32], e.Owner[:])

		var topic [32]byte
		copy(topic[:], buf)
		topics = append(topics, topic)
	}

	// Encode indexed field Spender
	{
		buf := make([]byte, 32)
		offset := 0

		// Spender (static)
		copy(buf[offset+12:offset+32], e.Spender[:])

		var topic [32]byte
		copy(topic[:], buf)
		topics = append(topics, topic)
	}

	return topics, nil
}

// DecodeTopics decodes indexed fields of Approval event from topics
func (e *ApprovalEvent) DecodeTopics(topics [][32]byte) error {
	if len(topics) < 3 {
		return fmt.Errorf("insufficient topics for Approval event")
	}

	// Skip the first topic (event signature)
	topicIndex := 1

	// Decode indexed field Owner
	if topicIndex >= len(topics) {
		return fmt.Errorf("missing topic for field Owner")
	}

	// Owner (static)
	{
		data := topics[topicIndex][:]
		offset := 0

		// e.Owner (static)
		copy(e.Owner[:], data[offset+12:offset+32])

	}
	topicIndex++

	// Decode indexed field Spender
	if topicIndex >= len(topics) {
		return fmt.Errorf("missing topic for field Spender")
	}

	// Spender (static)
	{
		data := topics[topicIndex][:]
		offset := 0

		// e.Spender (static)
		copy(e.Spender[:], data[offset+12:offset+32])

	}
	topicIndex++

	return nil
}

const ApprovalEventDataStaticSize = 32

// ApprovalEventData represents an ABI tuple
type ApprovalEventData struct {
	Value *big.Int
}

// EncodedSize returns the total encoded size of ApprovalEventData
func (t ApprovalEventData) EncodedSize() int {
	dynamicSize := 0

	return ApprovalEventDataStaticSize + dynamicSize
}

// EncodeTo encodes ApprovalEventData to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t ApprovalEventData) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := ApprovalEventDataStaticSize // Start dynamic data after static section

	// Value (static)

	if err := abi.EncodeBigInt(t.Value, buf[0:32], false); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes ApprovalEventData to ABI bytes
func (t ApprovalEventData) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes ApprovalEventData from ABI bytes in the provided buffer
func (t *ApprovalEventData) Decode(data0 []byte) error {
	if len(data0) < ApprovalEventDataStaticSize {
		return fmt.Errorf("insufficient data for ApprovalEventData")
	}

	// t.Value (static)
	t.Value = new(big.Int).SetBytes(data0[0:32])

	return nil
}

// Transfer represents an ABI event
type TransferEvent struct {
	From  common.Address
	To    common.Address
	Value *big.Int
}

// EncodeTopics encodes indexed fields of Transfer event to topics
func (e TransferEvent) EncodeTopics() ([][32]byte, error) {
	topics := make([][32]byte, 0, 3)
	topics = append(topics, TransferTopic)

	// Encode indexed field From
	{
		buf := make([]byte, 32)
		offset := 0

		// From (static)
		copy(buf[offset+12:offset+32], e.From[:])

		var topic [32]byte
		copy(topic[:], buf)
		topics = append(topics, topic)
	}

	// Encode indexed field To
	{
		buf := make([]byte, 32)
		offset := 0

		// To (static)
		copy(buf[offset+12:offset+32], e.To[:])

		var topic [32]byte
		copy(topic[:], buf)
		topics = append(topics, topic)
	}

	return topics, nil
}

// DecodeTopics decodes indexed fields of Transfer event from topics
func (e *TransferEvent) DecodeTopics(topics [][32]byte) error {
	if len(topics) < 3 {
		return fmt.Errorf("insufficient topics for Transfer event")
	}

	// Skip the first topic (event signature)
	topicIndex := 1

	// Decode indexed field From
	if topicIndex >= len(topics) {
		return fmt.Errorf("missing topic for field From")
	}

	// From (static)
	{
		data := topics[topicIndex][:]
		offset := 0

		// e.From (static)
		copy(e.From[:], data[offset+12:offset+32])

	}
	topicIndex++

	// Decode indexed field To
	if topicIndex >= len(topics) {
		return fmt.Errorf("missing topic for field To")
	}

	// To (static)
	{
		data := topics[topicIndex][:]
		offset := 0

		// e.To (static)
		copy(e.To[:], data[offset+12:offset+32])

	}
	topicIndex++

	return nil
}

const TransferEventDataStaticSize = 32

// TransferEventData represents an ABI tuple
type TransferEventData struct {
	Value *big.Int
}

// EncodedSize returns the total encoded size of TransferEventData
func (t TransferEventData) EncodedSize() int {
	dynamicSize := 0

	return TransferEventDataStaticSize + dynamicSize
}

// EncodeTo encodes TransferEventData to ABI bytes in the provided buffer
// it panics if the buffer is not large enough
func (t TransferEventData) EncodeTo(buf []byte) (int, error) {
	dynamicOffset := TransferEventDataStaticSize // Start dynamic data after static section

	// Value (static)

	if err := abi.EncodeBigInt(t.Value, buf[0:32], false); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TransferEventData to ABI bytes
func (t TransferEventData) Encode() ([]byte, error) {
	buf := make([]byte, t.EncodedSize())
	if _, err := t.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TransferEventData from ABI bytes in the provided buffer
func (t *TransferEventData) Decode(data0 []byte) error {
	if len(data0) < TransferEventDataStaticSize {
		return fmt.Errorf("insufficient data for TransferEventData")
	}

	// t.Value (static)
	t.Value = new(big.Int).SetBytes(data0[0:32])

	return nil
}
